<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Introduction to Zig - 16&nbsp; Introducing threads and parallelism in Zig</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../Chapters/15-vectors.html" rel="next">
<link href="../Chapters/13-image-filter.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-6CHJXK4CEV"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-6CHJXK4CEV', { 'anonymize_ip': true});
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../Chapters/14-threads.html"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Introducing threads and parallelism in Zig</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Introduction to Zig</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Welcome</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/01-zig-weird.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introducing Zig</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/03-structs.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Control flow, structs, modules and types</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/01-memory.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Memory and Allocators</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/01-base64.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Project 1 - Building a base64 encoder/decoder</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/02-debugging.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Debugging Zig applications</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/05-pointers.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Pointers and Optionals</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/04-http-server.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Project 2 - Building a HTTP Server from scratch</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/03-unittests.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Unit tests</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/07-build-system.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Build System</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/09-error-handling.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Error handling and unions</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/09-data-structures.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Data Structures</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/10-stack-project.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Project 3 - Building a stack data structure</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/12-file-op.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Filesystem and Input/Output (IO)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/14-zig-c-interop.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Zig interoperability with C</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/13-image-filter.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Project 4 - Developing an image filter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/14-threads.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Introducing threads and parallelism in Zig</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/15-vectors.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Introducing Vectors and SIMD</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#sec-what-thread" id="toc-sec-what-thread" class="nav-link active" data-scroll-target="#sec-what-thread"><span class="header-section-number">16.1</span> What are threads?</a></li>
  <li><a href="#threads-versus-processes" id="toc-threads-versus-processes" class="nav-link" data-scroll-target="#threads-versus-processes"><span class="header-section-number">16.2</span> Threads versus processes</a></li>
  <li><a href="#creating-a-thread" id="toc-creating-a-thread" class="nav-link" data-scroll-target="#creating-a-thread"><span class="header-section-number">16.3</span> Creating a thread</a></li>
  <li><a href="#returning-from-a-thread" id="toc-returning-from-a-thread" class="nav-link" data-scroll-target="#returning-from-a-thread"><span class="header-section-number">16.4</span> Returning from a thread</a>
  <ul class="collapse">
  <li><a href="#joining-a-thread" id="toc-joining-a-thread" class="nav-link" data-scroll-target="#joining-a-thread"><span class="header-section-number">16.4.1</span> Joining a thread</a></li>
  <li><a href="#detaching-a-thread" id="toc-detaching-a-thread" class="nav-link" data-scroll-target="#detaching-a-thread"><span class="header-section-number">16.4.2</span> Detaching a thread</a></li>
  </ul></li>
  <li><a href="#thread-pools" id="toc-thread-pools" class="nav-link" data-scroll-target="#thread-pools"><span class="header-section-number">16.5</span> Thread pools</a></li>
  <li><a href="#mutexes" id="toc-mutexes" class="nav-link" data-scroll-target="#mutexes"><span class="header-section-number">16.6</span> Mutexes</a>
  <ul class="collapse">
  <li><a href="#sec-critical-section" id="toc-sec-critical-section" class="nav-link" data-scroll-target="#sec-critical-section"><span class="header-section-number">16.6.1</span> Critical section</a></li>
  <li><a href="#sec-atomic-operation" id="toc-sec-atomic-operation" class="nav-link" data-scroll-target="#sec-atomic-operation"><span class="header-section-number">16.6.2</span> Atomic operations</a></li>
  <li><a href="#data-races-and-race-conditions" id="toc-data-races-and-race-conditions" class="nav-link" data-scroll-target="#data-races-and-race-conditions"><span class="header-section-number">16.6.3</span> Data races and race conditions</a></li>
  <li><a href="#using-mutexes-in-zig" id="toc-using-mutexes-in-zig" class="nav-link" data-scroll-target="#using-mutexes-in-zig"><span class="header-section-number">16.6.4</span> Using mutexes in Zig</a></li>
  </ul></li>
  <li><a href="#readwrite-locks" id="toc-readwrite-locks" class="nav-link" data-scroll-target="#readwrite-locks"><span class="header-section-number">16.7</span> Read/Write locks</a>
  <ul class="collapse">
  <li><a href="#exclusive-lock-vs-shared-lock" id="toc-exclusive-lock-vs-shared-lock" class="nav-link" data-scroll-target="#exclusive-lock-vs-shared-lock"><span class="header-section-number">16.7.1</span> Exclusive lock vs shared lock</a></li>
  <li><a href="#using-readwrite-locks-in-zig" id="toc-using-readwrite-locks-in-zig" class="nav-link" data-scroll-target="#using-readwrite-locks-in-zig"><span class="header-section-number">16.7.2</span> Using read/write locks in Zig</a></li>
  </ul></li>
  <li><a href="#yielding-a-thread" id="toc-yielding-a-thread" class="nav-link" data-scroll-target="#yielding-a-thread"><span class="header-section-number">16.8</span> Yielding a thread</a></li>
  <li><a href="#common-problems-in-threads" id="toc-common-problems-in-threads" class="nav-link" data-scroll-target="#common-problems-in-threads"><span class="header-section-number">16.9</span> Common problems in threads</a>
  <ul class="collapse">
  <li><a href="#deadlocks" id="toc-deadlocks" class="nav-link" data-scroll-target="#deadlocks"><span class="header-section-number">16.9.1</span> Deadlocks</a></li>
  <li><a href="#sec-not-call-join-detach" id="toc-sec-not-call-join-detach" class="nav-link" data-scroll-target="#sec-not-call-join-detach"><span class="header-section-number">16.9.2</span> Not calling <code>join()</code> or <code>detach()</code></a></li>
  <li><a href="#cancelling-or-killing-a-particular-thread" id="toc-cancelling-or-killing-a-particular-thread" class="nav-link" data-scroll-target="#cancelling-or-killing-a-particular-thread"><span class="header-section-number">16.9.3</span> Cancelling or killing a particular thread</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title"><span id="sec-thread" class="quarto-section-identifier"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Introducing threads and parallelism in Zig</span></span></h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">View Source</a></li></ul></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Threads are available in Zig through the <code>Thread</code> struct from the Zig Standard Library. This struct represents a kernel thread, and it follows a POSIX Thread pattern, meaning that, it works similarly to a thread from the <code>pthread</code> C library, which is usually available on any distribution of the GNU C Compiler (<code>gcc</code>). If you are not familiar with threads, I will give you some theory behind it first, shall we?</p>
<section id="sec-what-thread" class="level2" data-number="16.1">
<h2 data-number="16.1" class="anchored" data-anchor-id="sec-what-thread"><span class="header-section-number">16.1</span> What are threads?</h2>
<p>A thread is basically a separate context of execution. We use threads to introduce parallelism into our program, which in most cases, makes the program run faster, because we have multiple tasks being performed at the same time, parallel to each other.</p>
<p>Programs are normally single-threaded by default. Which means that each program usually runs on a single thread, or, a single context of execution. When we have only one thread running, we have no parallelism. And when we don’t have parallelism, the commands are executed sequentially, that is, only one command is executed at a time, one after another. By creating multiple threads inside our program, we start to execute multiple commands at the same time.</p>
<p>Programs that create multiple threads are very common in the wild. Because many different types of applications are well suited for parallelism. Good examples are video and photo-editing applications (e.g.&nbsp;Adobe Photoshop or DaVinci Resolve), games (e.g.&nbsp;The Witcher 3), and also web browsers (e.g.&nbsp;Google Chrome, Firefox, Microsoft Edge, etc). For example, in web browsers, threads are normally used to implement tabs. The tabs in a web browsers usually run as separate threads in the main process of the web browser. That is, each new tab that you open in your web browser usually runs on a separate thread of execution.</p>
<p>By running each tab in a separate thread, we allow all open tabs in the browser to run at the same time, and independently from each other. For example, you might have YouTube or Spotify currently open in a tab, and you are listening to some podcast in that tab while at the same time working in another tab, writing an essay on Google Docs. Even if you are not looking into the YouTube tab, you can still hear the podcast only because this YouTube tab is running in parallel with the other tab where Google Docs is running.</p>
<p>Without threads, the other alternative would be to run each tab as a completely separate process in your computer. But that would be a bad choice because just a few tabs would already consume too much power and resources from your computer. In other words, it’s very expensive to create a completely new process, compared to creating a new thread of execution. Also, the chances of you experiencing lag and overhead while using the browser would be significant. Threads are faster to create, and they also consume much, much less resources from the computer, especially because they share some resources with the main process.</p>
<p>Therefore, it’s the use of threads in modern web browsers that allow you to hear the podcast at the same time while you are writing something on Google Docs. Without threads, a web browser would probably be limited to just one single tab.</p>
<p>Threads are also well-suited for anything that involves serving requests or orders. Because serving a request takes time, and usually involves a lot of “waiting time”. In other words, we spend a lot of time in idle, waiting for something to complete. For example, consider a restaurant. Serving orders in a restaurant usually involves the following steps:</p>
<ol type="1">
<li>receive order from the client.</li>
<li>pass the order to the kitchen, and wait for the food to be cooked.</li>
<li>start cooking the food in the kitchen.</li>
<li>when the food is fully cooked deliver this food to the client.</li>
</ol>
<p>If you think about the bullet points above, you will notice that one big moment of waiting time is present in this whole process, which is while the food is being cooked inside the kitchen. While the food is being prepped, both the waiter and the client themselves are waiting for the food to be ready and delivered.</p>
<p>If we write a program to represent this restaurant, more specifically, a single-threaded program, then this program would be very inefficient. Because the program would stay in idle, waiting for a considerable amount of time on the “check if food is ready” step. Consider the code snippet exposed below that could potentially represent such program.</p>
<p>The problem with this program is the while loop. This program will spend a lot of time waiting on the while loop, doing nothing more than just checking if the food is ready. This is a waste of time. Instead of waiting for something to happen, the waiter could just send the order to the kitchen, and just move on, and continue with receiving more orders from other clients, and sending more orders to the kitchen, instead of doing nothing and waiting for the food to be ready.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> order = Order.init(<span class="st">"Pizza Margherita"</span>, n = <span class="dv">1</span>);</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> waiter = Waiter.init();</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>waiter.receive_order(order);</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>waiter.ask_kitchen_to_cook();</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> food_not_ready = <span class="cn">true</span>;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">while</span> (food_not_ready) <span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    food_not_ready = waiter.is_food_ready();</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> food = waiter.get_food_from_kitchen();</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>waiter.send_food_to_client(food);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>This is why threads would be a great fit for this program. We could use threads to free the waiters from their “waiting duties”, so they can go on with their other tasks, and receive more orders. Take a look at the next example, where I have re-written the above program into a different program that uses threads to cook and deliver the orders.</p>
<p>You can see in this program that when a waiter receives a new order from a client, this waiter executes the <code>send_order()</code> function. The only thing that this function does is to create a new thread and detaches it. Since creating a thread is a very fast operation, this <code>send_order()</code> function returns almost immediately, so the waiter spends almost no time worrying about the order, and just move on and tries to get the next order from the clients.</p>
<p>Inside the new thread created, the order gets cooked by a chef, and when the food is ready, it’s delivered to the client’s table.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> cook_and_deliver_order(order: *Order) <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> chef = Chef.init();</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> food = chef.cook(order.*);</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    chef.deliver_food(food);</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> send_order(order: Order) <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> cook_thread = Thread.spawn(</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        .<span class="op">{}</span>, cook_and_deliver_order, .<span class="op">{</span>&amp;order<span class="op">}</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    );</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    cook_thread.detach();</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> waiter = Waiter.init();</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="kw">while</span> (<span class="cn">true</span>) <span class="op">{</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> order = waiter.get_new_order();</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> (order) <span class="op">{</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        send_order(order);</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="threads-versus-processes" class="level2" data-number="16.2">
<h2 data-number="16.2" class="anchored" data-anchor-id="threads-versus-processes"><span class="header-section-number">16.2</span> Threads versus processes</h2>
<p>When we run a program, this program is executed as a <em>process</em> in the operating system. This is a one to one relationship, each program or application that you execute is a separate process in the operating system. But each program, or each process, can create and contain multiple threads inside of it. Therefore, processes and threads have a one to many relationship.</p>
<p>This also means that every thread that we create is always associated with a particular process in our computer. In other words, a thread is always a subset (or a children) of an existing process. All threads share some of the resources associated with the process from which they were created. And because threads share resources with the process, they are very good for making communication between tasks easier.</p>
<p>For example, suppose that you were developing a big and complex application that would be much simpler if you could split it in two, and make these two separate pieces talk with each other. Some programmers opt to effectively write these two pieces of the codebase as two completely separate programs, and then, they use IPC (<em>inter-process communication</em>) to make these two separate programs/processes talk to each other, and make them work together.</p>
<p>However, some programmers find IPC hard to deal with, and, as consequence, they prefer to write one piece of the codebase as the “main part of the program”, or, as the part of the code that runs as the process in the operating system, while the other piece of the codebase is written as a task to be executed in a new thread. A process and a thread can easily comunicate with each other through both control flow, and also, through data, because they share and have access to the same standard file descriptors (<code>stdout</code>, <code>stdin</code>, <code>stderr</code>), and also to the same memory space on the heap and global data section.</p>
<p>In more details, each thread that you create have a separate stack frame reserved just for that thread, which essentially means that each local object that you create inside this thread, is local to that thread, i.e., the other threads cannot see this local object. Unless this object that you have created is an object that lives on the heap. In other words, if the memory associated with this object is on the heap, then, the other threads can potentially access this object.</p>
<p>Therefore, objects that are stored in the stack are local to the thread where they were created. But objects that are stored on the heap are potentially accessible to other threads. All of this means that, each thread has its own separate stack frame, but, at the same time, all threads share the same heap, the same standard file descriptors (which means that they share the same <code>stdout</code>, <code>stdin</code>, <code>stderr</code>), and the same global data section in the program.</p>
</section>
<section id="creating-a-thread" class="level2" data-number="16.3">
<h2 data-number="16.3" class="anchored" data-anchor-id="creating-a-thread"><span class="header-section-number">16.3</span> Creating a thread</h2>
<p>We create new threads in Zig by first importing the <code>Thread</code> struct into our current Zig module and then calling the <code>spawn()</code> method of this struct, which creates (or “spawns”) a new thread of execution from our current process. This method has three arguments, which are, respectively:</p>
<ol type="1">
<li>a <code>SpawnConfig</code> object, which contains configurations for the spawn process.</li>
<li>the name of the function that is going to be executed (or that is going to be “called”) inside this new thread.</li>
<li>a list of arguments (or inputs) to be passed to the function provided in the second argument.</li>
</ol>
<p>With these three arguments, you can control how the thread gets created, and also, specify which work (or “tasks”) will be performed inside this new thread. A thread is just a separate context of execution, and we usually create new threads in our code because we want to perform some work inside this new context of execution. And we specify which exact work, or which exact steps that are going to be performed inside this context by providing the name of a function as the second argument of the <code>spawn()</code> method.</p>
<p>Thus, when this new thread gets created, this function that you provided as input to the <code>spawn()</code> method gets called, or gets executed inside this new thread. You can control the arguments, or the inputs that are passed to this function when it gets called by providing a list of arguments (or a list of inputs) in the third argument of the <code>spawn()</code> method. These arguments are passed to the function in the same order that they are provided to <code>spawn()</code>.</p>
<p>Furthermore, the <code>SpawnConfig</code> is a struct object with only two possible fields, or, two possible members, that you can set to tailor the spawn behaviour. These fields are:</p>
<ul>
<li><code>stack_size</code>: you can provide a <code>usize</code> value to specify the size (in bytes) of the thread’s stack frame. By default, this value is: <span class="math inline">\(16 \times 1024 \times 1024\)</span>.</li>
<li><code>allocator</code>: you can provide an allocator object to be used when allocating memory for the thread.</li>
</ul>
<p>To use one of these two fields (or “configs”), you just have to create a new object of type <code>SpawnConfig</code>, and provide this object as input to the <code>spawn()</code> method. But, if you are not interested in using one of these configs, and you are ok with using just the defaults, you can just provide an anonymous struct literal (<code>.{}</code>) in place of this <code>SpawnConfig</code> argument.</p>
<p>As our first, and very simple example, consider the code exposed below. Inside the same program, you can create multiple threads of execution if you want to. But, in this first example, we are creating just a single thread of execution, because we call <code>spawn()</code> only once.</p>
<p>Also, notice in this example that we are executing the function <code>do_some_work()</code> inside the new thread. Since this function receives no inputs, because it has no arguments, we have passed an empty list in this instance, or more precisely, an empty, anonymous struct (<code>.{}</code>) in the third argument of <code>spawn()</code>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> stdout = std.io.getStdOut().writer();</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> Thread = std.Thread;</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> do_some_work() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    _ = <span class="kw">try</span> stdout.write(<span class="st">"Starting the work.</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    std.time.sleep(<span class="dv">100</span> * std.time.ns_per_ms);</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    _ = <span class="kw">try</span> stdout.write(<span class="st">"Finishing the work.</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> thread = <span class="kw">try</span> Thread.spawn(.<span class="op">{}</span>, do_some_work, .<span class="op">{}</span>);</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    thread.join();</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Starting the work.Finishing the work.</code></pre>
</div>
</div>
<p>Notice the use of <code>try</code> when calling the <code>spawn()</code> method. This means that this method can return an error in some circumstances. One circumstance in particular is when you attempt to create a new thread, when you have already created too much (i.e., you have exceeded the quota of concurrent threads in your system).</p>
<p>But, if the new thread is successfully created, the <code>spawn()</code> method returns a handler object (which is just an object of type <code>Thread</code>) to this new thread. You can use this handler object to effectively control all aspects of the thread.</p>
<p>When the thread gets created, the function that you provided as input to <code>spawn()</code> gets invoked (i.e., gets called) to start the execution on this new thread. In other words, every time you call <code>spawn()</code>, not only is a new thread created, but the “start work button” of this thread is also automatically pressed. So the work being performed in this thread starts as soon as the thread is created. This is similar to how <code>pthread_create()</code> from the <code>pthreads</code> library in C works, which also starts the execution as soon as the thread is created.</p>
</section>
<section id="returning-from-a-thread" class="level2" data-number="16.4">
<h2 data-number="16.4" class="anchored" data-anchor-id="returning-from-a-thread"><span class="header-section-number">16.4</span> Returning from a thread</h2>
<p>We have learned in the previous section that the execution of the thread starts as soon as the thread is created. Now, we will learn how to “join” or “detach” a thread in Zig. “Join” and “detach” are operations that control how the thread returns to the main thread, or to the main process in our program.</p>
<p>We perform these operations by using the methods <code>join()</code> and <code>detach()</code> from the thread handler object. Every thread that you create can be marked as either <em>joinable</em> or <em>detached</em> <span class="citation" data-cites="linux_pthread_create">(<a href="../references.html#ref-linux_pthread_create" role="doc-biblioref">Linux man-pages 2024</a>)</span>. You can turn a thread into a <em>detached</em> thread by calling the <code>detach()</code> method from the thread handler object. But if you call the <code>join()</code> method instead, then this thread becomes a <em>joinable</em> thread.</p>
<p>A thread cannot be both <em>joinable</em> and <em>detached</em>. Which in general means that you cannot call both <code>join()</code> and <code>detach()</code> on the same thread. But a thread must be one of the two, meaning that, you should always call either <code>join()</code> or <code>detach()</code> over a thread. If you don’t call one of these two methods over your thread, you introduce undefined behaviour into your program, which is described in <a href="#sec-not-call-join-detach" class="quarto-xref"><span>Section 16.9.2</span></a>.</p>
<p>Now, let’s describe what each of these two methods do to your thread.</p>
<section id="joining-a-thread" class="level3" data-number="16.4.1">
<h3 data-number="16.4.1" class="anchored" data-anchor-id="joining-a-thread"><span class="header-section-number">16.4.1</span> Joining a thread</h3>
<p>When you join a thread, you are essentially saying: “Hey! Could you please wait for the thread to finish, before you continue with your execution?”. For example, if we come back to our first and simplest example of a thread in Zig, we created a single thread inside the <code>main()</code> function of our program and just called <code>join()</code> on this thread at the end. This section of the code example is reproduced below.</p>
<p>Because we are joining this new thread inside the <code>main()</code>’s scope, it means that the execution of the <code>main()</code> function is temporarily stopped, to wait for the execution of the thread to finish. That is, the execution of <code>main()</code> stops temporarily at the line where <code>join()</code> gets called, and it will continue only after the thread has finished its tasks.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> thread = <span class="kw">try</span> Thread.spawn(.<span class="op">{}</span>, do_some_work, .<span class="op">{}</span>);</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    thread.join();</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Because we have joined this new thread inside the <code>main()</code> scope, we have a guarantee that this new thread will finish before the end of the execution of <code>main()</code>. Because it’s guaranteed that <code>main()</code> will wait for the thread to finish its tasks.</p>
<p>In the example above, there are no more expressions after the <code>join()</code> call. We just have the end of the <code>main()</code>’s scope, and, therefore, the execution of our program just ends after the thread finishes its tasks, since there is nothing more to do. But what if we had more stuff to do after the join call?</p>
<p>To demonstrate this other possibility, consider the next example exposed below. Here, we create a <code>print_id()</code> function, that just receives an id as input, and prints it to <code>stdout</code>. In this example, we are creating two new threads, one after another. Then, we join the first thread, then, we wait for two whole seconds, then, at last, we join the second thread.</p>
<p>The idea behind this example is that the last <code>join()</code> call is executed only after the first thread finishes its task (i.e., the first <code>join()</code> call), and the two-second delay. If you compile and run this example, you will notice that most messages are quickly printed to <code>stdout</code>, i.e., they appear almost instantly on your screen. However, the last message (“Joining thread 2”) takes around 2 seconds to appear on the screen.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> print_id(id: *<span class="kw">const</span> <span class="dt">u8</span>) !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> stdout.print(<span class="st">"Thread ID: {d}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span>id.*<span class="op">}</span>);</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> id1: <span class="dt">u8</span> = <span class="dv">1</span>;</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> id2: <span class="dt">u8</span> = <span class="dv">2</span>;</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> thread1 = <span class="kw">try</span> Thread.spawn(.<span class="op">{}</span>, print_id, .<span class="op">{</span>&amp;id1<span class="op">}</span>);</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> thread2 = <span class="kw">try</span> Thread.spawn(.<span class="op">{}</span>, print_id, .<span class="op">{</span>&amp;id2<span class="op">}</span>);</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    _ = <span class="kw">try</span> stdout.write(<span class="st">"Joining thread 1</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    thread1.join();</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    std.time.sleep(<span class="dv">2</span> * std.time.ns_per_s);</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    _ = <span class="kw">try</span> stdout.write(<span class="st">"Joining thread 2</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    thread2.join();</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>Thread ID: Joining thread 1
1
Thread ID: 2
Joining thread 2</code></pre>
<p>This demonstrates that both threads finish their work (i.e., printing the IDs) very fast, before the two seconds of delay end. Because of that, the last <code>join()</code> call returns pretty much instantly. Because when this last <code>join()</code> call happens, the second thread has already finished its task.</p>
<p>Now, if you compile and run this example, you will also notice that, in some cases, the messages intertwine with each other. In other words, you might see the message “Joining thread 1” inserted in the middle of the message “Thread 1”, or vice-versa. This happens because:</p>
<ul>
<li>the threads are executing basically at the same time as the main process of the program (i.e., the <code>main()</code> function).</li>
<li>the threads share the same <code>stdout</code> from the main process of the program, which means that the messages that the threads produce are sent to exact same place as the messages produced by the main process.</li>
</ul>
<p>Both of these points were described previously in <a href="#sec-what-thread" class="quarto-xref"><span>Section 16.1</span></a>. So the messages might get intertwined because they are being produced and sent to the same <code>stdout</code> roughly at the same time. Anyway, when you call <code>join()</code> over a thread, the current process will wait for the thread to finish before it continues, and, when the thread finishes its task, the resources associated with this thread are automatically freed, and the current process continues with its execution.</p>
</section>
<section id="detaching-a-thread" class="level3" data-number="16.4.2">
<h3 data-number="16.4.2" class="anchored" data-anchor-id="detaching-a-thread"><span class="header-section-number">16.4.2</span> Detaching a thread</h3>
<p>When you detach a thread, the resources associated with this thread are automatically released back to the system, without the need for another thread to join with this terminated thread.</p>
<p>In other words, when you call <code>detach()</code> on a thread it’s like when your children become adults, i.e., they become independent from you. A detached thread frees itself, and when this thread finishes its tasks, it does not report the results back to you. Thus, you normally mark a thread as <em>detached</em> when you don’t need to use the return value of the thread, or when you don’t care about when exactly the thread finishes its job, i.e., the thread solves everything by itself.</p>
<p>Take the code example below. We create a new thread, detach it, and then, we just print a final message before we end our program. We use the same <code>print_id()</code> function that we have used over the previous examples.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> print_id(id: *<span class="kw">const</span> <span class="dt">u8</span>) !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> stdout.print(<span class="st">"Thread ID: {d}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span>id.*<span class="op">}</span>);</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> id1: <span class="dt">u8</span> = <span class="dv">1</span>;</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> thread1 = <span class="kw">try</span> Thread.spawn(.<span class="op">{}</span>, print_id, .<span class="op">{</span>&amp;id1<span class="op">}</span>);</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    thread1.detach();</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    _ = <span class="kw">try</span> stdout.write(<span class="st">"Finish main</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>Finish main</code></pre>
<p>Now, if you look closely at the output of this code example, you will notice that only the final message in main was printed to the console. The message that was supposed to be printed by <code>print_id()</code> did not appear in the console. Why? It’s because the main process of our program has finished first, before the thread was able to say anything.</p>
<p>And that is perfectly ok behaviour, because the thread was detached, so it was able to free itself, without the need to wait for the main process. If you ask main to sleep (or “wait”) for some extra nanoseconds, before it ends, you will likely see the message printed by <code>print_id()</code>, because you give enough time for the thread to finish before the main process ends.</p>
</section>
</section>
<section id="thread-pools" class="level2" data-number="16.5">
<h2 data-number="16.5" class="anchored" data-anchor-id="thread-pools"><span class="header-section-number">16.5</span> Thread pools</h2>
<p>Thread pools is a very popular programming pattern, which is used especially on servers and daemons processes. A thread pool is just a set of threads, or a “pool” of threads. Many programmers like to use this pattern because it makes it easier to manage and use multiple threads in your program, instead of manually creating the threads when you need them.</p>
<p>Also, using thread pools might increase performance as well in your program, especially if your program is constantly creating threads to perform short-lived tasks. In such instance, a thread pool might cause an increase in performance because you do not have be constantly creating and destroying threads all the time, so you don’t face a lot of the overhead involved in this constant process of creating and destroying threads.</p>
<p>The main idea behind a thread pool is to have a set of threads already created and ready to perform tasks at all times. You create a set of threads at the moment that your program starts, and keep these threads alive while your program runs. Each of these threads will be either performing a task, or waiting for a task to be assigned. Every time a new task emerges in your program, this task is added to a “queue of tasks”, and the moment that a thread becomes available and ready to perform a new task, this thread takes the next task from the “queue of tasks”, and it simply performs the task.</p>
<p>The Zig Standard Library offers a thread pool implementation on the <code>std.Thread.Pool</code> struct. You create a new instance of a <code>Pool</code> object by providing a <code>Pool.Options</code> object as input to the <code>init()</code> method of this struct. A <code>Pool.Options</code> object, is a struct object that contains configurations for the pool of threads. The most important settings in this struct object are the members <code>n_jobs</code> and <code>allocator</code>. As the name suggests, the member <code>allocator</code> should receive an allocator object, while the member <code>n_jobs</code> specifies the number of threads to be created and maintained in this pool.</p>
<p>Consider the example exposed below, that demonstrates how can we create a new thread pool object. Here, we create a <code>Pool.Options</code> object that contains a general purpose allocator object, and also, the <code>n_jobs</code> member was set to 4, which means that the thread pool will create and use 4 threads.</p>
<p>Also notice that the <code>pool</code> object was initially set to <code>undefined</code>. This allow us to initially declare the thread pool object, but not properly instantiate the underlying memory of the object. You have to initially declare your thread pool object by using <code>undefined</code> like this, because the <code>init()</code> method of <code>Pool</code> needs to have an initial pointer to properly instantiate the object.</p>
<p>So, just remember to create your thread pool object by using <code>undefined</code>, and then, after that, you call the <code>init()</code> method over the object. You should also not forget to call the <code>deinit()</code> method over the thread pool object, once you are done with it, to release the resources allocated for the thread pool. Otherwise, you will have a memory leak in your program.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> Pool = std.Thread.Pool;</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> gpa = std.heap.GeneralPurposeAllocator(.<span class="op">{}</span>)<span class="op">{}</span>;</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> allocator = gpa.allocator();</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> opt = Pool.Options<span class="op">{</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        .n_jobs = <span class="dv">4</span>,</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        .allocator = allocator,</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>;</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> pool: Pool = <span class="cn">undefined</span>;</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> pool.init(opt);</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">defer</span> pool.deinit();</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Now that we know how to create <code>Pool</code> objects, we have to understand how to assign tasks to be executed by the threads in this pool object. To assign a task to be performed by a thread, we need to call the <code>spawn()</code> method from the thread pool object.</p>
<p>This <code>spawn()</code> method works identical to the <code>spawn()</code> method from the <code>Thread</code> object. The method has almost the same arguments as the previous one, more precisely, we don’t have to provide a <code>SpawnConfig</code> object in this case. But instead of creating a new thread, this <code>spawn()</code> method from the thread pool object just registers a new task in the internal “queue of tasks” to be performed, and any available thread in the pool will get this task, and it will simply perform the task.</p>
<p>In the example below, we are using our previous <code>print_id()</code> function once again. But you may notice that the <code>print_id()</code> function is a little different this time, because now we are using <code>catch</code> instead of <code>try</code> in the <code>print()</code> call. Currently, the <code>Pool</code> struct only supports functions that don’t return errors as tasks. Thus, when assigning tasks to threads in a thread pool, it is essential to use functions that don’t return errors. That is why we are using <code>catch</code> here, so that the <code>print_id()</code> function don’t return an error.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> print_id(id: *<span class="kw">const</span> <span class="dt">u8</span>) <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    _ = stdout.print(<span class="st">"Thread ID: {d}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span>id.*<span class="op">}</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">catch</span> <span class="dt">void</span>;</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> id1: <span class="dt">u8</span> = <span class="dv">1</span>;</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> id2: <span class="dt">u8</span> = <span class="dv">2</span>;</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="kw">try</span> pool.spawn(print_id, .<span class="op">{</span>&amp;id1<span class="op">}</span>);</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="kw">try</span> pool.spawn(print_id, .<span class="op">{</span>&amp;id2<span class="op">}</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>This limitation should probably not exist, and, in fact, it’s already on the radar of the Zig team to fix this issue, and it’s being tracked in an <a href="https://github.com/ziglang/zig/issues/18810">open issue</a><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. So, if you do need to provide a function that might return an error as the task to be performed by the threads in the thread pool, then, you are either limited to:</p>
<ul>
<li>implementing your own thread pool that does not have this limitation.</li>
<li>wait for the Zig team to actually fix this issue.</li>
</ul>
</section>
<section id="mutexes" class="level2" data-number="16.6">
<h2 data-number="16.6" class="anchored" data-anchor-id="mutexes"><span class="header-section-number">16.6</span> Mutexes</h2>
<p>Mutexes are a classic component of every thread library. In essence, a mutex is a <em>Mutually Exclusive Flag</em>, and this flag acts like a type of “lock”, or as a gate keeper to a particular section of your code. Mutexes are related to thread synchronization, more specifically, they prevent you from having some classic race conditions in your program, and, therefore, major bugs and undefined behaviour that are usually difficult to track and understand.</p>
<p>The main idea behind a mutex is to help us to control the execution of a particular section of the code, and to prevent two or more threads from executing this particular section of the code at the same time. Many programmers like to compare a mutex to a bathroom door (which typically has a lock). When a thread locks its own mutex object, it’s like if the bathroom door was locked. Therefore, other people (in this case, other threads) who want to use the same bathroom at the same time must be patient and simply wait for the current occupant (or thread) to unlock the door and get out of the bathroom.</p>
<p>Some other programmers also like to explain mutexes by using the analogy of “each person will have their turn to speak”. This is the analogy used in the <a href="https://www.youtube.com/watch?v=7ENFeb-J75k&amp;ab_channel=Computerphile"><em>Multithreading Code</em> video from the Computerphile project</a><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>. Imagine if you are in a conversation circle. There is a moderator in this circle, which is the person that decides who has the right to speak at that particular moment. The moderator gives a green card (or some sort of an authorization card) to the person that is going to speak, and, as a result, everyone else must be silent and hear this person that has the green card. When the person finishes talking, they give the green card back to the moderator, and the moderator decides who is going to talk next, and delivers the green card to that person. And the cycle goes on like this.</p>
<p>A mutex acts like the moderator in this conversation circle. The mutex authorizes one single thread to execute a specific section of the code, and it also blocks the other threads from executing this same section of the code. If these other threads want to execute this same piece of the code, they are forced to wait for the the authorized thread to finish first. When the authorized thread finishes executing this code, the mutex authorizes the next thread to execute this code, while the remaining threads remain blocked. Therefore, a mutex is like a moderator that does a “each thread will have their turn to execute this section of the code” type of control.</p>
<p>Mutexes are especially used to prevent data race problems from happening. A data race problem happens when two or more threads are trying to read from or write to the same shared object at the same time. So, when you have an object that is shared will all threads, and, you want to avoid two or more threads from accessing this same object at the same time, you can use a mutex to lock the part of the code that access this specific object. When a thread tries to run this code that is locked by a mutex, this thread stops its execution, and patiently waits for this section of the codebase to be unlocked to continue.</p>
<p>Notice that mutexes are normally used to lock areas of the codebase that access/modify data that is <strong>shared</strong> with all threads, i.e., objects that are either stored in the global data section, or in the heap space of your program. So mutexes are not normally used on areas of the codebase that access/modify objects that are local to the thread.</p>
<section id="sec-critical-section" class="level3" data-number="16.6.1">
<h3 data-number="16.6.1" class="anchored" data-anchor-id="sec-critical-section"><span class="header-section-number">16.6.1</span> Critical section</h3>
<p>Critical section is a concept commonly associated with mutexes and thread synchronization. In essence, a critical section is the section of the program that a thread access/modify a shared resource (i.e., an object, a file descriptor, something that all threads have access to). In other words, a critical section is the section of the program where race conditions might happen, and, therefore, where undefined behaviour can be introduced into the program.</p>
<p>When we use mutexes in our program, the critical section defines the area of the codebase that we want to lock. So we normally lock the mutex object at the beginning of the critical section, and then, we unlock it at the end of the critical section. The two bullet points exposed below comes from the “Critical Section” article from GeekFromGeeks, and they summarise well the role that a critical section plays in the thread synchronization problem <span class="citation" data-cites="geeks_critical_section">(<a href="../references.html#ref-geeks_critical_section" role="doc-biblioref">Geeks for Geeks 2024</a>)</span>.</p>
<ol type="1">
<li>The critical section must be executed as an atomic operation, which means that once one thread or process has entered the critical section, all other threads or processes must wait until the executing thread or process exits the critical section. The purpose of synchronization mechanisms is to ensure that only one thread or process can execute the critical section at a time.</li>
<li>The concept of a critical section is central to synchronization in computer systems, as it is necessary to ensure that multiple threads or processes can execute concurrently without interfering with each other. Various synchronization mechanisms such as semaphores, mutexes, monitors, and condition variables are used to implement critical sections and ensure that shared resources are accessed in a mutually exclusive manner.</li>
</ol>
</section>
<section id="sec-atomic-operation" class="level3" data-number="16.6.2">
<h3 data-number="16.6.2" class="anchored" data-anchor-id="sec-atomic-operation"><span class="header-section-number">16.6.2</span> Atomic operations</h3>
<p>You will also see the term “atomic operation” a lot when reading about threads, race conditions and mutexes. In summary, an operation is categorized as “atomic” when a context switch cannot occur in the middle of the operation. In other words, this operation is always done from beginning to end, without interruptions of another process or operation in the middle of its execution phase.</p>
<p>Not many operations today are atomic. But why do atomic operations matter here? It’s because data races (which is a type of a race condition) cannot happen on operations that are atomic. So if a particular line in your code performs an atomic operation, then this line will never suffer from a data race problem. Therefore, programmers sometimes use an atomic operation to protect themselves from data race problems in their code.</p>
<p>When you have an operation that is compiled into just one single assembly instruction, this operation might be atomic, because it’s just one assembly instruction. But this is not guaranteed. This is usually true for old CPU architectures (such as <code>x86</code>). But nowadays, most assembly instructions in modern CPU architectures are broken down into multiple micro-tasks, which inherently makes the operation non-atomic, even if it consists of a single assembly instruction.</p>
<p>The Zig Standard Library offers some atomic functionality in the <code>std.atomic</code> module. In this module, you will find a public and generic function called <code>Value()</code>. With this function we create an “atomic object”, which is a value that contains some native atomic operations, most notably, a <code>load()</code> and a <code>fetchAdd()</code> operation. If you have experience with multithreading in C++, you probably have recognized this pattern. So yes, this generic “atomic object” in Zig is essentially identical to the template struct <code>std::atomic</code> from the C++ Standard Library. It’s important to emphasize that only primitive data types (i.e., the types presented in <a href="01-zig-weird.html#sec-primitive-data-types" class="quarto-xref"><span>Section 1.5</span></a>) are supported by these atomic operations in Zig.</p>
</section>
<section id="data-races-and-race-conditions" class="level3" data-number="16.6.3">
<h3 data-number="16.6.3" class="anchored" data-anchor-id="data-races-and-race-conditions"><span class="header-section-number">16.6.3</span> Data races and race conditions</h3>
<p>To understand why mutexes are used, we need to understand better the problem that they seek to solve, which can be summarized into data race problems. A data race problem is a type of a race condition, which happens when one thread is accessing a particular memory location (i.e., a particular shared object) at the same time that another thread is trying to write/save new data into this same memory location (i.e., the same shared object).</p>
<p>We can simply define a race condition as any type of bug in your program that is based on a “who gets there first” problem. A data race problem is a type of a race condition, because it occurs when two or more parties are trying to read and write into the same memory location at the same time, and, therefore, the end result of this operation depends completely on who gets to this memory location first. As a consequence, a program that has a data race problem will likely produce a different result each time that we execute it.</p>
<p>Thus, race conditions produce undefined behaviour and unpredictability because the program produces a different answer each time a different person gets to the target location before the others. And, we have no easy way to either predict or control who is getting to this target location first. In other words, each time your program runs, you may get a different answer because a different person, function, or part of the code finishes its tasks before the others.</p>
<p>As an example, consider the code snippet exposed below. In this example, we create a global counter variable, and we also create an <code>increment()</code> function, whose job is to just increment this global counter variable in a for loop.</p>
<p>Since the for loop iterates 1 hundred thousand times, and, we create two separate threads in this code example, what number do you expect to see in the final message printed to <code>stdout</code>? The answer should be 2 hundred thousand. Right? Well, in theory, this program was supposed to print 2 hundred thousand at the end, but in practice, every time that I execute this program I get a different answer.</p>
<p>In the example exposed below, you can see that this time the end result was 117254, instead of the expected 200000. The second time I executed this program, I got the number 108592 as the result. So the end result of this program is varying, but it never gets to the expected 200000 that we want.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Global counter variable</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> counter: <span class="dt">usize</span> = <span class="dv">0</span>;</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Function to increment the counter</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> increment() <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span> (<span class="dv">0</span>..<span class="dv">100000</span>) |_| <span class="op">{</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        counter += <span class="dv">1</span>;</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> thr1 = <span class="kw">try</span> Thread.spawn(.<span class="op">{}</span>, increment, .<span class="op">{}</span>);</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> thr2 = <span class="kw">try</span> Thread.spawn(.<span class="op">{}</span>, increment, .<span class="op">{}</span>);</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    thr1.join();</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    thr2.join();</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> stdout.print(<span class="st">"Couter value: {d}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span>counter<span class="op">}</span>);</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>Couter value: 117254</code></pre>
<p>Why this is happening? The answer is: because this program contains a data race problem. This program would print the correct number 200000 if and only if the first thread finishes its tasks before the second thread starts to execute. But that is very unlikely to happen. Because the process of creating the thread is too fast, and therefore, both threads start to execute roughly at the same time. If you change this code to add some nanoseconds of sleep between the first and the second calls to <code>spawn()</code>, you will increase the chances of the program producing the “correct result”.</p>
<p>So the data race problem happens because both threads are reading and writing to the same memory location at roughly the same time. In this example, each thread is essentially performing three basic operations at each iteration of the for loop, which are:</p>
<ol type="1">
<li>reading the current value of <code>count</code>.</li>
<li>incrementing this value by 1.</li>
<li>writing the result back into <code>count</code>.</li>
</ol>
<p>Ideally, a thread B should read the value of <code>count</code>, only after the other thread A has finished writing the incremented value back into the <code>count</code> object. Therefore, in the ideal scenario, which is demonstrated in <a href="#tbl-data-race-ideal" class="quarto-xref">Table&nbsp;<span>16.1</span></a>, the threads should work in sync with each other. But the reality is that these threads are out of sync, and because of that, they suffer from a data race problem, which is demonstrated in <a href="#tbl-data-race-not" class="quarto-xref">Table&nbsp;<span>16.2</span></a>.</p>
<p>Notice that, in the data race scenario (<a href="#tbl-data-race-not" class="quarto-xref">Table&nbsp;<span>16.2</span></a>), the read performed by a thread B happens before the write operation of thread A, and that ultimately leads to wrong results at the end of the program. Because when thread B reads the value of the <code>count</code> variable, thread A is still processing the initial value from <code>count</code>, and has not yet written the new, incremented value back to <code>count</code>. As a result, thread B ends up reading the same initial (or “old”) value from <code>count</code> instead of the updated, incremented value that thread A would have written.</p>
<div id="tbl-data-race-ideal" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-data-race-ideal-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;16.1: An ideal scenario for two threads incrementing the same integer value
</figcaption>
<div aria-describedby="tbl-data-race-ideal-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<thead>
<tr class="header">
<th>Thread 1</th>
<th>Thread 2</th>
<th>Integer value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>read value</td>
<td></td>
<td>0</td>
</tr>
<tr class="even">
<td>increment</td>
<td></td>
<td>1</td>
</tr>
<tr class="odd">
<td>write value</td>
<td></td>
<td>1</td>
</tr>
<tr class="even">
<td></td>
<td>read value</td>
<td>1</td>
</tr>
<tr class="odd">
<td></td>
<td>increment</td>
<td>2</td>
</tr>
<tr class="even">
<td></td>
<td>write value</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<div id="tbl-data-race-not" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-data-race-not-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;16.2: A data race scenario when two threads are incrementing the same integer value
</figcaption>
<div aria-describedby="tbl-data-race-not-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<thead>
<tr class="header">
<th>Thread 1</th>
<th>Thread 2</th>
<th>Integer value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>read value</td>
<td></td>
<td>0</td>
</tr>
<tr class="even">
<td></td>
<td>read value</td>
<td>0</td>
</tr>
<tr class="odd">
<td>increment</td>
<td></td>
<td>1</td>
</tr>
<tr class="even">
<td></td>
<td>increment</td>
<td>1</td>
</tr>
<tr class="odd">
<td>write value</td>
<td></td>
<td>1</td>
</tr>
<tr class="even">
<td></td>
<td>write value</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>If you think about these diagrams exposed in form of tables, you will notice that they relate back to our discussion of atomic operations in <a href="#sec-atomic-operation" class="quarto-xref"><span>Section 16.6.2</span></a>. Remember, atomic operations are operations that the CPU executes from beginning to end, without interruptions from other threads or processes. So, the scenario exposed in <a href="#tbl-data-race-ideal" class="quarto-xref">Table&nbsp;<span>16.1</span></a> does not suffer from a data race, because the operations performed by thread A are not interrupted in the middle by the operations from thread B.</p>
<p>If we also think about the discussion of critical section from <a href="#sec-critical-section" class="quarto-xref"><span>Section 16.6.1</span></a>, we can identify the section that representes the critical section of the program, which is the section that is vulnerable to data race conditions. In this example, the critical section of the program is the line where we increment the <code>counter</code> variable (<code>counter += 1</code>). So, ideally, we want to use a mutex, and lock right before this line, and then unlock right after this line.</p>
</section>
<section id="using-mutexes-in-zig" class="level3" data-number="16.6.4">
<h3 data-number="16.6.4" class="anchored" data-anchor-id="using-mutexes-in-zig"><span class="header-section-number">16.6.4</span> Using mutexes in Zig</h3>
<p>Now that we know the problem that mutexes seek to solve, we can learn how to use them in Zig. Mutexes in Zig are available through the <code>std.Thread.Mutex</code> struct from the Zig Standard Library. If we take the same code from the previous example, and improve it with mutexes, to solve our data race problem, we get the code example below.</p>
<p>Notice that this time, we had to alter the <code>increment()</code> function to receive a pointer to the <code>Mutex</code> object as input. All that we need to do, to make this program safe against data race problems, is to call the <code>lock()</code> method at the beginning of the critical section, and then, call <code>unlock()</code> at the end of the critical section. Notice that the output of this program is now the correct number of 200000.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> stdout = std.io.getStdOut().writer();</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> Thread = std.Thread;</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> Mutex = std.Thread.Mutex;</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> counter: <span class="dt">usize</span> = <span class="dv">0</span>;</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> increment(mutex: *Mutex) <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span> (<span class="dv">0</span>..<span class="dv">100000</span>) |_| <span class="op">{</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>        mutex.lock();</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>        counter += <span class="dv">1</span>;</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>        mutex.unlock();</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> mutex: Mutex = .<span class="op">{}</span>;</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> thr1 = <span class="kw">try</span> Thread.spawn(.<span class="op">{}</span>, increment, .<span class="op">{</span>&amp;mutex<span class="op">}</span>);</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> thr2 = <span class="kw">try</span> Thread.spawn(.<span class="op">{}</span>, increment, .<span class="op">{</span>&amp;mutex<span class="op">}</span>);</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>    thr1.join();</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>    thr2.join();</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> stdout.print(<span class="st">"Couter value: {d}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span>counter<span class="op">}</span>);</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Couter value: 200000</code></pre>
</div>
</div>
</section>
</section>
<section id="readwrite-locks" class="level2" data-number="16.7">
<h2 data-number="16.7" class="anchored" data-anchor-id="readwrite-locks"><span class="header-section-number">16.7</span> Read/Write locks</h2>
<p>Mutexes are normally used when it’s not always safe for two or more threads running the same piece of code at the same time. In contrast, read/write locks are normally used in situations where you have a mixture of scenarios, i.e., there are some pieces of the codebase that are safe to run in parallel, and other pieces that are not safe.</p>
<p>For example, suppose that you have multiple threads that uses the same shared file in the filesystem to store some configurations, or statistics. If two or more threads try to read the data from this same file at the same time, nothing bad happens. So this part of the codebase is perfectly safe to be executed in parallel, with multiple threads reading the same file at the same time.</p>
<p>However, if two or more threads try to write data into this same file at the same time, then we cause some race condition problems. So this other part of the codebase is not safe to be executed in parallel. More specifically, a thread might end up writing data in the middle of the data written by the other thread. This process of two or more threads writing to the same location might lead to data corruption. This specific situation is usually called a <em>torn write</em>.</p>
<p>Thus, what we can extract from this example is that there are certain types of operations that cause a race condition, but there are also other types of operations that do not cause a race condition problem. You could also say that there are types of operations that are susceptible to race condition problems, and there are other types of operations that are not.</p>
<p>A read/write lock is a type of lock that acknowledges the existence of this specific scenario, and you can use this type of lock to control which parts of the codebase are safe to run in parallel and which parts are not.</p>
<section id="exclusive-lock-vs-shared-lock" class="level3" data-number="16.7.1">
<h3 data-number="16.7.1" class="anchored" data-anchor-id="exclusive-lock-vs-shared-lock"><span class="header-section-number">16.7.1</span> Exclusive lock vs shared lock</h3>
<p>Therefore, a read/write lock is a little different from a mutex. Because a mutex is always an <em>exclusive lock</em>, meaning that, only one thread is allowed to execute at all times. With an exclusive lock, the other threads are always “excluded”, i.e., they are always blocked from executing. But in a read/write lock, the other threads might be authorized to run at the same time, depending on the type of lock that they acquire.</p>
<p>We have two types of locks in a read/write lock, which are: an exclusive lock and a shared lock. An exclusive lock works exactly the same as a mutex, while a shared lock is a lock that does not block the other threads from running at the same time. In the <code>pthreads</code> C library, read/write locks are available through the <code>pthread_rwlock_t</code> C struct. With this C struct, you can create:</p>
<ul>
<li>a “write lock”, which corresponds to an exclusive lock.</li>
<li>a “read lock”, which corresponds to a shared lock.</li>
</ul>
<p>The terminology might be a little different compared to Zig. But the meaning is still the same. Therefore, just remember this relationship, write locks are exclusive locks, while read locks are shared locks.</p>
<p>When a thread tries to acquire a read lock (i.e., a shared lock), this thread gets the shared lock if and only if another thread does not currently hold a write lock (i.e., an exclusive lock), and also if there are no other threads already in the queue, waiting for their turn to acquire a write lock. In other words, the thread in the queue has attempted to get a write lock earlier, but this thread was blocked because there was another thread running that already had a write lock. As a consequence, this thread is in the queue to get a write lock, and it’s currently waiting for the other thread with a write lock to finish its execution.</p>
<p>When a thread tries to acquire a read lock, but it fails in acquiring this read lock, either because there is a thread with a write lock already running, or because there is a thread in the queue to get a write lock, the execution of this thread is instantly blocked, i.e., paused. This thread will indefinitely attempt to get the read lock, and its execution will be unblocked (or unpaused) only after this thread successfully acquires the read lock.</p>
<p>If you think deeply about this dynamic between read locks versus write locks, you might notice that a read lock is basically a safety mechanism. More specifically, it’s a way for us to allow a particular thread to run together with the other threads only when it’s safe to. In other words, if there is currently a thread with a write lock running, then it’s very likely not safe for the thread that is trying to acquire the read lock to run now. As a consequence, the read lock protects this thread from running into dangerous waters, and patiently waits for the “write lock” thread to finishes its tasks before it continues.</p>
<p>On the other hand, if there are only “read lock” (i.e., “shared lock”) threads currently running (i.e., not a single “write lock” thread currently exists), then it is perfectly safe for this thread that is acquiring the read lock to run in parallel with the other threads. As a result, the read lock just allows for this thread to run together with the other threads.</p>
<p>Thus, by using read locks (shared locks) in conjunction with write locks (exclusive locks), we can control which regions or sections of our multithreaded code is safe to have parallelism, and which sections are not safe to have parallelism.</p>
</section>
<section id="using-readwrite-locks-in-zig" class="level3" data-number="16.7.2">
<h3 data-number="16.7.2" class="anchored" data-anchor-id="using-readwrite-locks-in-zig"><span class="header-section-number">16.7.2</span> Using read/write locks in Zig</h3>
<p>The Zig Standard Library supports read/write locks through the <code>std.Thread.RwLock</code> module. If you want a particular thread to acquire a shared lock (i.e., a read lock), you should call the <code>lockShared()</code> method from the <code>RwLock</code> object. But, if you want this thread to acquire an exclusive lock (i.e., a write lock) instead, then you should call the <code>lock()</code> method from the <code>RwLock</code> object.</p>
<p>As with mutexes, we also have to unlock the shared or exclusive locks that we acquire through a read/write lock object, once we are at the end of our “critical section”. If you have acquired an exclusive lock, then, you unlock this exclusive lock by calling the <code>unlock()</code> method from the read/write lock object. In contrast, if you have acquired a shared lock instead, then, call <code>unlockShared()</code> to unlock this shared lock.</p>
<p>As a simple example, the snippet below creates three separate threads responsible for reading the current value in a <code>counter</code> object, and it also creates another thread responsible for writing new data into the <code>counter</code> object (incrementing it, more specifically).</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> counter: <span class="dt">u32</span> = <span class="dv">0</span>;</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> reader(lock: *RwLock) !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">while</span> (<span class="cn">true</span>) <span class="op">{</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>        lock.lockShared();</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">const</span> v: <span class="dt">u32</span> = counter;</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">try</span> stdout.print(<span class="st">"{d}"</span>, .<span class="op">{</span>v<span class="op">}</span>);</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>        lock.unlockShared();</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>        std.time.sleep(<span class="dv">2</span> * std.time.ns_per_s);</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> writer(lock: *RwLock) <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">while</span> (<span class="cn">true</span>) <span class="op">{</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>        lock.lock();</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>        counter += <span class="dv">1</span>;</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>        lock.unlock();</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>        std.time.sleep(<span class="dv">2</span> * std.time.ns_per_s);</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> lock: RwLock = .<span class="op">{}</span>;</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> thr1 = <span class="kw">try</span> Thread.spawn(.<span class="op">{}</span>, reader, .<span class="op">{</span>&amp;lock<span class="op">}</span>);</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> thr2 = <span class="kw">try</span> Thread.spawn(.<span class="op">{}</span>, reader, .<span class="op">{</span>&amp;lock<span class="op">}</span>);</span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> thr3 = <span class="kw">try</span> Thread.spawn(.<span class="op">{}</span>, reader, .<span class="op">{</span>&amp;lock<span class="op">}</span>);</span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> wthread = <span class="kw">try</span> Thread.spawn(.<span class="op">{}</span>, writer, .<span class="op">{</span>&amp;lock<span class="op">}</span>);</span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>    thr1.join();</span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>    thr2.join();</span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a>    thr3.join();</span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a>    wthread.join();</span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="yielding-a-thread" class="level2" data-number="16.8">
<h2 data-number="16.8" class="anchored" data-anchor-id="yielding-a-thread"><span class="header-section-number">16.8</span> Yielding a thread</h2>
<p>The <code>Thread</code> struct supports yielding through the <code>yield()</code> method. Yielding a thread means that the execution of the thread is temporarily stopped, and it moves to the end of the priority queue managed by the scheduler of your operating system.</p>
<p>That is, when you yield a thread, you are essentially saying the following to your OS: “Hey! Could you please stop executing this thread for now, and comeback to continue it later?”. You could also interpret this yield operation as: “Could you please deprioritize this thread, to focus on doing other things instead?”. So this yield operation is also a way for you to stop a particular thread, so that you can work and prioritize other threads instead.</p>
<p>It’s important to say that, yielding a thread is a “not so common” thread operation these days. In other words, not many programmers use yielding in production, simply because it’s hard to use this operation and make it work properly, and also, there are better alternatives. Most programmers prefer to use <code>join()</code> instead. In fact, most of the time, when you see someone using this “yield” operation in some code example, they are usually doing so to help debug race conditions in their applications. That is, this “yield” operation is mostly used as a debug tool nowadays.</p>
<p>Anyway, if you want to yield a thread, just call the <code>yield()</code> method from it, like this:</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>thread.yield();</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="common-problems-in-threads" class="level2" data-number="16.9">
<h2 data-number="16.9" class="anchored" data-anchor-id="common-problems-in-threads"><span class="header-section-number">16.9</span> Common problems in threads</h2>
<section id="deadlocks" class="level3" data-number="16.9.1">
<h3 data-number="16.9.1" class="anchored" data-anchor-id="deadlocks"><span class="header-section-number">16.9.1</span> Deadlocks</h3>
<p>A deadlock occurs when two or more threads are blocked forever, waiting for each other to release a resource. This usually happens when multiple locks are involved, and the order of acquiring them is not well managed.</p>
<p>The code example below demonstrates a deadlock situation. We have two different threads that execute two different functions (<code>work1()</code> and <code>work2()</code>) in this example. And we also have two separate mutexes. If you compile and run this code example, you will notice that the program just runs indefinitely, without ending.</p>
<p>When we look into the first thread, which executes the <code>work1()</code> function, we can notice that this function acquires the <code>mut1</code> lock first. Because this is the first operation that is executed inside this thread, which is the first thread created in the program. After that, the function sleeps for 1 second, to simulate some type of work, and then, the function tries to acquire the <code>mut2</code> lock.</p>
<p>On the other hand, when we look into the second thread, which executes the <code>work2()</code> function, we can see that this function acquires the <code>mut2</code> lock first. Because when this thread gets created and it tries to acquire this <code>mut2</code> lock, the first thread is still sleeping on that “sleep 1 second” line. After acquiring <code>mut2</code>, the <code>work2()</code> function also sleeps for 1 second, to simulate some type of work, and then the function tries to acquire the <code>mut1</code> lock.</p>
<p>This creates a deadlock situation, because after the “sleep for 1 second” line in both threads, thread 1 is trying to acquire the <code>mut2</code> lock, but this lock is currently being used by thread 2. However, at this moment, thread 2 is also trying to acquire the <code>mut1</code> lock, which is currently being used by thread 1. Therefore, both threads end up waiting for ever. Waiting for their peer to free the lock that they want to acquire.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> mut1: Mutex = .<span class="op">{}</span>; <span class="kw">var</span> mut2: Mutex = .<span class="op">{}</span>;</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> work1() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    mut1.lock();</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    std.time.sleep(<span class="dv">1</span> * std.time.ns_per_s);</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    mut2.lock();</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    _ = <span class="kw">try</span> stdout.write(<span class="st">"Doing some work 1</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    mut2.unlock(); mut1.unlock();</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> work2() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    mut2.lock();</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    std.time.sleep(<span class="dv">1</span> * std.time.ns_per_s);</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    mut1.lock();</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    _ = <span class="kw">try</span> stdout.write(<span class="st">"Doing some work 1</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    mut1.unlock(); mut2.unlock();</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> thr1 = <span class="kw">try</span> Thread.spawn(.<span class="op">{}</span>, work1, .<span class="op">{}</span>);</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> thr2 = <span class="kw">try</span> Thread.spawn(.<span class="op">{}</span>, work2, .<span class="op">{}</span>);</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>    thr1.join();</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>    thr2.join();</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="sec-not-call-join-detach" class="level3" data-number="16.9.2">
<h3 data-number="16.9.2" class="anchored" data-anchor-id="sec-not-call-join-detach"><span class="header-section-number">16.9.2</span> Not calling <code>join()</code> or <code>detach()</code></h3>
<p>When you do not call either <code>join()</code> or <code>detach()</code> over a thread, then this thread becomes a “zombie thread”, because it does not have a clear “return point”. You could also interpret this as: “nobody is properly responsible for managing the thread”. When we don’t establish if a thread is either <em>joinable</em> or <em>detached</em>, nobody becomes responsible for dealing with the return value of this thread, and also, nobody becomes responsible for clearing (or freeing) the resources associated with this thread.</p>
<p>You don’t want to be in this situation, so remember to always use <code>join()</code> or <code>detach()</code> on the threads that you create. When you don’t use one of these methods, we lose control over the thread, and its resources are never freed (i.e., you have leaked resources in the system).</p>
</section>
<section id="cancelling-or-killing-a-particular-thread" class="level3" data-number="16.9.3">
<h3 data-number="16.9.3" class="anchored" data-anchor-id="cancelling-or-killing-a-particular-thread"><span class="header-section-number">16.9.3</span> Cancelling or killing a particular thread</h3>
<p>When we think about the <code>pthreads</code> C library, there is a possible way to asynchronously kill or cancel a thread, which is by sending a <code>SIGTERM</code> signal to the thread through the <code>pthread_kill()</code> function. But canceling a thread like this is bad. It’s dangerously bad. As a consequence, the Zig implementation of threads does not have a similar function, or, a similar way to asynchronously cancel or kill a thread.</p>
<p>Therefore, if you want to cancel a thread in the middle of its execution in Zig, then one good strategy that you can take is to use control flow in conjunction with <code>join()</code>. More specifically, you can design your thread around a while loop that is constantly checking if the thread should continue running. If it’s time to cancel the thread, we could make the while loop break, and join the thread with the main thread by calling <code>join()</code>.</p>
<p>The code example below demonstrates to some extent this strategy. Here, we are using control flow to break the while loop, and exit the thread earlier than what we have initially planned to. This example also demonstrates how can we use atomic objects in Zig with the <code>Value()</code> generic function that we have mentioned in <a href="#sec-atomic-operation" class="quarto-xref"><span>Section 16.6.2</span></a>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> Thread = std.Thread;</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> stdout = std.io.getStdOut().writer();</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> running = std.atomic.Value(<span class="dt">bool</span>).init(<span class="cn">true</span>);</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> counter: <span class="dt">u64</span> = <span class="dv">0</span>;</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> do_more_work() <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    std.time.sleep(<span class="dv">2</span> * std.time.ns_per_s);</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> work() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">while</span> (running.load(.monotonic)) <span class="op">{</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">for</span> (<span class="dv">0</span>..<span class="dv">10000</span>) |_| <span class="op">{</span> counter += <span class="dv">1</span>; <span class="op">}</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> (counter &lt; <span class="dv">15000</span>) <span class="op">{</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>            _ = <span class="kw">try</span> stdout.write(</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>                <span class="st">"Time to cancel the thread.</span><span class="sc">\n</span><span class="st">"</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>            );</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>            running.store(<span class="cn">false</span>, .monotonic);</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>            _ = <span class="kw">try</span> stdout.write(<span class="st">"Time to do more work.</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>            do_more_work();</span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>            running.store(<span class="cn">false</span>, .monotonic);</span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> thread = <span class="kw">try</span> Thread.spawn(.<span class="op">{}</span>, work, .<span class="op">{}</span>);</span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a>    thread.join();</span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Time to cancel the thread.</code></pre>
</div>
</div>


<!-- -->

<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-geeks_critical_section" class="csl-entry" role="listitem">
Geeks for Geeks. 2024. <span>“Critical Section.”</span> <span>Geeks for Geeks</span>. <a href="https://www.geeksforgeeks.org/g-fact-70/">https://www.geeksforgeeks.org/g-fact-70/</a>.
</div>
<div id="ref-linux_pthread_create" class="csl-entry" role="listitem">
Linux man-pages. 2024. <span>“Pthread_create(3) — Linux Manual Page.”</span> <a href="https://man7.org/linux/man-pages/man3/pthread_create.3.html">https://man7.org/linux/man-pages/man3/pthread_create.3.html</a>.
</div>
</div>
</section>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p><a href="https://github.com/ziglang/zig/issues/18810" class="uri">https://github.com/ziglang/zig/issues/18810</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><a href="https://www.youtube.com/watch?v=7ENFeb-J75k&amp;ab_channel=Computerphile" class="uri">https://www.youtube.com/watch?v=7ENFeb-J75k&amp;ab_channel=Computerphile</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
<<<<<<< HEAD
=======
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
>>>>>>> origin
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../Chapters/13-image-filter.html" class="pagination-link" aria-label="Project 4 - Developing an image filter">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Project 4 - Developing an image filter</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../Chapters/15-vectors.html" class="pagination-link" aria-label="Introducing Vectors and SIMD">
        <span class="nav-page-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Introducing Vectors and SIMD</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb21" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="an">engine:</span><span class="co"> knitr</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="an">knitr:</span><span class="co"> true</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="an">syntax-definition:</span><span class="co"> "../Assets/zig.xml"</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a><span class="co">#| include: false</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a><span class="fu">source</span>(<span class="st">"../zig_engine.R"</span>)</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>knitr<span class="sc">::</span>opts_chunk<span class="sc">$</span><span class="fu">set</span>(</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    <span class="at">auto_main =</span> <span class="cn">FALSE</span>,</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>    <span class="at">build_type =</span> <span class="st">"lib"</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a><span class="fu"># Introducing threads and parallelism in Zig {#sec-thread}</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>Threads are available in Zig through the <span class="in">`Thread`</span> struct from the Zig Standard Library.</span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>This struct represents a kernel thread, and it follows a POSIX Thread pattern,</span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>meaning that, it works similarly to a thread from the <span class="in">`pthread`</span> C library, which is usually available on any distribution</span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>of the GNU C Compiler (<span class="in">`gcc`</span>). If you are not familiar with threads, I will give you some theory behind it first, shall we?</span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a><span class="fu">## What are threads? {#sec-what-thread}</span></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>A thread is basically a separate context of execution.</span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a>We use threads to introduce parallelism into our program,</span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a>which in most cases, makes the program run faster, because we have multiple tasks</span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a>being performed at the same time, parallel to each other.</span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a>Programs are normally single-threaded by default. Which means that each program</span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a>usually runs on a single thread, or, a single context of execution. When we have only one thread running, we have no</span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a>parallelism. And when we don't have parallelism, the commands are executed sequentially, that is,</span>
<span id="cb21-38"><a href="#cb21-38" aria-hidden="true" tabindex="-1"></a>only one command is executed at a time, one after another. By creating multiple threads inside our program,</span>
<span id="cb21-39"><a href="#cb21-39" aria-hidden="true" tabindex="-1"></a>we start to execute multiple commands at the same time.</span>
<span id="cb21-40"><a href="#cb21-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-41"><a href="#cb21-41" aria-hidden="true" tabindex="-1"></a>Programs that create multiple threads are very common in the wild. Because many different types</span>
<span id="cb21-42"><a href="#cb21-42" aria-hidden="true" tabindex="-1"></a>of applications are well suited for parallelism. Good examples are video and photo-editing applications</span>
<span id="cb21-43"><a href="#cb21-43" aria-hidden="true" tabindex="-1"></a>(e.g. Adobe Photoshop or DaVinci Resolve), games (e.g. The Witcher 3), and also web browsers</span>
<span id="cb21-44"><a href="#cb21-44" aria-hidden="true" tabindex="-1"></a>(e.g. Google Chrome, Firefox, Microsoft Edge, etc).</span>
<span id="cb21-45"><a href="#cb21-45" aria-hidden="true" tabindex="-1"></a>For example, in web browsers, threads are normally used to implement tabs.</span>
<span id="cb21-46"><a href="#cb21-46" aria-hidden="true" tabindex="-1"></a>The tabs in a web browsers usually run as separate threads in the main process of</span>
<span id="cb21-47"><a href="#cb21-47" aria-hidden="true" tabindex="-1"></a>the web browser. That is, each new tab that you open in your web browser</span>
<span id="cb21-48"><a href="#cb21-48" aria-hidden="true" tabindex="-1"></a>usually runs on a separate thread of execution.</span>
<span id="cb21-49"><a href="#cb21-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-50"><a href="#cb21-50" aria-hidden="true" tabindex="-1"></a>By running each tab in a separate thread, we allow all open tabs in the browser to run at the same time,</span>
<span id="cb21-51"><a href="#cb21-51" aria-hidden="true" tabindex="-1"></a>and independently from each other. For example, you might have YouTube or Spotify currently open in</span>
<span id="cb21-52"><a href="#cb21-52" aria-hidden="true" tabindex="-1"></a>a tab, and you are listening to some podcast in that tab while at the same time</span>
<span id="cb21-53"><a href="#cb21-53" aria-hidden="true" tabindex="-1"></a>working in another tab, writing an essay on Google Docs. Even if you are not looking</span>
<span id="cb21-54"><a href="#cb21-54" aria-hidden="true" tabindex="-1"></a>into the YouTube tab, you can still hear the podcast only because this YouTube tab is running in parallel</span>
<span id="cb21-55"><a href="#cb21-55" aria-hidden="true" tabindex="-1"></a>with the other tab where Google Docs is running.</span>
<span id="cb21-56"><a href="#cb21-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-57"><a href="#cb21-57" aria-hidden="true" tabindex="-1"></a>Without threads, the other alternative would be to run each tab as a completely separate</span>
<span id="cb21-58"><a href="#cb21-58" aria-hidden="true" tabindex="-1"></a>process in your computer. But that would be a bad choice because just a few tabs would already consume</span>
<span id="cb21-59"><a href="#cb21-59" aria-hidden="true" tabindex="-1"></a>too much power and resources from your computer. In other words, it's very expensive to create a completely new process,</span>
<span id="cb21-60"><a href="#cb21-60" aria-hidden="true" tabindex="-1"></a>compared to creating a new thread of execution. Also, the chances of you experiencing lag and overhead</span>
<span id="cb21-61"><a href="#cb21-61" aria-hidden="true" tabindex="-1"></a>while using the browser would be significant. Threads are faster to create, and they also consume</span>
<span id="cb21-62"><a href="#cb21-62" aria-hidden="true" tabindex="-1"></a>much, much less resources from the computer, especially because they share some resources</span>
<span id="cb21-63"><a href="#cb21-63" aria-hidden="true" tabindex="-1"></a>with the main process.</span>
<span id="cb21-64"><a href="#cb21-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-65"><a href="#cb21-65" aria-hidden="true" tabindex="-1"></a>Therefore, it's the use of threads in modern web browsers that allow you to hear the podcast</span>
<span id="cb21-66"><a href="#cb21-66" aria-hidden="true" tabindex="-1"></a>at the same time while you are writing something on Google Docs.</span>
<span id="cb21-67"><a href="#cb21-67" aria-hidden="true" tabindex="-1"></a>Without threads, a web browser would probably be limited to just one single tab.</span>
<span id="cb21-68"><a href="#cb21-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-69"><a href="#cb21-69" aria-hidden="true" tabindex="-1"></a>Threads are also well-suited for anything that involves serving requests or orders.</span>
<span id="cb21-70"><a href="#cb21-70" aria-hidden="true" tabindex="-1"></a>Because serving a request takes time, and usually involves a lot of "waiting time".</span>
<span id="cb21-71"><a href="#cb21-71" aria-hidden="true" tabindex="-1"></a>In other words, we spend a lot of time in idle, waiting for something to complete.</span>
<span id="cb21-72"><a href="#cb21-72" aria-hidden="true" tabindex="-1"></a>For example, consider a restaurant. Serving orders in a restaurant usually involves</span>
<span id="cb21-73"><a href="#cb21-73" aria-hidden="true" tabindex="-1"></a>the following steps:</span>
<span id="cb21-74"><a href="#cb21-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-75"><a href="#cb21-75" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>receive order from the client.</span>
<span id="cb21-76"><a href="#cb21-76" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>pass the order to the kitchen, and wait for the food to be cooked.</span>
<span id="cb21-77"><a href="#cb21-77" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>start cooking the food in the kitchen.</span>
<span id="cb21-78"><a href="#cb21-78" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>when the food is fully cooked deliver this food to the client.</span>
<span id="cb21-79"><a href="#cb21-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-80"><a href="#cb21-80" aria-hidden="true" tabindex="-1"></a>If you think about the bullet points above, you will notice that one big moment of waiting time</span>
<span id="cb21-81"><a href="#cb21-81" aria-hidden="true" tabindex="-1"></a>is present in this whole process, which is while the food is being cooked</span>
<span id="cb21-82"><a href="#cb21-82" aria-hidden="true" tabindex="-1"></a>inside the kitchen. While the food is being prepped, both the waiter and the client</span>
<span id="cb21-83"><a href="#cb21-83" aria-hidden="true" tabindex="-1"></a>themselves are waiting for the food to be ready and delivered.</span>
<span id="cb21-84"><a href="#cb21-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-85"><a href="#cb21-85" aria-hidden="true" tabindex="-1"></a>If we write a program to represent this restaurant, more specifically, a single-threaded program, then</span>
<span id="cb21-86"><a href="#cb21-86" aria-hidden="true" tabindex="-1"></a>this program would be very inefficient. Because the program would stay in idle, waiting for a considerable amount</span>
<span id="cb21-87"><a href="#cb21-87" aria-hidden="true" tabindex="-1"></a>of time on the "check if food is ready" step. Consider the code snippet exposed below that could</span>
<span id="cb21-88"><a href="#cb21-88" aria-hidden="true" tabindex="-1"></a>potentially represent such program.</span>
<span id="cb21-89"><a href="#cb21-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-90"><a href="#cb21-90" aria-hidden="true" tabindex="-1"></a>The problem with this program is the while loop. This program will spend a lot of time</span>
<span id="cb21-91"><a href="#cb21-91" aria-hidden="true" tabindex="-1"></a>waiting on the while loop, doing nothing more than just checking if the food is ready.</span>
<span id="cb21-92"><a href="#cb21-92" aria-hidden="true" tabindex="-1"></a>This is a waste of time. Instead of waiting for something to happen, the waiter</span>
<span id="cb21-93"><a href="#cb21-93" aria-hidden="true" tabindex="-1"></a>could just send the order to the kitchen, and just move on, and continue with receiving</span>
<span id="cb21-94"><a href="#cb21-94" aria-hidden="true" tabindex="-1"></a>more orders from other clients, and sending more orders to the kitchen, instead</span>
<span id="cb21-95"><a href="#cb21-95" aria-hidden="true" tabindex="-1"></a>of doing nothing and waiting for the food to be ready.</span>
<span id="cb21-96"><a href="#cb21-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-99"><a href="#cb21-99" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb21-100"><a href="#cb21-100" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb21-101"><a href="#cb21-101" aria-hidden="true" tabindex="-1"></a><span class="in">const order = Order.init("Pizza Margherita", n = 1);</span></span>
<span id="cb21-102"><a href="#cb21-102" aria-hidden="true" tabindex="-1"></a><span class="in">const waiter = Waiter.init();</span></span>
<span id="cb21-103"><a href="#cb21-103" aria-hidden="true" tabindex="-1"></a><span class="in">waiter.receive_order(order);</span></span>
<span id="cb21-104"><a href="#cb21-104" aria-hidden="true" tabindex="-1"></a><span class="in">waiter.ask_kitchen_to_cook();</span></span>
<span id="cb21-105"><a href="#cb21-105" aria-hidden="true" tabindex="-1"></a><span class="in">var food_not_ready = true;</span></span>
<span id="cb21-106"><a href="#cb21-106" aria-hidden="true" tabindex="-1"></a><span class="in">while (food_not_ready) {</span></span>
<span id="cb21-107"><a href="#cb21-107" aria-hidden="true" tabindex="-1"></a><span class="in">    food_not_ready = waiter.is_food_ready();</span></span>
<span id="cb21-108"><a href="#cb21-108" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb21-109"><a href="#cb21-109" aria-hidden="true" tabindex="-1"></a><span class="in">const food = waiter.get_food_from_kitchen();</span></span>
<span id="cb21-110"><a href="#cb21-110" aria-hidden="true" tabindex="-1"></a><span class="in">waiter.send_food_to_client(food);</span></span>
<span id="cb21-111"><a href="#cb21-111" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-112"><a href="#cb21-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-113"><a href="#cb21-113" aria-hidden="true" tabindex="-1"></a>This is why threads would be a great fit for this program. We could use threads</span>
<span id="cb21-114"><a href="#cb21-114" aria-hidden="true" tabindex="-1"></a>to free the waiters from their "waiting duties", so they can go on with their</span>
<span id="cb21-115"><a href="#cb21-115" aria-hidden="true" tabindex="-1"></a>other tasks, and receive more orders. Take a look at the next example, where I have re-written the above</span>
<span id="cb21-116"><a href="#cb21-116" aria-hidden="true" tabindex="-1"></a>program into a different program that uses threads to cook and deliver the orders.</span>
<span id="cb21-117"><a href="#cb21-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-118"><a href="#cb21-118" aria-hidden="true" tabindex="-1"></a>You can see in this program that when a waiter receives a new order</span>
<span id="cb21-119"><a href="#cb21-119" aria-hidden="true" tabindex="-1"></a>from a client, this waiter executes the <span class="in">`send_order()`</span> function.</span>
<span id="cb21-120"><a href="#cb21-120" aria-hidden="true" tabindex="-1"></a>The only thing that this function does is to create a new thread</span>
<span id="cb21-121"><a href="#cb21-121" aria-hidden="true" tabindex="-1"></a>and detaches it. Since creating a thread is a very fast operation,</span>
<span id="cb21-122"><a href="#cb21-122" aria-hidden="true" tabindex="-1"></a>this <span class="in">`send_order()`</span> function returns almost immediately,</span>
<span id="cb21-123"><a href="#cb21-123" aria-hidden="true" tabindex="-1"></a>so the waiter spends almost no time worrying about the order, and just</span>
<span id="cb21-124"><a href="#cb21-124" aria-hidden="true" tabindex="-1"></a>move on and tries to get the next order from the clients.</span>
<span id="cb21-125"><a href="#cb21-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-126"><a href="#cb21-126" aria-hidden="true" tabindex="-1"></a>Inside the new thread created, the order gets cooked by a chef, and when the</span>
<span id="cb21-127"><a href="#cb21-127" aria-hidden="true" tabindex="-1"></a>food is ready, it's delivered to the client's table.</span>
<span id="cb21-128"><a href="#cb21-128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-129"><a href="#cb21-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-132"><a href="#cb21-132" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb21-133"><a href="#cb21-133" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb21-134"><a href="#cb21-134" aria-hidden="true" tabindex="-1"></a><span class="in">fn cook_and_deliver_order(order: *Order) void {</span></span>
<span id="cb21-135"><a href="#cb21-135" aria-hidden="true" tabindex="-1"></a><span class="in">    const chef = Chef.init();</span></span>
<span id="cb21-136"><a href="#cb21-136" aria-hidden="true" tabindex="-1"></a><span class="in">    const food = chef.cook(order.*);</span></span>
<span id="cb21-137"><a href="#cb21-137" aria-hidden="true" tabindex="-1"></a><span class="in">    chef.deliver_food(food);</span></span>
<span id="cb21-138"><a href="#cb21-138" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb21-139"><a href="#cb21-139" aria-hidden="true" tabindex="-1"></a><span class="in">fn send_order(order: Order) void {</span></span>
<span id="cb21-140"><a href="#cb21-140" aria-hidden="true" tabindex="-1"></a><span class="in">    const cook_thread = Thread.spawn(</span></span>
<span id="cb21-141"><a href="#cb21-141" aria-hidden="true" tabindex="-1"></a><span class="in">        .{}, cook_and_deliver_order, .{&amp;order}</span></span>
<span id="cb21-142"><a href="#cb21-142" aria-hidden="true" tabindex="-1"></a><span class="in">    );</span></span>
<span id="cb21-143"><a href="#cb21-143" aria-hidden="true" tabindex="-1"></a><span class="in">    cook_thread.detach();</span></span>
<span id="cb21-144"><a href="#cb21-144" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb21-145"><a href="#cb21-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-146"><a href="#cb21-146" aria-hidden="true" tabindex="-1"></a><span class="in">const waiter = Waiter.init();</span></span>
<span id="cb21-147"><a href="#cb21-147" aria-hidden="true" tabindex="-1"></a><span class="in">while (true) {</span></span>
<span id="cb21-148"><a href="#cb21-148" aria-hidden="true" tabindex="-1"></a><span class="in">    const order = waiter.get_new_order();</span></span>
<span id="cb21-149"><a href="#cb21-149" aria-hidden="true" tabindex="-1"></a><span class="in">    if (order) {</span></span>
<span id="cb21-150"><a href="#cb21-150" aria-hidden="true" tabindex="-1"></a><span class="in">        send_order(order);</span></span>
<span id="cb21-151"><a href="#cb21-151" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb21-152"><a href="#cb21-152" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb21-153"><a href="#cb21-153" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-154"><a href="#cb21-154" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-155"><a href="#cb21-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-156"><a href="#cb21-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-157"><a href="#cb21-157" aria-hidden="true" tabindex="-1"></a><span class="fu">## Threads versus processes</span></span>
<span id="cb21-158"><a href="#cb21-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-159"><a href="#cb21-159" aria-hidden="true" tabindex="-1"></a>When we run a program, this program is executed as a *process* in the operating system.</span>
<span id="cb21-160"><a href="#cb21-160" aria-hidden="true" tabindex="-1"></a>This is a one to one relationship, each program or application that you execute</span>
<span id="cb21-161"><a href="#cb21-161" aria-hidden="true" tabindex="-1"></a>is a separate process in the operating system. But each program, or each process,</span>
<span id="cb21-162"><a href="#cb21-162" aria-hidden="true" tabindex="-1"></a>can create and contain multiple threads inside of it. Therefore,</span>
<span id="cb21-163"><a href="#cb21-163" aria-hidden="true" tabindex="-1"></a>processes and threads have a one to many relationship.</span>
<span id="cb21-164"><a href="#cb21-164" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-165"><a href="#cb21-165" aria-hidden="true" tabindex="-1"></a>This also means that every thread that we create is always associated with a particular process in our computer.</span>
<span id="cb21-166"><a href="#cb21-166" aria-hidden="true" tabindex="-1"></a>In other words, a thread is always a subset (or a children) of an existing process.</span>
<span id="cb21-167"><a href="#cb21-167" aria-hidden="true" tabindex="-1"></a>All threads share some of the resources associated with the process from which they were created.</span>
<span id="cb21-168"><a href="#cb21-168" aria-hidden="true" tabindex="-1"></a>And because threads share resources with the process, they are very good for making communication</span>
<span id="cb21-169"><a href="#cb21-169" aria-hidden="true" tabindex="-1"></a>between tasks easier.</span>
<span id="cb21-170"><a href="#cb21-170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-171"><a href="#cb21-171" aria-hidden="true" tabindex="-1"></a>For example, suppose that you were developing a big and complex application</span>
<span id="cb21-172"><a href="#cb21-172" aria-hidden="true" tabindex="-1"></a>that would be much simpler if you could split it in two, and make these two separate pieces talk</span>
<span id="cb21-173"><a href="#cb21-173" aria-hidden="true" tabindex="-1"></a>with each other. Some programmers opt to effectively write these two pieces of the codebase as two</span>
<span id="cb21-174"><a href="#cb21-174" aria-hidden="true" tabindex="-1"></a>completely separate programs, and then, they use IPC (*inter-process communication*) to make these</span>
<span id="cb21-175"><a href="#cb21-175" aria-hidden="true" tabindex="-1"></a>two separate programs/processes talk to each other, and make them work together.</span>
<span id="cb21-176"><a href="#cb21-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-177"><a href="#cb21-177" aria-hidden="true" tabindex="-1"></a>However, some programmers find IPC hard to deal with, and, as consequence,</span>
<span id="cb21-178"><a href="#cb21-178" aria-hidden="true" tabindex="-1"></a>they prefer to write one piece of the codebase as the "main part of the program",</span>
<span id="cb21-179"><a href="#cb21-179" aria-hidden="true" tabindex="-1"></a>or, as the part of the code that runs as the process in the operating system,</span>
<span id="cb21-180"><a href="#cb21-180" aria-hidden="true" tabindex="-1"></a>while the other piece of the codebase is written as a task to be executed in</span>
<span id="cb21-181"><a href="#cb21-181" aria-hidden="true" tabindex="-1"></a>a new thread. A process and a thread can easily comunicate with each other</span>
<span id="cb21-182"><a href="#cb21-182" aria-hidden="true" tabindex="-1"></a>through both control flow, and also, through data, because they share and have</span>
<span id="cb21-183"><a href="#cb21-183" aria-hidden="true" tabindex="-1"></a>access to the same standard file descriptors (<span class="in">`stdout`</span>, <span class="in">`stdin`</span>, <span class="in">`stderr`</span>), and also to the</span>
<span id="cb21-184"><a href="#cb21-184" aria-hidden="true" tabindex="-1"></a>same memory space on the heap and global data section.</span>
<span id="cb21-185"><a href="#cb21-185" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-186"><a href="#cb21-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-187"><a href="#cb21-187" aria-hidden="true" tabindex="-1"></a>In more details, each thread that you create have a separate stack frame reserved just for that thread,</span>
<span id="cb21-188"><a href="#cb21-188" aria-hidden="true" tabindex="-1"></a>which essentially means that each local object that you create inside this thread, is local to that</span>
<span id="cb21-189"><a href="#cb21-189" aria-hidden="true" tabindex="-1"></a>thread, i.e., the other threads cannot see this local object. Unless this object that you have created</span>
<span id="cb21-190"><a href="#cb21-190" aria-hidden="true" tabindex="-1"></a>is an object that lives on the heap. In other words, if the memory associated with this object</span>
<span id="cb21-191"><a href="#cb21-191" aria-hidden="true" tabindex="-1"></a>is on the heap, then, the other threads can potentially access this object.</span>
<span id="cb21-192"><a href="#cb21-192" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-193"><a href="#cb21-193" aria-hidden="true" tabindex="-1"></a>Therefore, objects that are stored in the stack are local to the thread where they were created.</span>
<span id="cb21-194"><a href="#cb21-194" aria-hidden="true" tabindex="-1"></a>But objects that are stored on the heap are potentially accessible to other threads. All of this means that,</span>
<span id="cb21-195"><a href="#cb21-195" aria-hidden="true" tabindex="-1"></a>each thread has its own separate stack frame, but, at the same time, all threads share</span>
<span id="cb21-196"><a href="#cb21-196" aria-hidden="true" tabindex="-1"></a>the same heap, the same standard file descriptors (which means that they share the same <span class="in">`stdout`</span>, <span class="in">`stdin`</span>, <span class="in">`stderr`</span>),</span>
<span id="cb21-197"><a href="#cb21-197" aria-hidden="true" tabindex="-1"></a>and the same global data section in the program.</span>
<span id="cb21-198"><a href="#cb21-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-199"><a href="#cb21-199" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-200"><a href="#cb21-200" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-201"><a href="#cb21-201" aria-hidden="true" tabindex="-1"></a><span class="fu">## Creating a thread</span></span>
<span id="cb21-202"><a href="#cb21-202" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-203"><a href="#cb21-203" aria-hidden="true" tabindex="-1"></a>We create new threads in Zig by first importing the <span class="in">`Thread`</span> struct into</span>
<span id="cb21-204"><a href="#cb21-204" aria-hidden="true" tabindex="-1"></a>our current Zig module and then calling the <span class="in">`spawn()`</span> method of this struct,</span>
<span id="cb21-205"><a href="#cb21-205" aria-hidden="true" tabindex="-1"></a>which creates (or "spawns") a new thread of execution from our current process.</span>
<span id="cb21-206"><a href="#cb21-206" aria-hidden="true" tabindex="-1"></a>This method has three arguments, which are, respectively:</span>
<span id="cb21-207"><a href="#cb21-207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-208"><a href="#cb21-208" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>a <span class="in">`SpawnConfig`</span> object, which contains configurations for the spawn process.</span>
<span id="cb21-209"><a href="#cb21-209" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>the name of the function that is going to be executed (or that is going to be "called") inside this new thread.</span>
<span id="cb21-210"><a href="#cb21-210" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>a list of arguments (or inputs) to be passed to the function provided in the second argument.</span>
<span id="cb21-211"><a href="#cb21-211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-212"><a href="#cb21-212" aria-hidden="true" tabindex="-1"></a>With these three arguments, you can control how the thread gets created, and also, specify which</span>
<span id="cb21-213"><a href="#cb21-213" aria-hidden="true" tabindex="-1"></a>work (or "tasks") will be performed inside this new thread. A thread is just a separate context of execution,</span>
<span id="cb21-214"><a href="#cb21-214" aria-hidden="true" tabindex="-1"></a>and we usually create new threads in our code because we want to perform some work inside this</span>
<span id="cb21-215"><a href="#cb21-215" aria-hidden="true" tabindex="-1"></a>new context of execution. And we specify which exact work, or which exact steps that are going to be</span>
<span id="cb21-216"><a href="#cb21-216" aria-hidden="true" tabindex="-1"></a>performed inside this context by providing the name of a function as the second argument of the <span class="in">`spawn()`</span> method.</span>
<span id="cb21-217"><a href="#cb21-217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-218"><a href="#cb21-218" aria-hidden="true" tabindex="-1"></a>Thus, when this new thread gets created, this function that you provided as input to the <span class="in">`spawn()`</span></span>
<span id="cb21-219"><a href="#cb21-219" aria-hidden="true" tabindex="-1"></a>method gets called, or gets executed inside this new thread. You can control the</span>
<span id="cb21-220"><a href="#cb21-220" aria-hidden="true" tabindex="-1"></a>arguments, or the inputs that are passed to this function when it gets called by providing</span>
<span id="cb21-221"><a href="#cb21-221" aria-hidden="true" tabindex="-1"></a>a list of arguments (or a list of inputs) in the third argument of the <span class="in">`spawn()`</span> method.</span>
<span id="cb21-222"><a href="#cb21-222" aria-hidden="true" tabindex="-1"></a>These arguments are passed to the function in the same order that they are</span>
<span id="cb21-223"><a href="#cb21-223" aria-hidden="true" tabindex="-1"></a>provided to <span class="in">`spawn()`</span>.</span>
<span id="cb21-224"><a href="#cb21-224" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-225"><a href="#cb21-225" aria-hidden="true" tabindex="-1"></a>Furthermore, the <span class="in">`SpawnConfig`</span> is a struct object with only two possible fields, or, two possible members, that you</span>
<span id="cb21-226"><a href="#cb21-226" aria-hidden="true" tabindex="-1"></a>can set to tailor the spawn behaviour. These fields are:</span>
<span id="cb21-227"><a href="#cb21-227" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-228"><a href="#cb21-228" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`stack_size`</span>: you can provide a <span class="in">`usize`</span> value to specify the size (in bytes) of the thread's stack frame. By default, this value is: $16 \times 1024 \times 1024$.</span>
<span id="cb21-229"><a href="#cb21-229" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`allocator`</span>: you can provide an allocator object to be used when allocating memory for the thread.</span>
<span id="cb21-230"><a href="#cb21-230" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-231"><a href="#cb21-231" aria-hidden="true" tabindex="-1"></a>To use one of these two fields (or "configs"), you just have to create a new object of type <span class="in">`SpawnConfig`</span>,</span>
<span id="cb21-232"><a href="#cb21-232" aria-hidden="true" tabindex="-1"></a>and provide this object as input to the <span class="in">`spawn()`</span> method. But, if you are not interested in using</span>
<span id="cb21-233"><a href="#cb21-233" aria-hidden="true" tabindex="-1"></a>one of these configs, and you are ok with using just the defaults, you can just provide an anonymous</span>
<span id="cb21-234"><a href="#cb21-234" aria-hidden="true" tabindex="-1"></a>struct literal (<span class="in">`.{}`</span>) in place of this <span class="in">`SpawnConfig`</span> argument.</span>
<span id="cb21-235"><a href="#cb21-235" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-236"><a href="#cb21-236" aria-hidden="true" tabindex="-1"></a>As our first, and very simple example, consider the code exposed below.</span>
<span id="cb21-237"><a href="#cb21-237" aria-hidden="true" tabindex="-1"></a>Inside the same program, you can create multiple threads of execution if you want to.</span>
<span id="cb21-238"><a href="#cb21-238" aria-hidden="true" tabindex="-1"></a>But, in this first example, we are creating just a single thread of execution, because</span>
<span id="cb21-239"><a href="#cb21-239" aria-hidden="true" tabindex="-1"></a>we call <span class="in">`spawn()`</span> only once.</span>
<span id="cb21-240"><a href="#cb21-240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-241"><a href="#cb21-241" aria-hidden="true" tabindex="-1"></a>Also, notice in this example that we are executing the function <span class="in">`do_some_work()`</span></span>
<span id="cb21-242"><a href="#cb21-242" aria-hidden="true" tabindex="-1"></a>inside the new thread. Since this function receives no inputs, because it has</span>
<span id="cb21-243"><a href="#cb21-243" aria-hidden="true" tabindex="-1"></a>no arguments, we have passed an empty list in this instance, or more precisely,</span>
<span id="cb21-244"><a href="#cb21-244" aria-hidden="true" tabindex="-1"></a>an empty, anonymous struct (<span class="in">`.{}`</span>) in the third argument of <span class="in">`spawn()`</span>.</span>
<span id="cb21-245"><a href="#cb21-245" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-246"><a href="#cb21-246" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-249"><a href="#cb21-249" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb21-250"><a href="#cb21-250" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb21-251"><a href="#cb21-251" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb21-252"><a href="#cb21-252" aria-hidden="true" tabindex="-1"></a><span class="in">const stdout = std.io.getStdOut().writer();</span></span>
<span id="cb21-253"><a href="#cb21-253" aria-hidden="true" tabindex="-1"></a><span class="in">const Thread = std.Thread;</span></span>
<span id="cb21-254"><a href="#cb21-254" aria-hidden="true" tabindex="-1"></a><span class="in">fn do_some_work() !void {</span></span>
<span id="cb21-255"><a href="#cb21-255" aria-hidden="true" tabindex="-1"></a><span class="in">    _ = try stdout.write("Starting the work.\n");</span></span>
<span id="cb21-256"><a href="#cb21-256" aria-hidden="true" tabindex="-1"></a><span class="in">    std.time.sleep(100 * std.time.ns_per_ms);</span></span>
<span id="cb21-257"><a href="#cb21-257" aria-hidden="true" tabindex="-1"></a><span class="in">    _ = try stdout.write("Finishing the work.\n");</span></span>
<span id="cb21-258"><a href="#cb21-258" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb21-259"><a href="#cb21-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-260"><a href="#cb21-260" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb21-261"><a href="#cb21-261" aria-hidden="true" tabindex="-1"></a><span class="in">    const thread = try Thread.spawn(.{}, do_some_work, .{});</span></span>
<span id="cb21-262"><a href="#cb21-262" aria-hidden="true" tabindex="-1"></a><span class="in">    thread.join();</span></span>
<span id="cb21-263"><a href="#cb21-263" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb21-264"><a href="#cb21-264" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-265"><a href="#cb21-265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-266"><a href="#cb21-266" aria-hidden="true" tabindex="-1"></a>Notice the use of <span class="in">`try`</span> when calling the <span class="in">`spawn()`</span> method. This means</span>
<span id="cb21-267"><a href="#cb21-267" aria-hidden="true" tabindex="-1"></a>that this method can return an error in some circumstances. One circumstance</span>
<span id="cb21-268"><a href="#cb21-268" aria-hidden="true" tabindex="-1"></a>in particular is when you attempt to create a new thread, when you have already</span>
<span id="cb21-269"><a href="#cb21-269" aria-hidden="true" tabindex="-1"></a>created too much (i.e., you have exceeded the quota of concurrent threads in your system).</span>
<span id="cb21-270"><a href="#cb21-270" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-271"><a href="#cb21-271" aria-hidden="true" tabindex="-1"></a>But, if the new thread is successfully created, the <span class="in">`spawn()`</span> method returns a handler</span>
<span id="cb21-272"><a href="#cb21-272" aria-hidden="true" tabindex="-1"></a>object (which is just an object of type <span class="in">`Thread`</span>) to this new thread. You can use</span>
<span id="cb21-273"><a href="#cb21-273" aria-hidden="true" tabindex="-1"></a>this handler object to effectively control all aspects of the thread.</span>
<span id="cb21-274"><a href="#cb21-274" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-275"><a href="#cb21-275" aria-hidden="true" tabindex="-1"></a>When the thread gets created, the function that you provided as input to <span class="in">`spawn()`</span></span>
<span id="cb21-276"><a href="#cb21-276" aria-hidden="true" tabindex="-1"></a>gets invoked (i.e., gets called) to start the execution on this new thread.</span>
<span id="cb21-277"><a href="#cb21-277" aria-hidden="true" tabindex="-1"></a>In other words, every time you call <span class="in">`spawn()`</span>, not only is a new thread created,</span>
<span id="cb21-278"><a href="#cb21-278" aria-hidden="true" tabindex="-1"></a>but the "start work button" of this thread is also automatically pressed.</span>
<span id="cb21-279"><a href="#cb21-279" aria-hidden="true" tabindex="-1"></a>So the work being performed in this thread starts as soon as the thread is created.</span>
<span id="cb21-280"><a href="#cb21-280" aria-hidden="true" tabindex="-1"></a>This is similar to how <span class="in">`pthread_create()`</span> from the <span class="in">`pthreads`</span> library in C works,</span>
<span id="cb21-281"><a href="#cb21-281" aria-hidden="true" tabindex="-1"></a>which also starts the execution as soon as the thread is created.</span>
<span id="cb21-282"><a href="#cb21-282" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-283"><a href="#cb21-283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-284"><a href="#cb21-284" aria-hidden="true" tabindex="-1"></a><span class="fu">## Returning from a thread</span></span>
<span id="cb21-285"><a href="#cb21-285" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-286"><a href="#cb21-286" aria-hidden="true" tabindex="-1"></a>We have learned in the previous section that the execution of the thread starts as soon as</span>
<span id="cb21-287"><a href="#cb21-287" aria-hidden="true" tabindex="-1"></a>the thread is created. Now, we will learn how to "join" or "detach" a thread in Zig.</span>
<span id="cb21-288"><a href="#cb21-288" aria-hidden="true" tabindex="-1"></a>"Join" and "detach" are operations that control how the thread returns to</span>
<span id="cb21-289"><a href="#cb21-289" aria-hidden="true" tabindex="-1"></a>the main thread, or to the main process in our program.</span>
<span id="cb21-290"><a href="#cb21-290" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-291"><a href="#cb21-291" aria-hidden="true" tabindex="-1"></a>We perform these operations by using the methods <span class="in">`join()`</span> and <span class="in">`detach()`</span> from the thread handler object.</span>
<span id="cb21-292"><a href="#cb21-292" aria-hidden="true" tabindex="-1"></a>Every thread that you create can be marked as either *joinable* or *detached* <span class="co">[</span><span class="ot">@linux_pthread_create</span><span class="co">]</span>.</span>
<span id="cb21-293"><a href="#cb21-293" aria-hidden="true" tabindex="-1"></a>You can turn a thread into a *detached* thread by calling the <span class="in">`detach()`</span> method</span>
<span id="cb21-294"><a href="#cb21-294" aria-hidden="true" tabindex="-1"></a>from the thread handler object. But if you call the <span class="in">`join()`</span> method instead, then this thread</span>
<span id="cb21-295"><a href="#cb21-295" aria-hidden="true" tabindex="-1"></a>becomes a *joinable* thread.</span>
<span id="cb21-296"><a href="#cb21-296" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-297"><a href="#cb21-297" aria-hidden="true" tabindex="-1"></a>A thread cannot be both *joinable* and *detached*. Which in general means</span>
<span id="cb21-298"><a href="#cb21-298" aria-hidden="true" tabindex="-1"></a>that you cannot call both <span class="in">`join()`</span> and <span class="in">`detach()`</span> on the same thread.</span>
<span id="cb21-299"><a href="#cb21-299" aria-hidden="true" tabindex="-1"></a>But a thread must be one of the two, meaning that, you should always call</span>
<span id="cb21-300"><a href="#cb21-300" aria-hidden="true" tabindex="-1"></a>either <span class="in">`join()`</span> or <span class="in">`detach()`</span> over a thread. If you don't call</span>
<span id="cb21-301"><a href="#cb21-301" aria-hidden="true" tabindex="-1"></a>one of these two methods over your thread, you introduce undefined behaviour into your program,</span>
<span id="cb21-302"><a href="#cb21-302" aria-hidden="true" tabindex="-1"></a>which is described in @sec-not-call-join-detach.</span>
<span id="cb21-303"><a href="#cb21-303" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-304"><a href="#cb21-304" aria-hidden="true" tabindex="-1"></a>Now, let's describe what each of these two methods do to your thread.</span>
<span id="cb21-305"><a href="#cb21-305" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-306"><a href="#cb21-306" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-307"><a href="#cb21-307" aria-hidden="true" tabindex="-1"></a><span class="fu">### Joining a thread</span></span>
<span id="cb21-308"><a href="#cb21-308" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-309"><a href="#cb21-309" aria-hidden="true" tabindex="-1"></a>When you join a thread, you are essentially saying: "Hey! Could you please wait for the thread to finish,</span>
<span id="cb21-310"><a href="#cb21-310" aria-hidden="true" tabindex="-1"></a>before you continue with your execution?". For example, if we come back to our first and simplest example</span>
<span id="cb21-311"><a href="#cb21-311" aria-hidden="true" tabindex="-1"></a>of a thread in Zig, we created a single thread inside the <span class="in">`main()`</span> function of our program</span>
<span id="cb21-312"><a href="#cb21-312" aria-hidden="true" tabindex="-1"></a>and just called <span class="in">`join()`</span> on this thread at the end. This section of the code example is reproduced below.</span>
<span id="cb21-313"><a href="#cb21-313" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-314"><a href="#cb21-314" aria-hidden="true" tabindex="-1"></a>Because we are joining this new thread inside the <span class="in">`main()`</span>'s scope, it means that the</span>
<span id="cb21-315"><a href="#cb21-315" aria-hidden="true" tabindex="-1"></a>execution of the <span class="in">`main()`</span> function is temporarily stopped, to wait for the execution of the thread</span>
<span id="cb21-316"><a href="#cb21-316" aria-hidden="true" tabindex="-1"></a>to finish. That is, the execution of <span class="in">`main()`</span> stops temporarily at the line where <span class="in">`join()`</span> gets called,</span>
<span id="cb21-317"><a href="#cb21-317" aria-hidden="true" tabindex="-1"></a>and it will continue only after the thread has finished its tasks.</span>
<span id="cb21-318"><a href="#cb21-318" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-321"><a href="#cb21-321" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb21-322"><a href="#cb21-322" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb21-323"><a href="#cb21-323" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb21-324"><a href="#cb21-324" aria-hidden="true" tabindex="-1"></a><span class="in">    const thread = try Thread.spawn(.{}, do_some_work, .{});</span></span>
<span id="cb21-325"><a href="#cb21-325" aria-hidden="true" tabindex="-1"></a><span class="in">    thread.join();</span></span>
<span id="cb21-326"><a href="#cb21-326" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb21-327"><a href="#cb21-327" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-328"><a href="#cb21-328" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-329"><a href="#cb21-329" aria-hidden="true" tabindex="-1"></a>Because we have joined this new thread inside the <span class="in">`main()`</span> scope, we have a</span>
<span id="cb21-330"><a href="#cb21-330" aria-hidden="true" tabindex="-1"></a>guarantee that this new thread will finish before the end of the execution of <span class="in">`main()`</span>.</span>
<span id="cb21-331"><a href="#cb21-331" aria-hidden="true" tabindex="-1"></a>Because it's guaranteed that <span class="in">`main()`</span> will wait for the thread to finish its tasks.</span>
<span id="cb21-332"><a href="#cb21-332" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-333"><a href="#cb21-333" aria-hidden="true" tabindex="-1"></a>In the example above, there are no more expressions after the <span class="in">`join()`</span> call. We just have the end</span>
<span id="cb21-334"><a href="#cb21-334" aria-hidden="true" tabindex="-1"></a>of the <span class="in">`main()`</span>'s scope, and, therefore, the execution of our program just ends after the thread finishes its tasks,</span>
<span id="cb21-335"><a href="#cb21-335" aria-hidden="true" tabindex="-1"></a>since there is nothing more to do. But what if we had more stuff to do after the join call?</span>
<span id="cb21-336"><a href="#cb21-336" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-337"><a href="#cb21-337" aria-hidden="true" tabindex="-1"></a>To demonstrate this other possibility, consider the next example exposed</span>
<span id="cb21-338"><a href="#cb21-338" aria-hidden="true" tabindex="-1"></a>below. Here, we create a <span class="in">`print_id()`</span> function, that just receives an id</span>
<span id="cb21-339"><a href="#cb21-339" aria-hidden="true" tabindex="-1"></a>as input, and prints it to <span class="in">`stdout`</span>. In this example, we are creating two</span>
<span id="cb21-340"><a href="#cb21-340" aria-hidden="true" tabindex="-1"></a>new threads, one after another. Then, we join the first thread, then,</span>
<span id="cb21-341"><a href="#cb21-341" aria-hidden="true" tabindex="-1"></a>we wait for two whole seconds, then, at last, we join the second thread.</span>
<span id="cb21-342"><a href="#cb21-342" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-343"><a href="#cb21-343" aria-hidden="true" tabindex="-1"></a>The idea behind this example is that the last <span class="in">`join()`</span> call is executed</span>
<span id="cb21-344"><a href="#cb21-344" aria-hidden="true" tabindex="-1"></a>only after the first thread finishes its task (i.e., the first <span class="in">`join()`</span> call),</span>
<span id="cb21-345"><a href="#cb21-345" aria-hidden="true" tabindex="-1"></a>and the two-second delay. If you compile and run this</span>
<span id="cb21-346"><a href="#cb21-346" aria-hidden="true" tabindex="-1"></a>example, you will notice that most messages are quickly printed to <span class="in">`stdout`</span>,</span>
<span id="cb21-347"><a href="#cb21-347" aria-hidden="true" tabindex="-1"></a>i.e., they appear almost instantly on your screen.</span>
<span id="cb21-348"><a href="#cb21-348" aria-hidden="true" tabindex="-1"></a>However, the last message ("Joining thread 2") takes around 2 seconds to appear</span>
<span id="cb21-349"><a href="#cb21-349" aria-hidden="true" tabindex="-1"></a>on the screen.</span>
<span id="cb21-350"><a href="#cb21-350" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-351"><a href="#cb21-351" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-354"><a href="#cb21-354" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb21-355"><a href="#cb21-355" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb21-356"><a href="#cb21-356" aria-hidden="true" tabindex="-1"></a><span class="in">fn print_id(id: *const u8) !void {</span></span>
<span id="cb21-357"><a href="#cb21-357" aria-hidden="true" tabindex="-1"></a><span class="in">    try stdout.print("Thread ID: {d}\n", .{id.*});</span></span>
<span id="cb21-358"><a href="#cb21-358" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb21-359"><a href="#cb21-359" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-360"><a href="#cb21-360" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb21-361"><a href="#cb21-361" aria-hidden="true" tabindex="-1"></a><span class="in">    const id1: u8 = 1;</span></span>
<span id="cb21-362"><a href="#cb21-362" aria-hidden="true" tabindex="-1"></a><span class="in">    const id2: u8 = 2;</span></span>
<span id="cb21-363"><a href="#cb21-363" aria-hidden="true" tabindex="-1"></a><span class="in">    const thread1 = try Thread.spawn(.{}, print_id, .{&amp;id1});</span></span>
<span id="cb21-364"><a href="#cb21-364" aria-hidden="true" tabindex="-1"></a><span class="in">    const thread2 = try Thread.spawn(.{}, print_id, .{&amp;id2});</span></span>
<span id="cb21-365"><a href="#cb21-365" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-366"><a href="#cb21-366" aria-hidden="true" tabindex="-1"></a><span class="in">    _ = try stdout.write("Joining thread 1\n");</span></span>
<span id="cb21-367"><a href="#cb21-367" aria-hidden="true" tabindex="-1"></a><span class="in">    thread1.join();</span></span>
<span id="cb21-368"><a href="#cb21-368" aria-hidden="true" tabindex="-1"></a><span class="in">    std.time.sleep(2 * std.time.ns_per_s);</span></span>
<span id="cb21-369"><a href="#cb21-369" aria-hidden="true" tabindex="-1"></a><span class="in">    _ = try stdout.write("Joining thread 2\n");</span></span>
<span id="cb21-370"><a href="#cb21-370" aria-hidden="true" tabindex="-1"></a><span class="in">    thread2.join();</span></span>
<span id="cb21-371"><a href="#cb21-371" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb21-372"><a href="#cb21-372" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-373"><a href="#cb21-373" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-374"><a href="#cb21-374" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-375"><a href="#cb21-375" aria-hidden="true" tabindex="-1"></a><span class="in">Thread ID: Joining thread 1</span></span>
<span id="cb21-376"><a href="#cb21-376" aria-hidden="true" tabindex="-1"></a><span class="in">1</span></span>
<span id="cb21-377"><a href="#cb21-377" aria-hidden="true" tabindex="-1"></a><span class="in">Thread ID: 2</span></span>
<span id="cb21-378"><a href="#cb21-378" aria-hidden="true" tabindex="-1"></a><span class="in">Joining thread 2</span></span>
<span id="cb21-379"><a href="#cb21-379" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-380"><a href="#cb21-380" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-381"><a href="#cb21-381" aria-hidden="true" tabindex="-1"></a>This demonstrates that both threads finish their work (i.e., printing the IDs)</span>
<span id="cb21-382"><a href="#cb21-382" aria-hidden="true" tabindex="-1"></a>very fast, before the two seconds of delay end. Because of that, the last <span class="in">`join()`</span> call</span>
<span id="cb21-383"><a href="#cb21-383" aria-hidden="true" tabindex="-1"></a>returns pretty much instantly. Because when this last <span class="in">`join()`</span> call happens, the second</span>
<span id="cb21-384"><a href="#cb21-384" aria-hidden="true" tabindex="-1"></a>thread has already finished its task.</span>
<span id="cb21-385"><a href="#cb21-385" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-386"><a href="#cb21-386" aria-hidden="true" tabindex="-1"></a>Now, if you compile and run this example, you will also notice that, in some cases,</span>
<span id="cb21-387"><a href="#cb21-387" aria-hidden="true" tabindex="-1"></a>the messages intertwine with each other. In other words, you might see</span>
<span id="cb21-388"><a href="#cb21-388" aria-hidden="true" tabindex="-1"></a>the message "Joining thread 1" inserted in the middle of the message "Thread 1",</span>
<span id="cb21-389"><a href="#cb21-389" aria-hidden="true" tabindex="-1"></a>or vice-versa. This happens because:</span>
<span id="cb21-390"><a href="#cb21-390" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-391"><a href="#cb21-391" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>the threads are executing basically at the same time as the main process of the program (i.e., the <span class="in">`main()`</span> function).</span>
<span id="cb21-392"><a href="#cb21-392" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>the threads share the same <span class="in">`stdout`</span> from the main process of the program, which means that the messages that the threads produce are sent to exact same place as the messages produced by the main process.</span>
<span id="cb21-393"><a href="#cb21-393" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-394"><a href="#cb21-394" aria-hidden="true" tabindex="-1"></a>Both of these points were described previously in @sec-what-thread.</span>
<span id="cb21-395"><a href="#cb21-395" aria-hidden="true" tabindex="-1"></a>So the messages might get intertwined because they are being produced and</span>
<span id="cb21-396"><a href="#cb21-396" aria-hidden="true" tabindex="-1"></a>sent to the same <span class="in">`stdout`</span> roughly at the same time.</span>
<span id="cb21-397"><a href="#cb21-397" aria-hidden="true" tabindex="-1"></a>Anyway, when you call <span class="in">`join()`</span> over a thread, the current process will wait</span>
<span id="cb21-398"><a href="#cb21-398" aria-hidden="true" tabindex="-1"></a>for the thread to finish before it continues, and, when the thread finishes its</span>
<span id="cb21-399"><a href="#cb21-399" aria-hidden="true" tabindex="-1"></a>task, the resources associated with this thread are automatically freed, and</span>
<span id="cb21-400"><a href="#cb21-400" aria-hidden="true" tabindex="-1"></a>the current process continues with its execution.</span>
<span id="cb21-401"><a href="#cb21-401" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-402"><a href="#cb21-402" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-403"><a href="#cb21-403" aria-hidden="true" tabindex="-1"></a><span class="fu">### Detaching a thread</span></span>
<span id="cb21-404"><a href="#cb21-404" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-405"><a href="#cb21-405" aria-hidden="true" tabindex="-1"></a>When you detach a thread, the resources associated with this thread are automatically</span>
<span id="cb21-406"><a href="#cb21-406" aria-hidden="true" tabindex="-1"></a>released back to the system, without the need for another thread to join with this terminated thread.</span>
<span id="cb21-407"><a href="#cb21-407" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-408"><a href="#cb21-408" aria-hidden="true" tabindex="-1"></a>In other words, when you call <span class="in">`detach()`</span> on a thread it's like when your children become adults,</span>
<span id="cb21-409"><a href="#cb21-409" aria-hidden="true" tabindex="-1"></a>i.e., they become independent from you. A detached thread frees itself, and when this thread finishes its</span>
<span id="cb21-410"><a href="#cb21-410" aria-hidden="true" tabindex="-1"></a>tasks, it does not report the results back to you. Thus, you normally mark a thread as *detached*</span>
<span id="cb21-411"><a href="#cb21-411" aria-hidden="true" tabindex="-1"></a>when you don't need to use the return value of the thread, or when you don't care about</span>
<span id="cb21-412"><a href="#cb21-412" aria-hidden="true" tabindex="-1"></a>when exactly the thread finishes its job, i.e., the thread solves everything by itself.</span>
<span id="cb21-413"><a href="#cb21-413" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-414"><a href="#cb21-414" aria-hidden="true" tabindex="-1"></a>Take the code example below. We create a new thread, detach it, and then, we just</span>
<span id="cb21-415"><a href="#cb21-415" aria-hidden="true" tabindex="-1"></a>print a final message before we end our program. We use the same <span class="in">`print_id()`</span></span>
<span id="cb21-416"><a href="#cb21-416" aria-hidden="true" tabindex="-1"></a>function that we have used over the previous examples.</span>
<span id="cb21-417"><a href="#cb21-417" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-418"><a href="#cb21-418" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-421"><a href="#cb21-421" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb21-422"><a href="#cb21-422" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb21-423"><a href="#cb21-423" aria-hidden="true" tabindex="-1"></a><span class="in">fn print_id(id: *const u8) !void {</span></span>
<span id="cb21-424"><a href="#cb21-424" aria-hidden="true" tabindex="-1"></a><span class="in">    try stdout.print("Thread ID: {d}\n", .{id.*});</span></span>
<span id="cb21-425"><a href="#cb21-425" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb21-426"><a href="#cb21-426" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-427"><a href="#cb21-427" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb21-428"><a href="#cb21-428" aria-hidden="true" tabindex="-1"></a><span class="in">    const id1: u8 = 1;</span></span>
<span id="cb21-429"><a href="#cb21-429" aria-hidden="true" tabindex="-1"></a><span class="in">    const thread1 = try Thread.spawn(.{}, print_id, .{&amp;id1});</span></span>
<span id="cb21-430"><a href="#cb21-430" aria-hidden="true" tabindex="-1"></a><span class="in">    thread1.detach();</span></span>
<span id="cb21-431"><a href="#cb21-431" aria-hidden="true" tabindex="-1"></a><span class="in">    _ = try stdout.write("Finish main\n");</span></span>
<span id="cb21-432"><a href="#cb21-432" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb21-433"><a href="#cb21-433" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-434"><a href="#cb21-434" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-435"><a href="#cb21-435" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-436"><a href="#cb21-436" aria-hidden="true" tabindex="-1"></a><span class="in">Finish main</span></span>
<span id="cb21-437"><a href="#cb21-437" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-438"><a href="#cb21-438" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-439"><a href="#cb21-439" aria-hidden="true" tabindex="-1"></a>Now, if you look closely at the output of this code example, you will notice</span>
<span id="cb21-440"><a href="#cb21-440" aria-hidden="true" tabindex="-1"></a>that only the final message in main was printed to the console. The message</span>
<span id="cb21-441"><a href="#cb21-441" aria-hidden="true" tabindex="-1"></a>that was supposed to be printed by <span class="in">`print_id()`</span> did not appear in the console.</span>
<span id="cb21-442"><a href="#cb21-442" aria-hidden="true" tabindex="-1"></a>Why? It's because the main process of our program has finished first,</span>
<span id="cb21-443"><a href="#cb21-443" aria-hidden="true" tabindex="-1"></a>before the thread was able to say anything.</span>
<span id="cb21-444"><a href="#cb21-444" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-445"><a href="#cb21-445" aria-hidden="true" tabindex="-1"></a>And that is perfectly ok behaviour, because the thread was detached, so it was</span>
<span id="cb21-446"><a href="#cb21-446" aria-hidden="true" tabindex="-1"></a>able to free itself, without the need to wait for the main process.</span>
<span id="cb21-447"><a href="#cb21-447" aria-hidden="true" tabindex="-1"></a>If you ask main to sleep (or "wait") for some extra nanoseconds, before it ends, you will likely</span>
<span id="cb21-448"><a href="#cb21-448" aria-hidden="true" tabindex="-1"></a>see the message printed by <span class="in">`print_id()`</span>, because you give enough time for the thread to</span>
<span id="cb21-449"><a href="#cb21-449" aria-hidden="true" tabindex="-1"></a>finish before the main process ends.</span>
<span id="cb21-450"><a href="#cb21-450" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-451"><a href="#cb21-451" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-452"><a href="#cb21-452" aria-hidden="true" tabindex="-1"></a><span class="fu">## Thread pools</span></span>
<span id="cb21-453"><a href="#cb21-453" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-454"><a href="#cb21-454" aria-hidden="true" tabindex="-1"></a>Thread pools is a very popular programming pattern, which is used especially on servers and daemons processes.</span>
<span id="cb21-455"><a href="#cb21-455" aria-hidden="true" tabindex="-1"></a>A thread pool is just a set of threads, or a "pool" of threads. Many programmers like to use this pattern because it makes</span>
<span id="cb21-456"><a href="#cb21-456" aria-hidden="true" tabindex="-1"></a>it easier to manage and use multiple threads in your program, instead of manually creating the threads when you need them.</span>
<span id="cb21-457"><a href="#cb21-457" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-458"><a href="#cb21-458" aria-hidden="true" tabindex="-1"></a>Also, using thread pools might increase performance as well in your program,</span>
<span id="cb21-459"><a href="#cb21-459" aria-hidden="true" tabindex="-1"></a>especially if your program is constantly creating threads to perform short-lived tasks.</span>
<span id="cb21-460"><a href="#cb21-460" aria-hidden="true" tabindex="-1"></a>In such instance, a thread pool might cause an increase in performance because you do not have be constantly</span>
<span id="cb21-461"><a href="#cb21-461" aria-hidden="true" tabindex="-1"></a>creating and destroying threads all the time, so you don't face a lot of the overhead involved</span>
<span id="cb21-462"><a href="#cb21-462" aria-hidden="true" tabindex="-1"></a>in this constant process of creating and destroying threads.</span>
<span id="cb21-463"><a href="#cb21-463" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-464"><a href="#cb21-464" aria-hidden="true" tabindex="-1"></a>The main idea behind a thread pool is to have a set of threads already created and ready to perform</span>
<span id="cb21-465"><a href="#cb21-465" aria-hidden="true" tabindex="-1"></a>tasks at all times. You create a set of threads at the moment that your program starts, and keep</span>
<span id="cb21-466"><a href="#cb21-466" aria-hidden="true" tabindex="-1"></a>these threads alive while your program runs. Each of these threads will be either performing a task, or</span>
<span id="cb21-467"><a href="#cb21-467" aria-hidden="true" tabindex="-1"></a>waiting for a task to be assigned.</span>
<span id="cb21-468"><a href="#cb21-468" aria-hidden="true" tabindex="-1"></a>Every time a new task emerges in your program, this task is added to a "queue of tasks",</span>
<span id="cb21-469"><a href="#cb21-469" aria-hidden="true" tabindex="-1"></a>and the moment that a thread becomes available and ready to perform a new task,</span>
<span id="cb21-470"><a href="#cb21-470" aria-hidden="true" tabindex="-1"></a>this thread takes the next task from the "queue of tasks", and it simply performs the task.</span>
<span id="cb21-471"><a href="#cb21-471" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-472"><a href="#cb21-472" aria-hidden="true" tabindex="-1"></a>The Zig Standard Library offers a thread pool implementation on the <span class="in">`std.Thread.Pool`</span> struct.</span>
<span id="cb21-473"><a href="#cb21-473" aria-hidden="true" tabindex="-1"></a>You create a new instance of a <span class="in">`Pool`</span> object by providing a <span class="in">`Pool.Options`</span> object</span>
<span id="cb21-474"><a href="#cb21-474" aria-hidden="true" tabindex="-1"></a>as input to the <span class="in">`init()`</span> method of this struct. A <span class="in">`Pool.Options`</span> object, is a struct object that contains</span>
<span id="cb21-475"><a href="#cb21-475" aria-hidden="true" tabindex="-1"></a>configurations for the pool of threads. The most important settings in this struct object are</span>
<span id="cb21-476"><a href="#cb21-476" aria-hidden="true" tabindex="-1"></a>the members <span class="in">`n_jobs`</span> and <span class="in">`allocator`</span>. As the name suggests, the member <span class="in">`allocator`</span> should receive an allocator object,</span>
<span id="cb21-477"><a href="#cb21-477" aria-hidden="true" tabindex="-1"></a>while the member <span class="in">`n_jobs`</span> specifies the number of threads to be created and maintained in this pool.</span>
<span id="cb21-478"><a href="#cb21-478" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-479"><a href="#cb21-479" aria-hidden="true" tabindex="-1"></a>Consider the example exposed below, that demonstrates how can we create a new thread pool object.</span>
<span id="cb21-480"><a href="#cb21-480" aria-hidden="true" tabindex="-1"></a>Here, we create a <span class="in">`Pool.Options`</span> object that contains</span>
<span id="cb21-481"><a href="#cb21-481" aria-hidden="true" tabindex="-1"></a>a general purpose allocator object, and also, the <span class="in">`n_jobs`</span> member was set to 4, which</span>
<span id="cb21-482"><a href="#cb21-482" aria-hidden="true" tabindex="-1"></a>means that the thread pool will create and use 4 threads.</span>
<span id="cb21-483"><a href="#cb21-483" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-484"><a href="#cb21-484" aria-hidden="true" tabindex="-1"></a>Also notice that the <span class="in">`pool`</span> object was initially set to <span class="in">`undefined`</span>. This allow us</span>
<span id="cb21-485"><a href="#cb21-485" aria-hidden="true" tabindex="-1"></a>to initially declare the thread pool object, but not properly instantiate the</span>
<span id="cb21-486"><a href="#cb21-486" aria-hidden="true" tabindex="-1"></a>underlying memory of the object. You have to initially declare your thread pool object</span>
<span id="cb21-487"><a href="#cb21-487" aria-hidden="true" tabindex="-1"></a>by using <span class="in">`undefined`</span> like this, because the <span class="in">`init()`</span> method of <span class="in">`Pool`</span> needs</span>
<span id="cb21-488"><a href="#cb21-488" aria-hidden="true" tabindex="-1"></a>to have an initial pointer to properly instantiate the object.</span>
<span id="cb21-489"><a href="#cb21-489" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-490"><a href="#cb21-490" aria-hidden="true" tabindex="-1"></a>So, just remember to create your thread pool object by using <span class="in">`undefined`</span>, and then,</span>
<span id="cb21-491"><a href="#cb21-491" aria-hidden="true" tabindex="-1"></a>after that, you call the <span class="in">`init()`</span> method over the object.</span>
<span id="cb21-492"><a href="#cb21-492" aria-hidden="true" tabindex="-1"></a>You should also not forget to call the <span class="in">`deinit()`</span> method over the thread pool</span>
<span id="cb21-493"><a href="#cb21-493" aria-hidden="true" tabindex="-1"></a>object, once you are done with it, to release the resources allocated for the thread pool. Otherwise, you will</span>
<span id="cb21-494"><a href="#cb21-494" aria-hidden="true" tabindex="-1"></a>have a memory leak in your program.</span>
<span id="cb21-495"><a href="#cb21-495" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-498"><a href="#cb21-498" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb21-499"><a href="#cb21-499" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: false</span></span>
<span id="cb21-500"><a href="#cb21-500" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb21-501"><a href="#cb21-501" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb21-502"><a href="#cb21-502" aria-hidden="true" tabindex="-1"></a><span class="in">const Pool = std.Thread.Pool;</span></span>
<span id="cb21-503"><a href="#cb21-503" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb21-504"><a href="#cb21-504" aria-hidden="true" tabindex="-1"></a><span class="in">    var gpa = std.heap.GeneralPurposeAllocator(.{}){};</span></span>
<span id="cb21-505"><a href="#cb21-505" aria-hidden="true" tabindex="-1"></a><span class="in">    const allocator = gpa.allocator();</span></span>
<span id="cb21-506"><a href="#cb21-506" aria-hidden="true" tabindex="-1"></a><span class="in">    const opt = Pool.Options{</span></span>
<span id="cb21-507"><a href="#cb21-507" aria-hidden="true" tabindex="-1"></a><span class="in">        .n_jobs = 4,</span></span>
<span id="cb21-508"><a href="#cb21-508" aria-hidden="true" tabindex="-1"></a><span class="in">        .allocator = allocator,</span></span>
<span id="cb21-509"><a href="#cb21-509" aria-hidden="true" tabindex="-1"></a><span class="in">    };</span></span>
<span id="cb21-510"><a href="#cb21-510" aria-hidden="true" tabindex="-1"></a><span class="in">    var pool: Pool = undefined;</span></span>
<span id="cb21-511"><a href="#cb21-511" aria-hidden="true" tabindex="-1"></a><span class="in">    try pool.init(opt);</span></span>
<span id="cb21-512"><a href="#cb21-512" aria-hidden="true" tabindex="-1"></a><span class="in">    defer pool.deinit();</span></span>
<span id="cb21-513"><a href="#cb21-513" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb21-514"><a href="#cb21-514" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-515"><a href="#cb21-515" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-516"><a href="#cb21-516" aria-hidden="true" tabindex="-1"></a>Now that we know how to create <span class="in">`Pool`</span> objects, we have</span>
<span id="cb21-517"><a href="#cb21-517" aria-hidden="true" tabindex="-1"></a>to understand how to assign tasks to be executed by the threads in this pool object.</span>
<span id="cb21-518"><a href="#cb21-518" aria-hidden="true" tabindex="-1"></a>To assign a task to be performed by a thread, we need to call the <span class="in">`spawn()`</span> method</span>
<span id="cb21-519"><a href="#cb21-519" aria-hidden="true" tabindex="-1"></a>from the thread pool object.</span>
<span id="cb21-520"><a href="#cb21-520" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-521"><a href="#cb21-521" aria-hidden="true" tabindex="-1"></a>This <span class="in">`spawn()`</span> method works identical to the <span class="in">`spawn()`</span> method from the</span>
<span id="cb21-522"><a href="#cb21-522" aria-hidden="true" tabindex="-1"></a><span class="in">`Thread`</span> object. The method has almost the same arguments as the previous one,</span>
<span id="cb21-523"><a href="#cb21-523" aria-hidden="true" tabindex="-1"></a>more precisely, we don't have to provide a <span class="in">`SpawnConfig`</span> object in this case.</span>
<span id="cb21-524"><a href="#cb21-524" aria-hidden="true" tabindex="-1"></a>But instead of creating a new thread, this <span class="in">`spawn()`</span> method from</span>
<span id="cb21-525"><a href="#cb21-525" aria-hidden="true" tabindex="-1"></a>the thread pool object just registers a new task in the internal "queue of tasks" to be performed,</span>
<span id="cb21-526"><a href="#cb21-526" aria-hidden="true" tabindex="-1"></a>and any available thread in the pool will get this task, and it will simply perform the task.</span>
<span id="cb21-527"><a href="#cb21-527" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-528"><a href="#cb21-528" aria-hidden="true" tabindex="-1"></a>In the example below, we are using our previous <span class="in">`print_id()`</span> function once again.</span>
<span id="cb21-529"><a href="#cb21-529" aria-hidden="true" tabindex="-1"></a>But you may notice that the <span class="in">`print_id()`</span> function is a little different this time,</span>
<span id="cb21-530"><a href="#cb21-530" aria-hidden="true" tabindex="-1"></a>because now we are using <span class="in">`catch`</span> instead of <span class="in">`try`</span> in the <span class="in">`print()`</span> call.</span>
<span id="cb21-531"><a href="#cb21-531" aria-hidden="true" tabindex="-1"></a>Currently, the <span class="in">`Pool`</span> struct only supports functions that don't return errors</span>
<span id="cb21-532"><a href="#cb21-532" aria-hidden="true" tabindex="-1"></a>as tasks. Thus, when assigning tasks to threads in a thread pool, it is essential to use functions</span>
<span id="cb21-533"><a href="#cb21-533" aria-hidden="true" tabindex="-1"></a>that don't return errors. That is why we are using <span class="in">`catch`</span> here, so that the</span>
<span id="cb21-534"><a href="#cb21-534" aria-hidden="true" tabindex="-1"></a><span class="in">`print_id()`</span> function don't return an error.</span>
<span id="cb21-535"><a href="#cb21-535" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-536"><a href="#cb21-536" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-539"><a href="#cb21-539" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb21-540"><a href="#cb21-540" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb21-541"><a href="#cb21-541" aria-hidden="true" tabindex="-1"></a><span class="in">fn print_id(id: *const u8) void {</span></span>
<span id="cb21-542"><a href="#cb21-542" aria-hidden="true" tabindex="-1"></a><span class="in">    _ = stdout.print("Thread ID: {d}\n", .{id.*})</span></span>
<span id="cb21-543"><a href="#cb21-543" aria-hidden="true" tabindex="-1"></a><span class="in">        catch void;</span></span>
<span id="cb21-544"><a href="#cb21-544" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb21-545"><a href="#cb21-545" aria-hidden="true" tabindex="-1"></a><span class="in">const id1: u8 = 1;</span></span>
<span id="cb21-546"><a href="#cb21-546" aria-hidden="true" tabindex="-1"></a><span class="in">const id2: u8 = 2;</span></span>
<span id="cb21-547"><a href="#cb21-547" aria-hidden="true" tabindex="-1"></a><span class="in">try pool.spawn(print_id, .{&amp;id1});</span></span>
<span id="cb21-548"><a href="#cb21-548" aria-hidden="true" tabindex="-1"></a><span class="in">try pool.spawn(print_id, .{&amp;id2});</span></span>
<span id="cb21-549"><a href="#cb21-549" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-550"><a href="#cb21-550" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-551"><a href="#cb21-551" aria-hidden="true" tabindex="-1"></a>This limitation should probably not exist, and, in fact, it's already on the radar of the</span>
<span id="cb21-552"><a href="#cb21-552" aria-hidden="true" tabindex="-1"></a>Zig team to fix this issue, and it's being tracked in an <span class="co">[</span><span class="ot">open issue</span><span class="co">](https://github.com/ziglang/zig/issues/18810)</span><span class="ot">[^issue]</span>.</span>
<span id="cb21-553"><a href="#cb21-553" aria-hidden="true" tabindex="-1"></a>So, if you do need to provide a function that might return an error as the task</span>
<span id="cb21-554"><a href="#cb21-554" aria-hidden="true" tabindex="-1"></a>to be performed by the threads in the thread pool, then, you are either limited to:</span>
<span id="cb21-555"><a href="#cb21-555" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-556"><a href="#cb21-556" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>implementing your own thread pool that does not have this limitation.</span>
<span id="cb21-557"><a href="#cb21-557" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>wait for the Zig team to actually fix this issue.</span>
<span id="cb21-558"><a href="#cb21-558" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-559"><a href="#cb21-559" aria-hidden="true" tabindex="-1"></a><span class="ot">[^issue]: &lt;https://github.com/ziglang/zig/issues/18810&gt;</span></span>
<span id="cb21-560"><a href="#cb21-560" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-561"><a href="#cb21-561" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-562"><a href="#cb21-562" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-563"><a href="#cb21-563" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-564"><a href="#cb21-564" aria-hidden="true" tabindex="-1"></a><span class="fu">## Mutexes</span></span>
<span id="cb21-565"><a href="#cb21-565" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-566"><a href="#cb21-566" aria-hidden="true" tabindex="-1"></a>Mutexes are a classic component of every thread library. In essence, a mutex is a *Mutually Exclusive Flag*, and this flag</span>
<span id="cb21-567"><a href="#cb21-567" aria-hidden="true" tabindex="-1"></a>acts like a type of "lock", or as a gate keeper to a particular section of your code. Mutexes are related to thread synchronization,</span>
<span id="cb21-568"><a href="#cb21-568" aria-hidden="true" tabindex="-1"></a>more specifically, they prevent you from having some classic race conditions in your program,</span>
<span id="cb21-569"><a href="#cb21-569" aria-hidden="true" tabindex="-1"></a>and, therefore, major bugs and undefined behaviour that are usually difficult to track and understand.</span>
<span id="cb21-570"><a href="#cb21-570" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-571"><a href="#cb21-571" aria-hidden="true" tabindex="-1"></a>The main idea behind a mutex is to help us to control the execution of a particular section of the code, and to</span>
<span id="cb21-572"><a href="#cb21-572" aria-hidden="true" tabindex="-1"></a>prevent two or more threads from executing this particular section of the code at the same time.</span>
<span id="cb21-573"><a href="#cb21-573" aria-hidden="true" tabindex="-1"></a>Many programmers like to compare a mutex to a bathroom door (which typically has a lock).</span>
<span id="cb21-574"><a href="#cb21-574" aria-hidden="true" tabindex="-1"></a>When a thread locks its own mutex object, it's like if the bathroom door was locked.</span>
<span id="cb21-575"><a href="#cb21-575" aria-hidden="true" tabindex="-1"></a>Therefore, other people (in this case, other threads) who want to use the same bathroom at the same time</span>
<span id="cb21-576"><a href="#cb21-576" aria-hidden="true" tabindex="-1"></a>must be patient and simply wait for the current occupant (or thread) to unlock the door and get out of the bathroom.</span>
<span id="cb21-577"><a href="#cb21-577" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-578"><a href="#cb21-578" aria-hidden="true" tabindex="-1"></a>Some other programmers also like to explain mutexes by using the analogy of "each person will have their turn to speak".</span>
<span id="cb21-579"><a href="#cb21-579" aria-hidden="true" tabindex="-1"></a>This is the analogy used in the <span class="co">[</span><span class="ot">*Multithreading Code* video from the Computerphile project</span><span class="co">](https://www.youtube.com/watch?v=7ENFeb-J75k&amp;ab_channel=Computerphile)</span><span class="ot">[^computerphile]</span>.</span>
<span id="cb21-580"><a href="#cb21-580" aria-hidden="true" tabindex="-1"></a>Imagine if you are in a conversation circle. There is a moderator in this circle, which is the person that decides who</span>
<span id="cb21-581"><a href="#cb21-581" aria-hidden="true" tabindex="-1"></a>has the right to speak at that particular moment. The moderator gives a green card (or some sort of an authorization card) to the person that</span>
<span id="cb21-582"><a href="#cb21-582" aria-hidden="true" tabindex="-1"></a>is going to speak, and, as a result, everyone else must be silent and hear this person that has the green card.</span>
<span id="cb21-583"><a href="#cb21-583" aria-hidden="true" tabindex="-1"></a>When the person finishes talking, they give the green card back to the moderator, and the moderator decides</span>
<span id="cb21-584"><a href="#cb21-584" aria-hidden="true" tabindex="-1"></a>who is going to talk next, and delivers the green card to that person. And the cycle goes on like this.</span>
<span id="cb21-585"><a href="#cb21-585" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-586"><a href="#cb21-586" aria-hidden="true" tabindex="-1"></a><span class="ot">[^computerphile]: &lt;https://www.youtube.com/watch?v=7ENFeb-J75k&amp;ab_channel=Computerphile&gt;</span></span>
<span id="cb21-587"><a href="#cb21-587" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-588"><a href="#cb21-588" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-589"><a href="#cb21-589" aria-hidden="true" tabindex="-1"></a>A mutex acts like the moderator in this conversation circle. The mutex authorizes one single thread to execute a specific section of the code,</span>
<span id="cb21-590"><a href="#cb21-590" aria-hidden="true" tabindex="-1"></a>and it also blocks the other threads from executing this same section of the code. If these other threads want to execute this same</span>
<span id="cb21-591"><a href="#cb21-591" aria-hidden="true" tabindex="-1"></a>piece of the code, they are forced to wait for the the authorized thread to finish first.</span>
<span id="cb21-592"><a href="#cb21-592" aria-hidden="true" tabindex="-1"></a>When the authorized thread finishes executing this code, the mutex authorizes the next thread to execute this code,</span>
<span id="cb21-593"><a href="#cb21-593" aria-hidden="true" tabindex="-1"></a>while the remaining threads remain blocked. Therefore, a mutex is like a moderator that does a "each</span>
<span id="cb21-594"><a href="#cb21-594" aria-hidden="true" tabindex="-1"></a>thread will have their turn to execute this section of the code" type of control.</span>
<span id="cb21-595"><a href="#cb21-595" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-596"><a href="#cb21-596" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-597"><a href="#cb21-597" aria-hidden="true" tabindex="-1"></a>Mutexes are especially used to prevent data race problems from happening. A data race problem happens when two or more threads</span>
<span id="cb21-598"><a href="#cb21-598" aria-hidden="true" tabindex="-1"></a>are trying to read from or write to the same shared object at the same time.</span>
<span id="cb21-599"><a href="#cb21-599" aria-hidden="true" tabindex="-1"></a>So, when you have an object that is shared will all threads, and, you want to avoid two or more threads from</span>
<span id="cb21-600"><a href="#cb21-600" aria-hidden="true" tabindex="-1"></a>accessing this same object at the same time, you can use a mutex to lock the part of the code that access this specific object.</span>
<span id="cb21-601"><a href="#cb21-601" aria-hidden="true" tabindex="-1"></a>When a thread tries to run this code that is locked by a mutex, this thread stops its execution,</span>
<span id="cb21-602"><a href="#cb21-602" aria-hidden="true" tabindex="-1"></a>and patiently waits for this section of the codebase to be unlocked to continue.</span>
<span id="cb21-603"><a href="#cb21-603" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-604"><a href="#cb21-604" aria-hidden="true" tabindex="-1"></a>Notice that mutexes are normally used to lock areas of the codebase that access/modify data that is **shared** with all threads,</span>
<span id="cb21-605"><a href="#cb21-605" aria-hidden="true" tabindex="-1"></a>i.e., objects that are either stored in the global data section, or in the heap space of your program.</span>
<span id="cb21-606"><a href="#cb21-606" aria-hidden="true" tabindex="-1"></a>So mutexes are not normally used on areas of the codebase that access/modify objects that are local to the thread.</span>
<span id="cb21-607"><a href="#cb21-607" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-608"><a href="#cb21-608" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-609"><a href="#cb21-609" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-610"><a href="#cb21-610" aria-hidden="true" tabindex="-1"></a><span class="fu">### Critical section {#sec-critical-section}</span></span>
<span id="cb21-611"><a href="#cb21-611" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-612"><a href="#cb21-612" aria-hidden="true" tabindex="-1"></a>Critical section is a concept commonly associated with mutexes and thread synchronization.</span>
<span id="cb21-613"><a href="#cb21-613" aria-hidden="true" tabindex="-1"></a>In essence, a critical section is the section of the program that a thread access/modify a shared resource</span>
<span id="cb21-614"><a href="#cb21-614" aria-hidden="true" tabindex="-1"></a>(i.e., an object, a file descriptor, something that all threads have access to). In other words,</span>
<span id="cb21-615"><a href="#cb21-615" aria-hidden="true" tabindex="-1"></a>a critical section is the section of the program where race conditions might happen, and, therefore,</span>
<span id="cb21-616"><a href="#cb21-616" aria-hidden="true" tabindex="-1"></a>where undefined behaviour can be introduced into the program.</span>
<span id="cb21-617"><a href="#cb21-617" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-618"><a href="#cb21-618" aria-hidden="true" tabindex="-1"></a>When we use mutexes in our program, the critical section defines the area of the codebase that we want to lock.</span>
<span id="cb21-619"><a href="#cb21-619" aria-hidden="true" tabindex="-1"></a>So we normally lock the mutex object at the beginning of the critical section,</span>
<span id="cb21-620"><a href="#cb21-620" aria-hidden="true" tabindex="-1"></a>and then, we unlock it at the end of the critical section.</span>
<span id="cb21-621"><a href="#cb21-621" aria-hidden="true" tabindex="-1"></a>The two bullet points exposed below comes from the "Critical Section" article from GeekFromGeeks,</span>
<span id="cb21-622"><a href="#cb21-622" aria-hidden="true" tabindex="-1"></a>and they summarise well the role that a critical section plays in the thread synchronization problem <span class="co">[</span><span class="ot">@geeks_critical_section</span><span class="co">]</span>.</span>
<span id="cb21-623"><a href="#cb21-623" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-624"><a href="#cb21-624" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-625"><a href="#cb21-625" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>The critical section must be executed as an atomic operation, which means that once one thread or process has entered the critical section, all other threads or processes must wait until the executing thread or process exits the critical section. The purpose of synchronization mechanisms is to ensure that only one thread or process can execute the critical section at a time.</span>
<span id="cb21-626"><a href="#cb21-626" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>The concept of a critical section is central to synchronization in computer systems, as it is necessary to ensure that multiple threads or processes can execute concurrently without interfering with each other. Various synchronization mechanisms such as semaphores, mutexes, monitors, and condition variables are used to implement critical sections and ensure that shared resources are accessed in a mutually exclusive manner.</span>
<span id="cb21-627"><a href="#cb21-627" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-628"><a href="#cb21-628" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-629"><a href="#cb21-629" aria-hidden="true" tabindex="-1"></a><span class="fu">### Atomic operations {#sec-atomic-operation}</span></span>
<span id="cb21-630"><a href="#cb21-630" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-631"><a href="#cb21-631" aria-hidden="true" tabindex="-1"></a>You will also see the term "atomic operation" a lot when reading about threads, race conditions and mutexes.</span>
<span id="cb21-632"><a href="#cb21-632" aria-hidden="true" tabindex="-1"></a>In summary, an operation is categorized as "atomic" when a context switch cannot occur in</span>
<span id="cb21-633"><a href="#cb21-633" aria-hidden="true" tabindex="-1"></a>the middle of the operation. In other words, this operation is always done from beginning to end, without interruptions</span>
<span id="cb21-634"><a href="#cb21-634" aria-hidden="true" tabindex="-1"></a>of another process or operation in the middle of its execution phase.</span>
<span id="cb21-635"><a href="#cb21-635" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-636"><a href="#cb21-636" aria-hidden="true" tabindex="-1"></a>Not many operations today are atomic. But why do atomic operations matter here? It's because data races</span>
<span id="cb21-637"><a href="#cb21-637" aria-hidden="true" tabindex="-1"></a>(which is a type of a race condition) cannot happen on operations that are atomic.</span>
<span id="cb21-638"><a href="#cb21-638" aria-hidden="true" tabindex="-1"></a>So if a particular line in your code performs an atomic operation, then this line will never</span>
<span id="cb21-639"><a href="#cb21-639" aria-hidden="true" tabindex="-1"></a>suffer from a data race problem. Therefore, programmers sometimes use an atomic operation</span>
<span id="cb21-640"><a href="#cb21-640" aria-hidden="true" tabindex="-1"></a>to protect themselves from data race problems in their code.</span>
<span id="cb21-641"><a href="#cb21-641" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-642"><a href="#cb21-642" aria-hidden="true" tabindex="-1"></a>When you have an operation that is compiled into just one single assembly instruction, this operation might be atomic,</span>
<span id="cb21-643"><a href="#cb21-643" aria-hidden="true" tabindex="-1"></a>because it's just one assembly instruction. But this is not guaranteed. This is usually true for old CPU architectures</span>
<span id="cb21-644"><a href="#cb21-644" aria-hidden="true" tabindex="-1"></a>(such as <span class="in">`x86`</span>). But nowadays, most assembly instructions in modern CPU architectures are broken down into multiple micro-tasks,</span>
<span id="cb21-645"><a href="#cb21-645" aria-hidden="true" tabindex="-1"></a>which inherently makes the operation non-atomic, even if it consists of a single assembly instruction.</span>
<span id="cb21-646"><a href="#cb21-646" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-647"><a href="#cb21-647" aria-hidden="true" tabindex="-1"></a>The Zig Standard Library offers some atomic functionality in the <span class="in">`std.atomic`</span> module.</span>
<span id="cb21-648"><a href="#cb21-648" aria-hidden="true" tabindex="-1"></a>In this module, you will find a public and generic function called <span class="in">`Value()`</span>. With this function we create an "atomic object", which is</span>
<span id="cb21-649"><a href="#cb21-649" aria-hidden="true" tabindex="-1"></a>a value that contains some native atomic operations, most notably, a <span class="in">`load()`</span> and a <span class="in">`fetchAdd()`</span> operation.</span>
<span id="cb21-650"><a href="#cb21-650" aria-hidden="true" tabindex="-1"></a>If you have experience with multithreading in C++, you probably have recognized this pattern. So yes, this generic</span>
<span id="cb21-651"><a href="#cb21-651" aria-hidden="true" tabindex="-1"></a>"atomic object" in Zig is essentially identical to the template struct <span class="in">`std::atomic`</span> from the C++ Standard Library.</span>
<span id="cb21-652"><a href="#cb21-652" aria-hidden="true" tabindex="-1"></a>It's important to emphasize that only primitive data types (i.e., the types presented in @sec-primitive-data-types)</span>
<span id="cb21-653"><a href="#cb21-653" aria-hidden="true" tabindex="-1"></a>are supported by these atomic operations in Zig.</span>
<span id="cb21-654"><a href="#cb21-654" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-655"><a href="#cb21-655" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-656"><a href="#cb21-656" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-657"><a href="#cb21-657" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-658"><a href="#cb21-658" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-659"><a href="#cb21-659" aria-hidden="true" tabindex="-1"></a><span class="fu">### Data races and race conditions</span></span>
<span id="cb21-660"><a href="#cb21-660" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-661"><a href="#cb21-661" aria-hidden="true" tabindex="-1"></a>To understand why mutexes are used, we need to understand better the problem that they seek</span>
<span id="cb21-662"><a href="#cb21-662" aria-hidden="true" tabindex="-1"></a>to solve, which can be summarized into data race problems. A data race problem is a type of a race condition,</span>
<span id="cb21-663"><a href="#cb21-663" aria-hidden="true" tabindex="-1"></a>which happens when one thread is accessing a particular memory location (i.e., a particular shared object) at the same</span>
<span id="cb21-664"><a href="#cb21-664" aria-hidden="true" tabindex="-1"></a>time that another thread is trying to write/save new data into this same memory location (i.e., the same shared object).</span>
<span id="cb21-665"><a href="#cb21-665" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-666"><a href="#cb21-666" aria-hidden="true" tabindex="-1"></a>We can simply define a race condition as any type of bug in your program that is based</span>
<span id="cb21-667"><a href="#cb21-667" aria-hidden="true" tabindex="-1"></a>on a "who gets there first" problem. A data race problem is a type of a race condition, because it occurs when two or more parties</span>
<span id="cb21-668"><a href="#cb21-668" aria-hidden="true" tabindex="-1"></a>are trying to read and write into the same memory location at the same time, and, therefore, the end result of this operation</span>
<span id="cb21-669"><a href="#cb21-669" aria-hidden="true" tabindex="-1"></a>depends completely on who gets to this memory location first.</span>
<span id="cb21-670"><a href="#cb21-670" aria-hidden="true" tabindex="-1"></a>As a consequence, a program that has a data race problem will likely produce a different result each time that we execute it.</span>
<span id="cb21-671"><a href="#cb21-671" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-672"><a href="#cb21-672" aria-hidden="true" tabindex="-1"></a>Thus, race conditions produce undefined behaviour and unpredictability because the program produces</span>
<span id="cb21-673"><a href="#cb21-673" aria-hidden="true" tabindex="-1"></a>a different answer each time a different person gets to the target location before the others.</span>
<span id="cb21-674"><a href="#cb21-674" aria-hidden="true" tabindex="-1"></a>And, we have no easy way to either predict or control who is getting to this target location first.</span>
<span id="cb21-675"><a href="#cb21-675" aria-hidden="true" tabindex="-1"></a>In other words, each time your program runs, you may get a different answer because a different person,</span>
<span id="cb21-676"><a href="#cb21-676" aria-hidden="true" tabindex="-1"></a>function, or part of the code finishes its tasks before the others.</span>
<span id="cb21-677"><a href="#cb21-677" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-678"><a href="#cb21-678" aria-hidden="true" tabindex="-1"></a>As an example, consider the code snippet exposed below. In this example, we create a global counter</span>
<span id="cb21-679"><a href="#cb21-679" aria-hidden="true" tabindex="-1"></a>variable, and we also create an <span class="in">`increment()`</span> function, whose job is to just increment this global counter</span>
<span id="cb21-680"><a href="#cb21-680" aria-hidden="true" tabindex="-1"></a>variable in a for loop.</span>
<span id="cb21-681"><a href="#cb21-681" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-682"><a href="#cb21-682" aria-hidden="true" tabindex="-1"></a>Since the for loop iterates 1 hundred thousand times, and, we create two separate threads</span>
<span id="cb21-683"><a href="#cb21-683" aria-hidden="true" tabindex="-1"></a>in this code example, what number do you expect to see in the final message printed to <span class="in">`stdout`</span>?</span>
<span id="cb21-684"><a href="#cb21-684" aria-hidden="true" tabindex="-1"></a>The answer should be 2 hundred thousand. Right? Well, in theory, this program was supposed</span>
<span id="cb21-685"><a href="#cb21-685" aria-hidden="true" tabindex="-1"></a>to print 2 hundred thousand at the end, but in practice, every time that I execute this program</span>
<span id="cb21-686"><a href="#cb21-686" aria-hidden="true" tabindex="-1"></a>I get a different answer.</span>
<span id="cb21-687"><a href="#cb21-687" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-688"><a href="#cb21-688" aria-hidden="true" tabindex="-1"></a>In the example exposed below, you can see that this time the end</span>
<span id="cb21-689"><a href="#cb21-689" aria-hidden="true" tabindex="-1"></a>result was 117254, instead of the expected 200000. The second time I executed this program,</span>
<span id="cb21-690"><a href="#cb21-690" aria-hidden="true" tabindex="-1"></a>I got the number 108592 as the result. So the end result of this program is varying, but it never gets</span>
<span id="cb21-691"><a href="#cb21-691" aria-hidden="true" tabindex="-1"></a>to the expected 200000 that we want.</span>
<span id="cb21-692"><a href="#cb21-692" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-693"><a href="#cb21-693" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-696"><a href="#cb21-696" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb21-697"><a href="#cb21-697" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: false</span></span>
<span id="cb21-698"><a href="#cb21-698" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb21-699"><a href="#cb21-699" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb21-700"><a href="#cb21-700" aria-hidden="true" tabindex="-1"></a><span class="in">// Global counter variable</span></span>
<span id="cb21-701"><a href="#cb21-701" aria-hidden="true" tabindex="-1"></a><span class="in">var counter: usize = 0;</span></span>
<span id="cb21-702"><a href="#cb21-702" aria-hidden="true" tabindex="-1"></a><span class="in">// Function to increment the counter</span></span>
<span id="cb21-703"><a href="#cb21-703" aria-hidden="true" tabindex="-1"></a><span class="in">fn increment() void {</span></span>
<span id="cb21-704"><a href="#cb21-704" aria-hidden="true" tabindex="-1"></a><span class="in">    for (0..100000) |_| {</span></span>
<span id="cb21-705"><a href="#cb21-705" aria-hidden="true" tabindex="-1"></a><span class="in">        counter += 1;</span></span>
<span id="cb21-706"><a href="#cb21-706" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb21-707"><a href="#cb21-707" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb21-708"><a href="#cb21-708" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-709"><a href="#cb21-709" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb21-710"><a href="#cb21-710" aria-hidden="true" tabindex="-1"></a><span class="in">    const thr1 = try Thread.spawn(.{}, increment, .{});</span></span>
<span id="cb21-711"><a href="#cb21-711" aria-hidden="true" tabindex="-1"></a><span class="in">    const thr2 = try Thread.spawn(.{}, increment, .{});</span></span>
<span id="cb21-712"><a href="#cb21-712" aria-hidden="true" tabindex="-1"></a><span class="in">    thr1.join();</span></span>
<span id="cb21-713"><a href="#cb21-713" aria-hidden="true" tabindex="-1"></a><span class="in">    thr2.join();</span></span>
<span id="cb21-714"><a href="#cb21-714" aria-hidden="true" tabindex="-1"></a><span class="in">    try stdout.print("Couter value: {d}\n", .{counter});</span></span>
<span id="cb21-715"><a href="#cb21-715" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb21-716"><a href="#cb21-716" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-717"><a href="#cb21-717" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-718"><a href="#cb21-718" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-719"><a href="#cb21-719" aria-hidden="true" tabindex="-1"></a><span class="in">Couter value: 117254</span></span>
<span id="cb21-720"><a href="#cb21-720" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-721"><a href="#cb21-721" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-722"><a href="#cb21-722" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-723"><a href="#cb21-723" aria-hidden="true" tabindex="-1"></a>Why this is happening? The answer is: because this program contains a data race problem.</span>
<span id="cb21-724"><a href="#cb21-724" aria-hidden="true" tabindex="-1"></a>This program would print the correct number 200000 if and only if the first thread finishes</span>
<span id="cb21-725"><a href="#cb21-725" aria-hidden="true" tabindex="-1"></a>its tasks before the second thread starts to execute. But that is very unlikely to happen.</span>
<span id="cb21-726"><a href="#cb21-726" aria-hidden="true" tabindex="-1"></a>Because the process of creating the thread is too fast, and therefore, both threads start to execute roughly</span>
<span id="cb21-727"><a href="#cb21-727" aria-hidden="true" tabindex="-1"></a>at the same time. If you change this code to add some nanoseconds of sleep between the first and the second calls to <span class="in">`spawn()`</span>,</span>
<span id="cb21-728"><a href="#cb21-728" aria-hidden="true" tabindex="-1"></a>you will increase the chances of the program producing the "correct result".</span>
<span id="cb21-729"><a href="#cb21-729" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-730"><a href="#cb21-730" aria-hidden="true" tabindex="-1"></a>So the data race problem happens because both threads are reading and writing to the same</span>
<span id="cb21-731"><a href="#cb21-731" aria-hidden="true" tabindex="-1"></a>memory location at roughly the same time. In this example, each thread is essentially performing</span>
<span id="cb21-732"><a href="#cb21-732" aria-hidden="true" tabindex="-1"></a>three basic operations at each iteration of the for loop, which are:</span>
<span id="cb21-733"><a href="#cb21-733" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-734"><a href="#cb21-734" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>reading the current value of <span class="in">`count`</span>.</span>
<span id="cb21-735"><a href="#cb21-735" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>incrementing this value by 1.</span>
<span id="cb21-736"><a href="#cb21-736" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>writing the result back into <span class="in">`count`</span>.</span>
<span id="cb21-737"><a href="#cb21-737" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-738"><a href="#cb21-738" aria-hidden="true" tabindex="-1"></a>Ideally, a thread B should read the value of <span class="in">`count`</span>, only after the other thread A has finished</span>
<span id="cb21-739"><a href="#cb21-739" aria-hidden="true" tabindex="-1"></a>writing the incremented value back into the <span class="in">`count`</span> object. Therefore, in the ideal scenario, which is demonstrated</span>
<span id="cb21-740"><a href="#cb21-740" aria-hidden="true" tabindex="-1"></a>in @tbl-data-race-ideal, the threads should work in sync with each other. But the reality is that these</span>
<span id="cb21-741"><a href="#cb21-741" aria-hidden="true" tabindex="-1"></a>threads are out of sync, and because of that, they suffer from a data race problem, which is demonstrated</span>
<span id="cb21-742"><a href="#cb21-742" aria-hidden="true" tabindex="-1"></a>in @tbl-data-race-not.</span>
<span id="cb21-743"><a href="#cb21-743" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-744"><a href="#cb21-744" aria-hidden="true" tabindex="-1"></a>Notice that, in the data race scenario (@tbl-data-race-not), the read performed by a thread B happens</span>
<span id="cb21-745"><a href="#cb21-745" aria-hidden="true" tabindex="-1"></a>before the write operation of thread A, and that ultimately leads to wrong results at the end of the program.</span>
<span id="cb21-746"><a href="#cb21-746" aria-hidden="true" tabindex="-1"></a>Because when thread B reads the value of the <span class="in">`count`</span> variable, thread A is still processing</span>
<span id="cb21-747"><a href="#cb21-747" aria-hidden="true" tabindex="-1"></a>the initial value from <span class="in">`count`</span>, and has not yet written the new, incremented value back to <span class="in">`count`</span>. As a result,</span>
<span id="cb21-748"><a href="#cb21-748" aria-hidden="true" tabindex="-1"></a>thread B ends up reading the same initial (or "old") value from <span class="in">`count`</span> instead of</span>
<span id="cb21-749"><a href="#cb21-749" aria-hidden="true" tabindex="-1"></a>the updated, incremented value that thread A would have written.</span>
<span id="cb21-750"><a href="#cb21-750" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-751"><a href="#cb21-751" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-752"><a href="#cb21-752" aria-hidden="true" tabindex="-1"></a>::: {#tbl-data-race-ideal}</span>
<span id="cb21-753"><a href="#cb21-753" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-754"><a href="#cb21-754" aria-hidden="true" tabindex="-1"></a>| Thread 1    | Thread 2    | Integer value |</span>
<span id="cb21-755"><a href="#cb21-755" aria-hidden="true" tabindex="-1"></a>|-------------|-------------|---------------|</span>
<span id="cb21-756"><a href="#cb21-756" aria-hidden="true" tabindex="-1"></a>| read value  |             | 0             |</span>
<span id="cb21-757"><a href="#cb21-757" aria-hidden="true" tabindex="-1"></a>| increment   |             | 1             |</span>
<span id="cb21-758"><a href="#cb21-758" aria-hidden="true" tabindex="-1"></a>| write value |             | 1             |</span>
<span id="cb21-759"><a href="#cb21-759" aria-hidden="true" tabindex="-1"></a>|             | read value  | 1             |</span>
<span id="cb21-760"><a href="#cb21-760" aria-hidden="true" tabindex="-1"></a>|             | increment   | 2             |</span>
<span id="cb21-761"><a href="#cb21-761" aria-hidden="true" tabindex="-1"></a>|             | write value | 2             |</span>
<span id="cb21-762"><a href="#cb21-762" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-763"><a href="#cb21-763" aria-hidden="true" tabindex="-1"></a>: An ideal scenario for two threads incrementing the same integer value</span>
<span id="cb21-764"><a href="#cb21-764" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb21-765"><a href="#cb21-765" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-766"><a href="#cb21-766" aria-hidden="true" tabindex="-1"></a>::: {#tbl-data-race-not}</span>
<span id="cb21-767"><a href="#cb21-767" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-768"><a href="#cb21-768" aria-hidden="true" tabindex="-1"></a>| Thread 1    | Thread 2    | Integer value |</span>
<span id="cb21-769"><a href="#cb21-769" aria-hidden="true" tabindex="-1"></a>|-------------|-------------|---------------|</span>
<span id="cb21-770"><a href="#cb21-770" aria-hidden="true" tabindex="-1"></a>| read value  |             | 0             |</span>
<span id="cb21-771"><a href="#cb21-771" aria-hidden="true" tabindex="-1"></a>|             | read value  | 0             |</span>
<span id="cb21-772"><a href="#cb21-772" aria-hidden="true" tabindex="-1"></a>| increment   |             | 1             |</span>
<span id="cb21-773"><a href="#cb21-773" aria-hidden="true" tabindex="-1"></a>|             | increment   | 1             |</span>
<span id="cb21-774"><a href="#cb21-774" aria-hidden="true" tabindex="-1"></a>| write value |             | 1             |</span>
<span id="cb21-775"><a href="#cb21-775" aria-hidden="true" tabindex="-1"></a>|             | write value | 1             |</span>
<span id="cb21-776"><a href="#cb21-776" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-777"><a href="#cb21-777" aria-hidden="true" tabindex="-1"></a>: A data race scenario when two threads are incrementing the same integer value</span>
<span id="cb21-778"><a href="#cb21-778" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb21-779"><a href="#cb21-779" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-780"><a href="#cb21-780" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-781"><a href="#cb21-781" aria-hidden="true" tabindex="-1"></a>If you think about these diagrams exposed in form of tables, you will notice that they relate back to our discussion of atomic operations</span>
<span id="cb21-782"><a href="#cb21-782" aria-hidden="true" tabindex="-1"></a>in @sec-atomic-operation. Remember, atomic operations are operations that the CPU executes</span>
<span id="cb21-783"><a href="#cb21-783" aria-hidden="true" tabindex="-1"></a>from beginning to end, without interruptions from other threads or processes. So,</span>
<span id="cb21-784"><a href="#cb21-784" aria-hidden="true" tabindex="-1"></a>the scenario exposed in @tbl-data-race-ideal does not suffer from a data race, because</span>
<span id="cb21-785"><a href="#cb21-785" aria-hidden="true" tabindex="-1"></a>the operations performed by thread A are not interrupted in the middle by the operations</span>
<span id="cb21-786"><a href="#cb21-786" aria-hidden="true" tabindex="-1"></a>from thread B.</span>
<span id="cb21-787"><a href="#cb21-787" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-788"><a href="#cb21-788" aria-hidden="true" tabindex="-1"></a>If we also think about the discussion of critical section from @sec-critical-section, we can identify</span>
<span id="cb21-789"><a href="#cb21-789" aria-hidden="true" tabindex="-1"></a>the section that representes the critical section of the program, which is the section that is vulnerable</span>
<span id="cb21-790"><a href="#cb21-790" aria-hidden="true" tabindex="-1"></a>to data race conditions. In this example, the critical section of the program is the line where we increment</span>
<span id="cb21-791"><a href="#cb21-791" aria-hidden="true" tabindex="-1"></a>the <span class="in">`counter`</span> variable (<span class="in">`counter += 1`</span>). So, ideally, we want to use a mutex, and lock right before this line, and then</span>
<span id="cb21-792"><a href="#cb21-792" aria-hidden="true" tabindex="-1"></a>unlock right after this line.</span>
<span id="cb21-793"><a href="#cb21-793" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-794"><a href="#cb21-794" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-795"><a href="#cb21-795" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-796"><a href="#cb21-796" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-797"><a href="#cb21-797" aria-hidden="true" tabindex="-1"></a><span class="fu">### Using mutexes in Zig</span></span>
<span id="cb21-798"><a href="#cb21-798" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-799"><a href="#cb21-799" aria-hidden="true" tabindex="-1"></a>Now that we know the problem that mutexes seek to solve, we can learn how to use them in Zig.</span>
<span id="cb21-800"><a href="#cb21-800" aria-hidden="true" tabindex="-1"></a>Mutexes in Zig are available through the <span class="in">`std.Thread.Mutex`</span> struct from the Zig Standard Library.</span>
<span id="cb21-801"><a href="#cb21-801" aria-hidden="true" tabindex="-1"></a>If we take the same code from the previous example, and improve it with mutexes, to solve</span>
<span id="cb21-802"><a href="#cb21-802" aria-hidden="true" tabindex="-1"></a>our data race problem, we get the code example below.</span>
<span id="cb21-803"><a href="#cb21-803" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-804"><a href="#cb21-804" aria-hidden="true" tabindex="-1"></a>Notice that this time, we had to alter the <span class="in">`increment()`</span> function to receive a pointer to</span>
<span id="cb21-805"><a href="#cb21-805" aria-hidden="true" tabindex="-1"></a>the <span class="in">`Mutex`</span> object as input. All that we need to do, to make this program safe against</span>
<span id="cb21-806"><a href="#cb21-806" aria-hidden="true" tabindex="-1"></a>data race problems, is to call the <span class="in">`lock()`</span> method at the beginning of</span>
<span id="cb21-807"><a href="#cb21-807" aria-hidden="true" tabindex="-1"></a>the critical section, and then, call <span class="in">`unlock()`</span> at the end of the critical section.</span>
<span id="cb21-808"><a href="#cb21-808" aria-hidden="true" tabindex="-1"></a>Notice that the output of this program is now the correct number of 200000.</span>
<span id="cb21-809"><a href="#cb21-809" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-812"><a href="#cb21-812" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb21-813"><a href="#cb21-813" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb21-814"><a href="#cb21-814" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb21-815"><a href="#cb21-815" aria-hidden="true" tabindex="-1"></a><span class="in">const stdout = std.io.getStdOut().writer();</span></span>
<span id="cb21-816"><a href="#cb21-816" aria-hidden="true" tabindex="-1"></a><span class="in">const Thread = std.Thread;</span></span>
<span id="cb21-817"><a href="#cb21-817" aria-hidden="true" tabindex="-1"></a><span class="in">const Mutex = std.Thread.Mutex;</span></span>
<span id="cb21-818"><a href="#cb21-818" aria-hidden="true" tabindex="-1"></a><span class="in">var counter: usize = 0;</span></span>
<span id="cb21-819"><a href="#cb21-819" aria-hidden="true" tabindex="-1"></a><span class="in">fn increment(mutex: *Mutex) void {</span></span>
<span id="cb21-820"><a href="#cb21-820" aria-hidden="true" tabindex="-1"></a><span class="in">    for (0..100000) |_| {</span></span>
<span id="cb21-821"><a href="#cb21-821" aria-hidden="true" tabindex="-1"></a><span class="in">        mutex.lock();</span></span>
<span id="cb21-822"><a href="#cb21-822" aria-hidden="true" tabindex="-1"></a><span class="in">        counter += 1;</span></span>
<span id="cb21-823"><a href="#cb21-823" aria-hidden="true" tabindex="-1"></a><span class="in">        mutex.unlock();</span></span>
<span id="cb21-824"><a href="#cb21-824" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb21-825"><a href="#cb21-825" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb21-826"><a href="#cb21-826" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-827"><a href="#cb21-827" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb21-828"><a href="#cb21-828" aria-hidden="true" tabindex="-1"></a><span class="in">    var mutex: Mutex = .{};</span></span>
<span id="cb21-829"><a href="#cb21-829" aria-hidden="true" tabindex="-1"></a><span class="in">    const thr1 = try Thread.spawn(.{}, increment, .{&amp;mutex});</span></span>
<span id="cb21-830"><a href="#cb21-830" aria-hidden="true" tabindex="-1"></a><span class="in">    const thr2 = try Thread.spawn(.{}, increment, .{&amp;mutex});</span></span>
<span id="cb21-831"><a href="#cb21-831" aria-hidden="true" tabindex="-1"></a><span class="in">    thr1.join();</span></span>
<span id="cb21-832"><a href="#cb21-832" aria-hidden="true" tabindex="-1"></a><span class="in">    thr2.join();</span></span>
<span id="cb21-833"><a href="#cb21-833" aria-hidden="true" tabindex="-1"></a><span class="in">    try stdout.print("Couter value: {d}\n", .{counter});</span></span>
<span id="cb21-834"><a href="#cb21-834" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb21-835"><a href="#cb21-835" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-836"><a href="#cb21-836" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-837"><a href="#cb21-837" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-838"><a href="#cb21-838" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-839"><a href="#cb21-839" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-840"><a href="#cb21-840" aria-hidden="true" tabindex="-1"></a><span class="fu">## Read/Write locks</span></span>
<span id="cb21-841"><a href="#cb21-841" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-842"><a href="#cb21-842" aria-hidden="true" tabindex="-1"></a>Mutexes are normally used when it's not always safe for two or more threads running the same</span>
<span id="cb21-843"><a href="#cb21-843" aria-hidden="true" tabindex="-1"></a>piece of code at the same time. In contrast, read/write locks are normally used in situations</span>
<span id="cb21-844"><a href="#cb21-844" aria-hidden="true" tabindex="-1"></a>where you have a mixture of scenarios, i.e., there are some pieces of the codebase that are safe</span>
<span id="cb21-845"><a href="#cb21-845" aria-hidden="true" tabindex="-1"></a>to run in parallel, and other pieces that are not safe.</span>
<span id="cb21-846"><a href="#cb21-846" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-847"><a href="#cb21-847" aria-hidden="true" tabindex="-1"></a>For example, suppose that you have multiple threads that uses the same shared file in the filesystem to store some configurations, or</span>
<span id="cb21-848"><a href="#cb21-848" aria-hidden="true" tabindex="-1"></a>statistics. If two or more threads try to read the data from this same file at the same time, nothing bad happens.</span>
<span id="cb21-849"><a href="#cb21-849" aria-hidden="true" tabindex="-1"></a>So this part of the codebase is perfectly safe to be executed in parallel, with multiple threads reading the same file at the same time.</span>
<span id="cb21-850"><a href="#cb21-850" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-851"><a href="#cb21-851" aria-hidden="true" tabindex="-1"></a>However, if two or more threads try to write data into this same file at the same time, then we cause some race condition</span>
<span id="cb21-852"><a href="#cb21-852" aria-hidden="true" tabindex="-1"></a>problems. So this other part of the codebase is not safe to be executed in parallel.</span>
<span id="cb21-853"><a href="#cb21-853" aria-hidden="true" tabindex="-1"></a>More specifically, a thread might end up writing data in the middle of the data written by the other thread.</span>
<span id="cb21-854"><a href="#cb21-854" aria-hidden="true" tabindex="-1"></a>This process of two or more threads writing to the same location might lead to data corruption.</span>
<span id="cb21-855"><a href="#cb21-855" aria-hidden="true" tabindex="-1"></a>This specific situation is usually called a *torn write*.</span>
<span id="cb21-856"><a href="#cb21-856" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-857"><a href="#cb21-857" aria-hidden="true" tabindex="-1"></a>Thus, what we can extract from this example is that there are certain types of operations that cause</span>
<span id="cb21-858"><a href="#cb21-858" aria-hidden="true" tabindex="-1"></a>a race condition, but there are also other types of operations that do not cause a race condition problem.</span>
<span id="cb21-859"><a href="#cb21-859" aria-hidden="true" tabindex="-1"></a>You could also say that there are types of operations that are susceptible to race condition problems,</span>
<span id="cb21-860"><a href="#cb21-860" aria-hidden="true" tabindex="-1"></a>and there are other types of operations that are not.</span>
<span id="cb21-861"><a href="#cb21-861" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-862"><a href="#cb21-862" aria-hidden="true" tabindex="-1"></a>A read/write lock is a type of lock that acknowledges the existence of this specific scenario, and you can</span>
<span id="cb21-863"><a href="#cb21-863" aria-hidden="true" tabindex="-1"></a>use this type of lock to control which parts of the codebase are safe to run in parallel and which parts are not.</span>
<span id="cb21-864"><a href="#cb21-864" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-865"><a href="#cb21-865" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-866"><a href="#cb21-866" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-867"><a href="#cb21-867" aria-hidden="true" tabindex="-1"></a><span class="fu">### Exclusive lock vs shared lock</span></span>
<span id="cb21-868"><a href="#cb21-868" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-869"><a href="#cb21-869" aria-hidden="true" tabindex="-1"></a>Therefore, a read/write lock is a little different from a mutex. Because a mutex is always an *exclusive lock*, meaning that, only</span>
<span id="cb21-870"><a href="#cb21-870" aria-hidden="true" tabindex="-1"></a>one thread is allowed to execute at all times. With an exclusive lock, the other threads are always "excluded",</span>
<span id="cb21-871"><a href="#cb21-871" aria-hidden="true" tabindex="-1"></a>i.e., they are always blocked from executing. But in a read/write lock, the other threads might be authorized</span>
<span id="cb21-872"><a href="#cb21-872" aria-hidden="true" tabindex="-1"></a>to run at the same time, depending on the type of lock that they acquire.</span>
<span id="cb21-873"><a href="#cb21-873" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-874"><a href="#cb21-874" aria-hidden="true" tabindex="-1"></a>We have two types of locks in a read/write lock, which are: an exclusive lock and a shared lock. An exclusive lock works exactly the same</span>
<span id="cb21-875"><a href="#cb21-875" aria-hidden="true" tabindex="-1"></a>as a mutex, while a shared lock is a lock that does not block the other threads from running at the same time.</span>
<span id="cb21-876"><a href="#cb21-876" aria-hidden="true" tabindex="-1"></a>In the <span class="in">`pthreads`</span> C library, read/write locks are available through the <span class="in">`pthread_rwlock_t`</span> C struct. With</span>
<span id="cb21-877"><a href="#cb21-877" aria-hidden="true" tabindex="-1"></a>this C struct, you can create:</span>
<span id="cb21-878"><a href="#cb21-878" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-879"><a href="#cb21-879" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>a "write lock", which corresponds to an exclusive lock.</span>
<span id="cb21-880"><a href="#cb21-880" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>a "read lock", which corresponds to a shared lock.</span>
<span id="cb21-881"><a href="#cb21-881" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-882"><a href="#cb21-882" aria-hidden="true" tabindex="-1"></a>The terminology might be a little different compared to Zig. But the meaning is still the same.</span>
<span id="cb21-883"><a href="#cb21-883" aria-hidden="true" tabindex="-1"></a>Therefore, just remember this relationship, write locks are exclusive locks, while read locks are shared locks.</span>
<span id="cb21-884"><a href="#cb21-884" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-885"><a href="#cb21-885" aria-hidden="true" tabindex="-1"></a>When a thread tries to acquire a read lock (i.e., a shared lock), this thread gets the shared lock</span>
<span id="cb21-886"><a href="#cb21-886" aria-hidden="true" tabindex="-1"></a>if and only if another thread does not currently hold a write lock (i.e., an exclusive lock), and also</span>
<span id="cb21-887"><a href="#cb21-887" aria-hidden="true" tabindex="-1"></a>if there are no other threads already in the queue,</span>
<span id="cb21-888"><a href="#cb21-888" aria-hidden="true" tabindex="-1"></a>waiting for their turn to acquire a write lock. In other words, the thread in the queue has attempted</span>
<span id="cb21-889"><a href="#cb21-889" aria-hidden="true" tabindex="-1"></a>to get a write lock earlier, but this thread was blocked</span>
<span id="cb21-890"><a href="#cb21-890" aria-hidden="true" tabindex="-1"></a>because there was another thread running that already had a write lock. As a consequence, this thread is in the queue to get a write lock,</span>
<span id="cb21-891"><a href="#cb21-891" aria-hidden="true" tabindex="-1"></a>and it's currently waiting for the other thread with a write lock to finish its execution.</span>
<span id="cb21-892"><a href="#cb21-892" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-893"><a href="#cb21-893" aria-hidden="true" tabindex="-1"></a>When a thread tries to acquire a read lock, but it fails in acquiring this read lock, either because there is</span>
<span id="cb21-894"><a href="#cb21-894" aria-hidden="true" tabindex="-1"></a>a thread with a write lock already running, or because there is a thread in the queue to get a write lock,</span>
<span id="cb21-895"><a href="#cb21-895" aria-hidden="true" tabindex="-1"></a>the execution of this thread is instantly blocked, i.e., paused. This thread will indefinitely attempt to get the</span>
<span id="cb21-896"><a href="#cb21-896" aria-hidden="true" tabindex="-1"></a>read lock, and its execution will be unblocked (or unpaused) only after this thread successfully acquires the read lock.</span>
<span id="cb21-897"><a href="#cb21-897" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-898"><a href="#cb21-898" aria-hidden="true" tabindex="-1"></a>If you think deeply about this dynamic between read locks versus write locks, you might notice that a read lock is basically a safety mechanism.</span>
<span id="cb21-899"><a href="#cb21-899" aria-hidden="true" tabindex="-1"></a>More specifically, it's a way for us to</span>
<span id="cb21-900"><a href="#cb21-900" aria-hidden="true" tabindex="-1"></a>allow a particular thread to run together with the other threads only when it's safe to. In other words, if there is currently</span>
<span id="cb21-901"><a href="#cb21-901" aria-hidden="true" tabindex="-1"></a>a thread with a write lock running, then it's very likely not safe for the thread that is trying to acquire the read lock to run now.</span>
<span id="cb21-902"><a href="#cb21-902" aria-hidden="true" tabindex="-1"></a>As a consequence, the read lock protects this thread from running into dangerous waters, and patiently waits for the</span>
<span id="cb21-903"><a href="#cb21-903" aria-hidden="true" tabindex="-1"></a>"write lock" thread to finishes its tasks before it continues.</span>
<span id="cb21-904"><a href="#cb21-904" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-905"><a href="#cb21-905" aria-hidden="true" tabindex="-1"></a>On the other hand, if there are only "read lock" (i.e., "shared lock") threads currently running</span>
<span id="cb21-906"><a href="#cb21-906" aria-hidden="true" tabindex="-1"></a>(i.e., not a single "write lock" thread currently exists), then it</span>
<span id="cb21-907"><a href="#cb21-907" aria-hidden="true" tabindex="-1"></a>is perfectly safe for this thread that is acquiring the read lock to run in parallel with the other</span>
<span id="cb21-908"><a href="#cb21-908" aria-hidden="true" tabindex="-1"></a>threads. As a result, the read lock just</span>
<span id="cb21-909"><a href="#cb21-909" aria-hidden="true" tabindex="-1"></a>allows for this thread to run together with the other threads.</span>
<span id="cb21-910"><a href="#cb21-910" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-911"><a href="#cb21-911" aria-hidden="true" tabindex="-1"></a>Thus, by using read locks (shared locks) in conjunction with write locks (exclusive locks), we can control which regions or sections</span>
<span id="cb21-912"><a href="#cb21-912" aria-hidden="true" tabindex="-1"></a>of our multithreaded code is safe to have parallelism, and which sections are not safe to have parallelism.</span>
<span id="cb21-913"><a href="#cb21-913" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-914"><a href="#cb21-914" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-915"><a href="#cb21-915" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-916"><a href="#cb21-916" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-917"><a href="#cb21-917" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-918"><a href="#cb21-918" aria-hidden="true" tabindex="-1"></a><span class="fu">### Using read/write locks in Zig</span></span>
<span id="cb21-919"><a href="#cb21-919" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-920"><a href="#cb21-920" aria-hidden="true" tabindex="-1"></a>The Zig Standard Library supports read/write locks through the <span class="in">`std.Thread.RwLock`</span> module.</span>
<span id="cb21-921"><a href="#cb21-921" aria-hidden="true" tabindex="-1"></a>If you want a particular thread to acquire a shared lock (i.e., a read lock), you should</span>
<span id="cb21-922"><a href="#cb21-922" aria-hidden="true" tabindex="-1"></a>call the <span class="in">`lockShared()`</span> method from the <span class="in">`RwLock`</span> object. But, if you want this thread</span>
<span id="cb21-923"><a href="#cb21-923" aria-hidden="true" tabindex="-1"></a>to acquire an exclusive lock (i.e., a write lock) instead, then you should call the</span>
<span id="cb21-924"><a href="#cb21-924" aria-hidden="true" tabindex="-1"></a><span class="in">`lock()`</span> method from the <span class="in">`RwLock`</span> object.</span>
<span id="cb21-925"><a href="#cb21-925" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-926"><a href="#cb21-926" aria-hidden="true" tabindex="-1"></a>As with mutexes, we also have to unlock the shared or exclusive locks that we acquire through a read/write lock object,</span>
<span id="cb21-927"><a href="#cb21-927" aria-hidden="true" tabindex="-1"></a>once we are at the end of our "critical section". If you have acquired an exclusive lock, then, you unlock</span>
<span id="cb21-928"><a href="#cb21-928" aria-hidden="true" tabindex="-1"></a>this exclusive lock by calling the <span class="in">`unlock()`</span> method from the read/write lock object. In contrast,</span>
<span id="cb21-929"><a href="#cb21-929" aria-hidden="true" tabindex="-1"></a>if you have acquired a shared lock instead, then, call <span class="in">`unlockShared()`</span> to unlock this shared lock.</span>
<span id="cb21-930"><a href="#cb21-930" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-931"><a href="#cb21-931" aria-hidden="true" tabindex="-1"></a>As a simple example, the snippet below creates three separate threads responsible for reading the</span>
<span id="cb21-932"><a href="#cb21-932" aria-hidden="true" tabindex="-1"></a>current value in a <span class="in">`counter`</span> object, and it also creates another thread responsible for writing</span>
<span id="cb21-933"><a href="#cb21-933" aria-hidden="true" tabindex="-1"></a>new data into the <span class="in">`counter`</span> object (incrementing it, more specifically).</span>
<span id="cb21-934"><a href="#cb21-934" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-937"><a href="#cb21-937" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb21-938"><a href="#cb21-938" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb21-939"><a href="#cb21-939" aria-hidden="true" tabindex="-1"></a><span class="in">var counter: u32 = 0;</span></span>
<span id="cb21-940"><a href="#cb21-940" aria-hidden="true" tabindex="-1"></a><span class="in">fn reader(lock: *RwLock) !void {</span></span>
<span id="cb21-941"><a href="#cb21-941" aria-hidden="true" tabindex="-1"></a><span class="in">    while (true) {</span></span>
<span id="cb21-942"><a href="#cb21-942" aria-hidden="true" tabindex="-1"></a><span class="in">        lock.lockShared();</span></span>
<span id="cb21-943"><a href="#cb21-943" aria-hidden="true" tabindex="-1"></a><span class="in">        const v: u32 = counter;</span></span>
<span id="cb21-944"><a href="#cb21-944" aria-hidden="true" tabindex="-1"></a><span class="in">        try stdout.print("{d}", .{v});</span></span>
<span id="cb21-945"><a href="#cb21-945" aria-hidden="true" tabindex="-1"></a><span class="in">        lock.unlockShared();</span></span>
<span id="cb21-946"><a href="#cb21-946" aria-hidden="true" tabindex="-1"></a><span class="in">        std.time.sleep(2 * std.time.ns_per_s);</span></span>
<span id="cb21-947"><a href="#cb21-947" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb21-948"><a href="#cb21-948" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb21-949"><a href="#cb21-949" aria-hidden="true" tabindex="-1"></a><span class="in">fn writer(lock: *RwLock) void {</span></span>
<span id="cb21-950"><a href="#cb21-950" aria-hidden="true" tabindex="-1"></a><span class="in">    while (true) {</span></span>
<span id="cb21-951"><a href="#cb21-951" aria-hidden="true" tabindex="-1"></a><span class="in">        lock.lock();</span></span>
<span id="cb21-952"><a href="#cb21-952" aria-hidden="true" tabindex="-1"></a><span class="in">        counter += 1;</span></span>
<span id="cb21-953"><a href="#cb21-953" aria-hidden="true" tabindex="-1"></a><span class="in">        lock.unlock();</span></span>
<span id="cb21-954"><a href="#cb21-954" aria-hidden="true" tabindex="-1"></a><span class="in">        std.time.sleep(2 * std.time.ns_per_s);</span></span>
<span id="cb21-955"><a href="#cb21-955" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb21-956"><a href="#cb21-956" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb21-957"><a href="#cb21-957" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-958"><a href="#cb21-958" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb21-959"><a href="#cb21-959" aria-hidden="true" tabindex="-1"></a><span class="in">    var lock: RwLock = .{};</span></span>
<span id="cb21-960"><a href="#cb21-960" aria-hidden="true" tabindex="-1"></a><span class="in">    const thr1 = try Thread.spawn(.{}, reader, .{&amp;lock});</span></span>
<span id="cb21-961"><a href="#cb21-961" aria-hidden="true" tabindex="-1"></a><span class="in">    const thr2 = try Thread.spawn(.{}, reader, .{&amp;lock});</span></span>
<span id="cb21-962"><a href="#cb21-962" aria-hidden="true" tabindex="-1"></a><span class="in">    const thr3 = try Thread.spawn(.{}, reader, .{&amp;lock});</span></span>
<span id="cb21-963"><a href="#cb21-963" aria-hidden="true" tabindex="-1"></a><span class="in">    const wthread = try Thread.spawn(.{}, writer, .{&amp;lock});</span></span>
<span id="cb21-964"><a href="#cb21-964" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-965"><a href="#cb21-965" aria-hidden="true" tabindex="-1"></a><span class="in">    thr1.join();</span></span>
<span id="cb21-966"><a href="#cb21-966" aria-hidden="true" tabindex="-1"></a><span class="in">    thr2.join();</span></span>
<span id="cb21-967"><a href="#cb21-967" aria-hidden="true" tabindex="-1"></a><span class="in">    thr3.join();</span></span>
<span id="cb21-968"><a href="#cb21-968" aria-hidden="true" tabindex="-1"></a><span class="in">    wthread.join();</span></span>
<span id="cb21-969"><a href="#cb21-969" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb21-970"><a href="#cb21-970" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-971"><a href="#cb21-971" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-972"><a href="#cb21-972" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-973"><a href="#cb21-973" aria-hidden="true" tabindex="-1"></a><span class="fu">## Yielding a thread</span></span>
<span id="cb21-974"><a href="#cb21-974" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-975"><a href="#cb21-975" aria-hidden="true" tabindex="-1"></a>The <span class="in">`Thread`</span> struct supports yielding through the <span class="in">`yield()`</span> method.</span>
<span id="cb21-976"><a href="#cb21-976" aria-hidden="true" tabindex="-1"></a>Yielding a thread means that the execution of the thread is temporarily stopped,</span>
<span id="cb21-977"><a href="#cb21-977" aria-hidden="true" tabindex="-1"></a>and it moves to the end of the priority queue managed by the scheduler of</span>
<span id="cb21-978"><a href="#cb21-978" aria-hidden="true" tabindex="-1"></a>your operating system.</span>
<span id="cb21-979"><a href="#cb21-979" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-980"><a href="#cb21-980" aria-hidden="true" tabindex="-1"></a>That is, when you yield a thread, you are essentially saying the following to your OS:</span>
<span id="cb21-981"><a href="#cb21-981" aria-hidden="true" tabindex="-1"></a>"Hey! Could you please stop executing this thread for now, and comeback to continue it later?".</span>
<span id="cb21-982"><a href="#cb21-982" aria-hidden="true" tabindex="-1"></a>You could also interpret this yield operation as: "Could you please deprioritize this thread,</span>
<span id="cb21-983"><a href="#cb21-983" aria-hidden="true" tabindex="-1"></a>to focus on doing other things instead?".</span>
<span id="cb21-984"><a href="#cb21-984" aria-hidden="true" tabindex="-1"></a>So this yield operation is also a way for you</span>
<span id="cb21-985"><a href="#cb21-985" aria-hidden="true" tabindex="-1"></a>to stop a particular thread, so that you can work and prioritize other threads instead.</span>
<span id="cb21-986"><a href="#cb21-986" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-987"><a href="#cb21-987" aria-hidden="true" tabindex="-1"></a>It's important to say that, yielding a thread is a "not so common" thread operation these days.</span>
<span id="cb21-988"><a href="#cb21-988" aria-hidden="true" tabindex="-1"></a>In other words, not many programmers use yielding in production, simply because it's hard to use</span>
<span id="cb21-989"><a href="#cb21-989" aria-hidden="true" tabindex="-1"></a>this operation and make it work properly, and also, there</span>
<span id="cb21-990"><a href="#cb21-990" aria-hidden="true" tabindex="-1"></a>are better alternatives. Most programmers prefer to use <span class="in">`join()`</span> instead.</span>
<span id="cb21-991"><a href="#cb21-991" aria-hidden="true" tabindex="-1"></a>In fact, most of the time, when you see someone using this "yield" operation in some code example,</span>
<span id="cb21-992"><a href="#cb21-992" aria-hidden="true" tabindex="-1"></a>they are usually doing so to help debug race conditions in their applications.</span>
<span id="cb21-993"><a href="#cb21-993" aria-hidden="true" tabindex="-1"></a>That is, this "yield" operation is mostly used as a debug tool nowadays.</span>
<span id="cb21-994"><a href="#cb21-994" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-995"><a href="#cb21-995" aria-hidden="true" tabindex="-1"></a>Anyway, if you want to yield a thread, just call the <span class="in">`yield()`</span> method from it, like this:</span>
<span id="cb21-996"><a href="#cb21-996" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-999"><a href="#cb21-999" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb21-1000"><a href="#cb21-1000" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb21-1001"><a href="#cb21-1001" aria-hidden="true" tabindex="-1"></a><span class="in">thread.yield();</span></span>
<span id="cb21-1002"><a href="#cb21-1002" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-1003"><a href="#cb21-1003" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1004"><a href="#cb21-1004" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1005"><a href="#cb21-1005" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1006"><a href="#cb21-1006" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1007"><a href="#cb21-1007" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1008"><a href="#cb21-1008" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1009"><a href="#cb21-1009" aria-hidden="true" tabindex="-1"></a><span class="fu">## Common problems in threads</span></span>
<span id="cb21-1010"><a href="#cb21-1010" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1011"><a href="#cb21-1011" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1012"><a href="#cb21-1012" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1013"><a href="#cb21-1013" aria-hidden="true" tabindex="-1"></a><span class="fu">### Deadlocks</span></span>
<span id="cb21-1014"><a href="#cb21-1014" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1015"><a href="#cb21-1015" aria-hidden="true" tabindex="-1"></a>A deadlock occurs when two or more threads are blocked forever,</span>
<span id="cb21-1016"><a href="#cb21-1016" aria-hidden="true" tabindex="-1"></a>waiting for each other to release a resource. This usually happens when multiple locks are involved,</span>
<span id="cb21-1017"><a href="#cb21-1017" aria-hidden="true" tabindex="-1"></a>and the order of acquiring them is not well managed.</span>
<span id="cb21-1018"><a href="#cb21-1018" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1019"><a href="#cb21-1019" aria-hidden="true" tabindex="-1"></a>The code example below demonstrates a deadlock situation. We have two different threads that execute</span>
<span id="cb21-1020"><a href="#cb21-1020" aria-hidden="true" tabindex="-1"></a>two different functions (<span class="in">`work1()`</span> and <span class="in">`work2()`</span>) in this example. And we also have two separate</span>
<span id="cb21-1021"><a href="#cb21-1021" aria-hidden="true" tabindex="-1"></a>mutexes. If you compile and run this code example, you will notice that the program just runs indefinitely,</span>
<span id="cb21-1022"><a href="#cb21-1022" aria-hidden="true" tabindex="-1"></a>without ending.</span>
<span id="cb21-1023"><a href="#cb21-1023" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1024"><a href="#cb21-1024" aria-hidden="true" tabindex="-1"></a>When we look into the first thread, which executes the <span class="in">`work1()`</span> function, we can</span>
<span id="cb21-1025"><a href="#cb21-1025" aria-hidden="true" tabindex="-1"></a>notice that this function acquires the <span class="in">`mut1`</span> lock first. Because this is the first operation</span>
<span id="cb21-1026"><a href="#cb21-1026" aria-hidden="true" tabindex="-1"></a>that is executed inside this thread, which is the first thread created in the program.</span>
<span id="cb21-1027"><a href="#cb21-1027" aria-hidden="true" tabindex="-1"></a>After that, the function sleeps for 1 second, to</span>
<span id="cb21-1028"><a href="#cb21-1028" aria-hidden="true" tabindex="-1"></a>simulate some type of work, and then, the function tries to acquire the <span class="in">`mut2`</span> lock.</span>
<span id="cb21-1029"><a href="#cb21-1029" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1030"><a href="#cb21-1030" aria-hidden="true" tabindex="-1"></a>On the other hand, when we look into the second thread, which executes the <span class="in">`work2()`</span> function,</span>
<span id="cb21-1031"><a href="#cb21-1031" aria-hidden="true" tabindex="-1"></a>we can see that this function acquires the <span class="in">`mut2`</span> lock first. Because when this thread gets created and it tries</span>
<span id="cb21-1032"><a href="#cb21-1032" aria-hidden="true" tabindex="-1"></a>to acquire this <span class="in">`mut2`</span> lock, the first thread is still sleeping on that "sleep 1 second" line.</span>
<span id="cb21-1033"><a href="#cb21-1033" aria-hidden="true" tabindex="-1"></a>After acquiring <span class="in">`mut2`</span>, the <span class="in">`work2()`</span> function also sleeps for 1 second, to</span>
<span id="cb21-1034"><a href="#cb21-1034" aria-hidden="true" tabindex="-1"></a>simulate some type of work, and then the function tries to acquire the <span class="in">`mut1`</span> lock.</span>
<span id="cb21-1035"><a href="#cb21-1035" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1036"><a href="#cb21-1036" aria-hidden="true" tabindex="-1"></a>This creates a deadlock situation, because after the "sleep for 1 second" line in both threads,</span>
<span id="cb21-1037"><a href="#cb21-1037" aria-hidden="true" tabindex="-1"></a>thread 1 is trying to acquire the <span class="in">`mut2`</span> lock, but this lock is currently being used by thread 2.</span>
<span id="cb21-1038"><a href="#cb21-1038" aria-hidden="true" tabindex="-1"></a>However, at this moment, thread 2 is also trying to acquire the <span class="in">`mut1`</span> lock, which is currently</span>
<span id="cb21-1039"><a href="#cb21-1039" aria-hidden="true" tabindex="-1"></a>being used by thread 1. Therefore, both threads end up waiting for ever. Waiting for their peer to</span>
<span id="cb21-1040"><a href="#cb21-1040" aria-hidden="true" tabindex="-1"></a>free the lock that they want to acquire.</span>
<span id="cb21-1041"><a href="#cb21-1041" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1042"><a href="#cb21-1042" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1045"><a href="#cb21-1045" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb21-1046"><a href="#cb21-1046" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb21-1047"><a href="#cb21-1047" aria-hidden="true" tabindex="-1"></a><span class="in">var mut1: Mutex = .{}; var mut2: Mutex = .{};</span></span>
<span id="cb21-1048"><a href="#cb21-1048" aria-hidden="true" tabindex="-1"></a><span class="in">fn work1() !void {</span></span>
<span id="cb21-1049"><a href="#cb21-1049" aria-hidden="true" tabindex="-1"></a><span class="in">    mut1.lock();</span></span>
<span id="cb21-1050"><a href="#cb21-1050" aria-hidden="true" tabindex="-1"></a><span class="in">    std.time.sleep(1 * std.time.ns_per_s);</span></span>
<span id="cb21-1051"><a href="#cb21-1051" aria-hidden="true" tabindex="-1"></a><span class="in">    mut2.lock();</span></span>
<span id="cb21-1052"><a href="#cb21-1052" aria-hidden="true" tabindex="-1"></a><span class="in">    _ = try stdout.write("Doing some work 1\n");</span></span>
<span id="cb21-1053"><a href="#cb21-1053" aria-hidden="true" tabindex="-1"></a><span class="in">    mut2.unlock(); mut1.unlock();</span></span>
<span id="cb21-1054"><a href="#cb21-1054" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb21-1055"><a href="#cb21-1055" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1056"><a href="#cb21-1056" aria-hidden="true" tabindex="-1"></a><span class="in">fn work2() !void {</span></span>
<span id="cb21-1057"><a href="#cb21-1057" aria-hidden="true" tabindex="-1"></a><span class="in">    mut2.lock();</span></span>
<span id="cb21-1058"><a href="#cb21-1058" aria-hidden="true" tabindex="-1"></a><span class="in">    std.time.sleep(1 * std.time.ns_per_s);</span></span>
<span id="cb21-1059"><a href="#cb21-1059" aria-hidden="true" tabindex="-1"></a><span class="in">    mut1.lock();</span></span>
<span id="cb21-1060"><a href="#cb21-1060" aria-hidden="true" tabindex="-1"></a><span class="in">    _ = try stdout.write("Doing some work 1\n");</span></span>
<span id="cb21-1061"><a href="#cb21-1061" aria-hidden="true" tabindex="-1"></a><span class="in">    mut1.unlock(); mut2.unlock();</span></span>
<span id="cb21-1062"><a href="#cb21-1062" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb21-1063"><a href="#cb21-1063" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1064"><a href="#cb21-1064" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb21-1065"><a href="#cb21-1065" aria-hidden="true" tabindex="-1"></a><span class="in">    const thr1 = try Thread.spawn(.{}, work1, .{});</span></span>
<span id="cb21-1066"><a href="#cb21-1066" aria-hidden="true" tabindex="-1"></a><span class="in">    const thr2 = try Thread.spawn(.{}, work2, .{});</span></span>
<span id="cb21-1067"><a href="#cb21-1067" aria-hidden="true" tabindex="-1"></a><span class="in">    thr1.join();</span></span>
<span id="cb21-1068"><a href="#cb21-1068" aria-hidden="true" tabindex="-1"></a><span class="in">    thr2.join();</span></span>
<span id="cb21-1069"><a href="#cb21-1069" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb21-1070"><a href="#cb21-1070" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-1071"><a href="#cb21-1071" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1072"><a href="#cb21-1072" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1073"><a href="#cb21-1073" aria-hidden="true" tabindex="-1"></a><span class="fu">### Not calling `join()` or `detach()` {#sec-not-call-join-detach}</span></span>
<span id="cb21-1074"><a href="#cb21-1074" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1075"><a href="#cb21-1075" aria-hidden="true" tabindex="-1"></a>When you do not call either <span class="in">`join()`</span> or <span class="in">`detach()`</span> over a thread, then this thread becomes a "zombie thread",</span>
<span id="cb21-1076"><a href="#cb21-1076" aria-hidden="true" tabindex="-1"></a>because it does not have a clear "return point".</span>
<span id="cb21-1077"><a href="#cb21-1077" aria-hidden="true" tabindex="-1"></a>You could also interpret this as: "nobody is properly responsible for managing the thread".</span>
<span id="cb21-1078"><a href="#cb21-1078" aria-hidden="true" tabindex="-1"></a>When we don't establish if a thread is either *joinable* or *detached*,</span>
<span id="cb21-1079"><a href="#cb21-1079" aria-hidden="true" tabindex="-1"></a>nobody becomes responsible for dealing with the return value of this thread, and also,</span>
<span id="cb21-1080"><a href="#cb21-1080" aria-hidden="true" tabindex="-1"></a>nobody becomes responsible for clearing (or freeing) the resources associated with this thread.</span>
<span id="cb21-1081"><a href="#cb21-1081" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1082"><a href="#cb21-1082" aria-hidden="true" tabindex="-1"></a>You don't want to be in this situation, so remember to always use <span class="in">`join()`</span> or <span class="in">`detach()`</span></span>
<span id="cb21-1083"><a href="#cb21-1083" aria-hidden="true" tabindex="-1"></a>on the threads that you create. When you don't use one of these methods, we lose</span>
<span id="cb21-1084"><a href="#cb21-1084" aria-hidden="true" tabindex="-1"></a>control over the thread, and its resources are never freed</span>
<span id="cb21-1085"><a href="#cb21-1085" aria-hidden="true" tabindex="-1"></a>(i.e., you have leaked resources in the system).</span>
<span id="cb21-1086"><a href="#cb21-1086" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1087"><a href="#cb21-1087" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1088"><a href="#cb21-1088" aria-hidden="true" tabindex="-1"></a><span class="fu">### Cancelling or killing a particular thread</span></span>
<span id="cb21-1089"><a href="#cb21-1089" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1090"><a href="#cb21-1090" aria-hidden="true" tabindex="-1"></a>When we think about the <span class="in">`pthreads`</span> C library, there is a possible way to asynchronously kill or cancel</span>
<span id="cb21-1091"><a href="#cb21-1091" aria-hidden="true" tabindex="-1"></a>a thread, which is by sending a <span class="in">`SIGTERM`</span> signal to the thread through the <span class="in">`pthread_kill()`</span> function.</span>
<span id="cb21-1092"><a href="#cb21-1092" aria-hidden="true" tabindex="-1"></a>But canceling a thread like this is bad. It's dangerously bad. As a consequence, the Zig implementation</span>
<span id="cb21-1093"><a href="#cb21-1093" aria-hidden="true" tabindex="-1"></a>of threads does not have a similar function, or, a similar way to asynchronously cancel or kill</span>
<span id="cb21-1094"><a href="#cb21-1094" aria-hidden="true" tabindex="-1"></a>a thread.</span>
<span id="cb21-1095"><a href="#cb21-1095" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1096"><a href="#cb21-1096" aria-hidden="true" tabindex="-1"></a>Therefore, if you want to cancel a thread in the middle of its execution in Zig,</span>
<span id="cb21-1097"><a href="#cb21-1097" aria-hidden="true" tabindex="-1"></a>then one good strategy that you can take is to use control flow in conjunction with <span class="in">`join()`</span>.</span>
<span id="cb21-1098"><a href="#cb21-1098" aria-hidden="true" tabindex="-1"></a>More specifically, you can design your thread around a while loop that is constantly</span>
<span id="cb21-1099"><a href="#cb21-1099" aria-hidden="true" tabindex="-1"></a>checking if the thread should continue running.</span>
<span id="cb21-1100"><a href="#cb21-1100" aria-hidden="true" tabindex="-1"></a>If it's time to cancel the thread, we could make the while loop break, and join the thread with the main thread</span>
<span id="cb21-1101"><a href="#cb21-1101" aria-hidden="true" tabindex="-1"></a>by calling <span class="in">`join()`</span>.</span>
<span id="cb21-1102"><a href="#cb21-1102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1103"><a href="#cb21-1103" aria-hidden="true" tabindex="-1"></a>The code example below demonstrates to some extent this strategy.</span>
<span id="cb21-1104"><a href="#cb21-1104" aria-hidden="true" tabindex="-1"></a>Here, we are using control flow to break the while loop, and exit the thread earlier than</span>
<span id="cb21-1105"><a href="#cb21-1105" aria-hidden="true" tabindex="-1"></a>what we have initially planned to. This example also demonstrates how can we use</span>
<span id="cb21-1106"><a href="#cb21-1106" aria-hidden="true" tabindex="-1"></a>atomic objects in Zig with the <span class="in">`Value()`</span> generic function that we have mentioned in @sec-atomic-operation.</span>
<span id="cb21-1107"><a href="#cb21-1107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1108"><a href="#cb21-1108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1111"><a href="#cb21-1111" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb21-1112"><a href="#cb21-1112" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: false</span></span>
<span id="cb21-1113"><a href="#cb21-1113" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb21-1114"><a href="#cb21-1114" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb21-1115"><a href="#cb21-1115" aria-hidden="true" tabindex="-1"></a><span class="in">const Thread = std.Thread;</span></span>
<span id="cb21-1116"><a href="#cb21-1116" aria-hidden="true" tabindex="-1"></a><span class="in">const stdout = std.io.getStdOut().writer();</span></span>
<span id="cb21-1117"><a href="#cb21-1117" aria-hidden="true" tabindex="-1"></a><span class="in">var running = std.atomic.Value(bool).init(true);</span></span>
<span id="cb21-1118"><a href="#cb21-1118" aria-hidden="true" tabindex="-1"></a><span class="in">var counter: u64 = 0;</span></span>
<span id="cb21-1119"><a href="#cb21-1119" aria-hidden="true" tabindex="-1"></a><span class="in">fn do_more_work() void {</span></span>
<span id="cb21-1120"><a href="#cb21-1120" aria-hidden="true" tabindex="-1"></a><span class="in">    std.time.sleep(2 * std.time.ns_per_s);</span></span>
<span id="cb21-1121"><a href="#cb21-1121" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb21-1122"><a href="#cb21-1122" aria-hidden="true" tabindex="-1"></a><span class="in">fn work() !void {</span></span>
<span id="cb21-1123"><a href="#cb21-1123" aria-hidden="true" tabindex="-1"></a><span class="in">    while (running.load(.monotonic)) {</span></span>
<span id="cb21-1124"><a href="#cb21-1124" aria-hidden="true" tabindex="-1"></a><span class="in">        for (0..10000) |_| { counter += 1; }</span></span>
<span id="cb21-1125"><a href="#cb21-1125" aria-hidden="true" tabindex="-1"></a><span class="in">        if (counter &lt; 15000) {</span></span>
<span id="cb21-1126"><a href="#cb21-1126" aria-hidden="true" tabindex="-1"></a><span class="in">            _ = try stdout.write(</span></span>
<span id="cb21-1127"><a href="#cb21-1127" aria-hidden="true" tabindex="-1"></a><span class="in">                "Time to cancel the thread.\n"</span></span>
<span id="cb21-1128"><a href="#cb21-1128" aria-hidden="true" tabindex="-1"></a><span class="in">            );</span></span>
<span id="cb21-1129"><a href="#cb21-1129" aria-hidden="true" tabindex="-1"></a><span class="in">            running.store(false, .monotonic);</span></span>
<span id="cb21-1130"><a href="#cb21-1130" aria-hidden="true" tabindex="-1"></a><span class="in">        } else {</span></span>
<span id="cb21-1131"><a href="#cb21-1131" aria-hidden="true" tabindex="-1"></a><span class="in">            _ = try stdout.write("Time to do more work.\n");</span></span>
<span id="cb21-1132"><a href="#cb21-1132" aria-hidden="true" tabindex="-1"></a><span class="in">            do_more_work();</span></span>
<span id="cb21-1133"><a href="#cb21-1133" aria-hidden="true" tabindex="-1"></a><span class="in">            running.store(false, .monotonic);</span></span>
<span id="cb21-1134"><a href="#cb21-1134" aria-hidden="true" tabindex="-1"></a><span class="in">        }</span></span>
<span id="cb21-1135"><a href="#cb21-1135" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb21-1136"><a href="#cb21-1136" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb21-1137"><a href="#cb21-1137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1138"><a href="#cb21-1138" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb21-1139"><a href="#cb21-1139" aria-hidden="true" tabindex="-1"></a><span class="in">    const thread = try Thread.spawn(.{}, work, .{});</span></span>
<span id="cb21-1140"><a href="#cb21-1140" aria-hidden="true" tabindex="-1"></a><span class="in">    thread.join();</span></span>
<span id="cb21-1141"><a href="#cb21-1141" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb21-1142"><a href="#cb21-1142" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>