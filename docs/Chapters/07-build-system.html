<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Introduction to Zig - 9&nbsp; Build System</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../Chapters/09-error-handling.html" rel="next">
<link href="../Chapters/03-unittests.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-6CHJXK4CEV"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-6CHJXK4CEV', { 'anonymize_ip': true});
</script>


</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../Chapters/07-build-system.html"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Build System</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Introduction to Zig</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Welcome</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/01-zig-weird.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introducing Zig</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/03-structs.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Control flow, structs, modules and types</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/01-memory.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Memory and Allocators</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/01-base64.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Project 1 - Building a base64 encoder/decoder</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/02-debugging.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Debugging Zig applications</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/05-pointers.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Pointers and Optionals</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/04-http-server.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Project 2 - Building a HTTP Server from scratch</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/03-unittests.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Unit tests</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/07-build-system.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Build System</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/09-error-handling.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Error handling and unions</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/09-data-structures.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Data Structures</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/10-stack-project.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Project 3 - Building a stack data structure</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/12-file-op.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Filesystem and Input/Output (IO)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/14-zig-c-interop.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Zig interoperability with C</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/13-image-filter.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Project 4 - Developing an image filter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/14-threads.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Introducing threads and parallelism in Zig</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/15-vectors.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Introducing Vectors and SIMD</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#how-source-code-is-built" id="toc-how-source-code-is-built" class="nav-link active" data-scroll-target="#how-source-code-is-built"><span class="header-section-number">9.1</span> How source code is built?</a></li>
  <li><a href="#sec-build-fun" id="toc-sec-build-fun" class="nav-link" data-scroll-target="#sec-build-fun"><span class="header-section-number">9.2</span> The <code>build()</code> function</a></li>
  <li><a href="#sec-targets" id="toc-sec-targets" class="nav-link" data-scroll-target="#sec-targets"><span class="header-section-number">9.3</span> Target objects</a></li>
  <li><a href="#setting-the-build-mode" id="toc-setting-the-build-mode" class="nav-link" data-scroll-target="#setting-the-build-mode"><span class="header-section-number">9.4</span> Setting the build mode</a></li>
  <li><a href="#setting-the-version-of-your-build" id="toc-setting-the-version-of-your-build" class="nav-link" data-scroll-target="#setting-the-version-of-your-build"><span class="header-section-number">9.5</span> Setting the version of your build</a></li>
  <li><a href="#sec-detect-os" id="toc-sec-detect-os" class="nav-link" data-scroll-target="#sec-detect-os"><span class="header-section-number">9.6</span> Detecting the OS in your build script</a></li>
  <li><a href="#adding-a-run-step-to-your-build-process" id="toc-adding-a-run-step-to-your-build-process" class="nav-link" data-scroll-target="#adding-a-run-step-to-your-build-process"><span class="header-section-number">9.7</span> Adding a run step to your build process</a></li>
  <li><a href="#build-unit-tests-in-your-project" id="toc-build-unit-tests-in-your-project" class="nav-link" data-scroll-target="#build-unit-tests-in-your-project"><span class="header-section-number">9.8</span> Build unit tests in your project</a></li>
  <li><a href="#tailoring-your-build-process-with-user-provided-options" id="toc-tailoring-your-build-process-with-user-provided-options" class="nav-link" data-scroll-target="#tailoring-your-build-process-with-user-provided-options"><span class="header-section-number">9.9</span> Tailoring your build process with user-provided options</a></li>
  <li><a href="#linking-to-external-libraries" id="toc-linking-to-external-libraries" class="nav-link" data-scroll-target="#linking-to-external-libraries"><span class="header-section-number">9.10</span> Linking to external libraries</a></li>
  <li><a href="#sec-building-c-code" id="toc-sec-building-c-code" class="nav-link" data-scroll-target="#sec-building-c-code"><span class="header-section-number">9.11</span> Building C code</a>
  <ul class="collapse">
  <li><a href="#creating-c-compiler-flags" id="toc-creating-c-compiler-flags" class="nav-link" data-scroll-target="#creating-c-compiler-flags"><span class="header-section-number">9.11.1</span> Creating C compiler flags</a></li>
  <li><a href="#listing-your-c-files" id="toc-listing-your-c-files" class="nav-link" data-scroll-target="#listing-your-c-files"><span class="header-section-number">9.11.2</span> Listing your C files</a></li>
  <li><a href="#defining-c-macros" id="toc-defining-c-macros" class="nav-link" data-scroll-target="#defining-c-macros"><span class="header-section-number">9.11.3</span> Defining C Macros</a></li>
  <li><a href="#sec-library-paths" id="toc-sec-library-paths" class="nav-link" data-scroll-target="#sec-library-paths"><span class="header-section-number">9.11.4</span> Adding library paths</a></li>
  <li><a href="#sec-include-paths" id="toc-sec-include-paths" class="nav-link" data-scroll-target="#sec-include-paths"><span class="header-section-number">9.11.5</span> Adding include paths</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title"><span id="sec-build-system" class="quarto-section-identifier"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Build System</span></span></h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">View Source</a></li></ul></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>In this chapter, we are going to talk about the build system, and how an entire project is built in Zig. One key advantage of Zig is that it includes a build system embedded in the language itself. This is great, because then you do not have to depend on an external system, separated from the compiler, to build your code.</p>
<p>You can find a good description of Zig’s build system in the <a href="https://ziglang.org/learn/build-system/#user-provided-options">article entitled “Build System”</a><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> from the official Zig’s website. We also have the excellent <a href="https://zig.news/xq/zig-build-explained-part-1-59lf">series of posts written by Felix</a><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>. Hence, this chapter represents an extra resource for you to consult and rely on.</p>
<p>Building code is one of the things that Zig is best at. One thing that is particularly difficult in C/C++ and even in Rust, is to cross-compile source code to multiple targets (e.g.&nbsp;multiple computer architectures and operating systems), and the <code>zig</code> compiler is known for being one of the best existing pieces of software for this particular task.</p>
<section id="how-source-code-is-built" class="level2" data-number="9.1">
<h2 data-number="9.1" class="anchored" data-anchor-id="how-source-code-is-built"><span class="header-section-number">9.1</span> How source code is built?</h2>
<p>We already have talked about the challenges of building source code in low-level languages in <a href="01-zig-weird.html#sec-project-files" class="quarto-xref"><span>Section 1.2.1</span></a>. As we described at that section, programmers invented Build Systems to surpass these challenges on the process of building source code in low-level languages.</p>
<p>Low-level languages uses a compiler to compile (or to build) your source code into binary instructions. In C and C++, we normally use compilers like <code>gcc</code>, <code>g++</code> or <code>clang</code> to compile our C and C++ source code into these instructions. Every language have its own compiler, and this is no different in Zig.</p>
<p>In Zig, we have the <code>zig</code> compiler to compile our Zig source code into binary instructions that can be executed by our computer. In Zig, the compilation (or the build) process involves the following components:</p>
<ul>
<li>The Zig modules that contains your source code;</li>
<li>Library files (either a dynamic library or a static library);</li>
<li>Compiler flags that tailors the build process to your needs.</li>
</ul>
<p>These are the things that you need to connect together in order to build your source code in Zig. In C and C++, you would have an extra component, which are the header files of the libraries that you are using. But header files do not exist in Zig, so, you only need to care about them if you are linking your Zig source code with a C library. If that is not your case, you can forget about it.</p>
<p>Your build process is usually organized in a build script. In Zig, we normally write this build script into a Zig module in the root directory of our project, named as <code>build.zig</code>. You write this build script, then, when you run it, your project gets built into binary files that you can use and distribute to your users.</p>
<p>This build script is normally organized around <em>target objects</em>. A target is simply something to be built, or, in other words, it’s something that you want the <code>zig</code> compiler to build for you. This concept of “targets” is present in most Build Systems, especially in CMake<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>.</p>
<p>There are four types of target objects that you can build in Zig, which are:</p>
<ul>
<li>An executable (e.g.&nbsp;a <code>.exe</code> file on Windows).</li>
<li>A shared library (e.g.&nbsp;a <code>.so</code> file in Linux or a <code>.dll</code> file on Windows).</li>
<li>A static library (e.g.&nbsp;a <code>.a</code> file in Linux or a <code>.lib</code> file on Windows).</li>
<li>An executable file that executes only unit tests (or, a “unit tests executable”).</li>
</ul>
<p>We are going to talk more about these target objects in <a href="#sec-targets" class="quarto-xref"><span>Section 9.3</span></a>.</p>
</section>
<section id="sec-build-fun" class="level2" data-number="9.2">
<h2 data-number="9.2" class="anchored" data-anchor-id="sec-build-fun"><span class="header-section-number">9.2</span> The <code>build()</code> function</h2>
<p>A build script in Zig always contains a public (and top-level) <code>build()</code> function declared. It’s like the <code>main()</code> function in the main Zig module of your project, that we discussed in <a href="01-zig-weird.html#sec-main-file" class="quarto-xref"><span>Section 1.2.3</span></a>. But instead of creating the entrypoint to your code, this <code>build()</code> function is the entrypoint to the build process.</p>
<p>This <code>build()</code> function should accept a pointer to a <code>Build</code> object as input, and it should use this “build object” to perform the necessary steps to build your project. The return type of this function is always <code>void</code>, and this <code>Build</code> struct comes directly from the Zig Standard Library (<code>std.Build</code>). So, you can access this struct by just importing the Zig Standard Library into your <code>build.zig</code> module.</p>
<p>Just as a very simple example, here you can see the source code necessary to build an executable file from the <code>hello.zig</code> Zig module.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> build(b: *std.Build) <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> exe = b.addExecutable(.<span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        .name = <span class="st">"hello"</span>,</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        .root_source_file = b.path(<span class="st">"hello.zig"</span>),</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        .target = b.host,</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>);</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    b.installArtifact(exe);</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>You can define and use other functions and objects in this build script. You can also import other Zig modules as you would normally do in any other module of your project. The only real requirement for this build script, is to have a public and top-level <code>build()</code> function defined, that accepts a pointer to a <code>Build</code> struct as input.</p>
</section>
<section id="sec-targets" class="level2" data-number="9.3">
<h2 data-number="9.3" class="anchored" data-anchor-id="sec-targets"><span class="header-section-number">9.3</span> Target objects</h2>
<p>As we described over the previous sections, a build script is composed around target objects. Each target object is normally a binary file (or an output) that you want to get from the build process. You can list multiple target objects in your build script, so that the build process generates multiple binary files for you at once.</p>
<p>For example, maybe you are a developer working in a cross-platform application, and, because this application is cross-platform, you probably need to release binary files of your software for each OS supported by your application to your end users. Thus, you can define a different target object in your build script for each OS (Windows, Linux, etc.) where you want to publish your software. This will make the <code>zig</code> compiler to build your project to multiple target OS’s at once. The Zig Build System official documentation have a <a href="https://ziglang.org/learn/build-system/#handy-examples">great code example that demonstrates this strategy</a><a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>.</p>
<p>A target object is created by the following methods of the <code>Build</code> struct that we introduced in <a href="#sec-build-fun" class="quarto-xref"><span>Section 9.2</span></a>:</p>
<ul>
<li><code>addExecutable()</code> creates an executable file;</li>
<li><code>addSharedLibrary()</code> creates a shared library file;</li>
<li><code>addStaticLibrary()</code> creates a static library file;</li>
<li><code>addTest()</code> creates an executable file that executes unit tests.</li>
</ul>
<p>These functions are methods from the <code>Build</code> struct that you receive as input of the <code>build()</code> function. All of them, create as output a <code>Compile</code> object, which represents a target object to be compiled by the <code>zig</code> compiler. All of these functions accept a similar struct literal as input. This struct literal defines three essential specs about this target object that you are building: <code>name</code>, <code>target</code> and <code>root_source_file</code>.</p>
<p>We have already seen these three options being used on the previous example, where we used the <code>addExecutable()</code> method to create an executable target object. This example is reproduced below. Notice the use of the <code>path()</code> method from the <code>Build</code> struct, to define a path in the <code>root_source_file</code> option.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> exe = b.addExecutable(.<span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    .name = <span class="st">"hello"</span>,</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    .root_source_file = b.path(<span class="st">"hello.zig"</span>),</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    .target = b.host,</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The <code>name</code> option specify the name that you want to give to the binary file defined by this target object. So, in this example, we are building an executable file named <code>hello</code>. It’s common to set this <code>name</code> option to the name of your project.</p>
<p>Furthermore, the <code>target</code> option specify the target computer architecture (or the target operating system) of this binary file. For example, if you want this target object to run on a Windows machine that uses a <code>x86_64</code> architecture, you can set this <code>target</code> option to <code>x86_64-windows-gnu</code> for example. This will make the <code>zig</code> compiler to compile the project to run on a <code>x86_64</code> Windows machine. You can see the full list of architectures and OS’s that the <code>zig</code> compiler supports by running the <code>zig targets</code> command in the terminal.</p>
<p>Now, if you are building the project to run on the current machine that you are using to run this build script, you can set this <code>target</code> option to the <code>host</code> method of the <code>Build</code> object, like we did in the example above. This <code>host</code> method identifies the current machine where you are currently running the <code>zig</code> compiler.</p>
<p>At last, the <code>root_source_file</code> option specifies the root Zig module of your project. That is the Zig module that contains the entrypoint to your application (i.e., the <code>main()</code> function), or, the main API of your library. This also means that, all the Zig modules that compose your project are automatically discovered from the import statements you have inside this “root source file”. The <code>zig</code> compiler can detect when a Zig module depends on the other through the import statements, and, as a result, it can discover the entire map of Zig modules used in your project.</p>
<p>This is handy, and it’s different from what happens in other build systems. In CMake for example, you have to explicitly list the paths to all source files that you want to include in your build process. This is probably a symptom of the “lack of conditional compilation” in the C and C++ compilers. Since they lack this feature, you have to explicitly choose which source files should be sent to the C/C++ compiler, because not every C/C++ code is portable or supported in every operating system, and, therefore, would cause a compilation error in the C/C++ compiler.</p>
<p>Now, one important detail about the build process is that, you have to <strong>explicitly install the target objects that you create in your build script</strong>, by using the <code>installArtifact()</code> method of the <code>Build</code> struct.</p>
<p>Everytime you invoke the build process of your project, by calling the <code>build</code> command of the <code>zig</code> compiler, a new directory named <code>zig-out</code> is created in the root directory of your project. This new directory contains the outputs of the build process, that is, the binary files built from your source code.</p>
<p>What the <code>installArtifact()</code> method do is to install (or copy) the built target objects that you defined to this <code>zig-out</code> directory. This means that, if you do not install the target objects you define in your build script, these target objects are essentially discarded at the end of the build process.</p>
<p>For example, you might be building a project that uses a third party library that is built together with the project. So, when you build your project, you would need first, to build the third party library, and then, you link it with the source code of your project. So, in this case, we have two binary files that are generated in the build process (the executable file of your project, and the third party library). But only one is of interest, which is the executable file of our project. We can discard the binary file of the third party library, by simply not installing it into this <code>zig-out</code> directory.</p>
<p>This <code>installArtifact()</code> method is pretty straightforward. Just remember to apply it to every target object that you want to save into the <code>zig-out</code> directory, like in the example below:</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> exe = b.addExecutable(.<span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    .name = <span class="st">"hello"</span>,</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    .root_source_file = b.path(<span class="st">"hello.zig"</span>),</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    .target = b.host,</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>);</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>b.installArtifact(exe);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="setting-the-build-mode" class="level2" data-number="9.4">
<h2 data-number="9.4" class="anchored" data-anchor-id="setting-the-build-mode"><span class="header-section-number">9.4</span> Setting the build mode</h2>
<p>We have talked about the three essential options that are set when you create a new target object. But there is also a fourth option that you can use to set the build mode of this target object, which is the <code>optimize</code> option. This option is called this way, because the build modes in Zig are treated more of an “optimization vs safety” problem. So optimization plays an important role here. Don’t worry, I’m going back to this question very soon.</p>
<p>In Zig, we have four build modes (which are listed below). Each one of these build modes offer different advantages and characteristics. As we described in <a href="02-debugging.html#sec-compile-debug-mode" class="quarto-xref"><span>Section 5.2.1</span></a>, the <code>zig</code> compiler uses the <code>Debug</code> build mode by default, when you don’t explicitly choose a build mode.</p>
<ul>
<li><code>Debug</code>, mode that produces and includes debugging information in the output of the build process (i.e., the binary file defined by the target object);</li>
<li><code>ReleaseSmall</code>, mode that tries to produce a binary file that is small in size;</li>
<li><code>ReleaseFast</code>, mode that tries to optimize your code, in order to produce a binary file that is as fast as possible;</li>
<li><code>ReleaseSafe</code>, mode that tries to make your code as safe as possible, by including safeguards when possible.</li>
</ul>
<p>So, when you build your project, you can set the build mode of your target object to <code>ReleaseFast</code> for example, which will tell the <code>zig</code> compiler to apply important optimizations in your code. This creates a binary file that simply runs faster on most contexts, because it contains a more optimized version of your code. However, as a result, we often lose some safety features in our code. Because some safety checks are removed from the final binary file, which makes your code run faster, but in a less safe manner.</p>
<p>This choice depends on your current priorities. If you are building a cryptography or banking system, you might prefer to prioritize safety in your code, so, you would choose the <code>ReleaseSafe</code> build mode, which is a little slower to run, but much more secure, because it includes all possible runtime safety checks in the binary file built in the build process. In the other hand, if you are writing a game for example, you might prefer to prioritize performance over safety, by using the <code>ReleaseFast</code> build mode, so that your users can experience faster frame rates in your game.</p>
<p>In the example below, we are creating the same target object that we have used on previous examples. But this time, we are specifying the build mode of this target object to the <code>ReleaseSafe</code> mode.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> exe = b.addExecutable(.<span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    .name = <span class="st">"hello"</span>,</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    .root_source_file = b.path(<span class="st">"hello.zig"</span>),</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    .target = b.host,</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    .optimize = .ReleaseSafe</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>);</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>b.installArtifact(exe);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="setting-the-version-of-your-build" class="level2" data-number="9.5">
<h2 data-number="9.5" class="anchored" data-anchor-id="setting-the-version-of-your-build"><span class="header-section-number">9.5</span> Setting the version of your build</h2>
<p>Everytime you build a target object in your build script, you can assign a version number to this specific build, following a semantic versioning framework. You can find more about semantic versioning by visiting the <a href="https://semver.org/">Semantic Versioning website</a><a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>. Anyway, in Zig, you can specify the version of your build, by providing a <code>SemanticVersion</code> struct to the <code>version</code> option, like in the example below:</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> exe = b.addExecutable(.<span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    .name = <span class="st">"hello"</span>,</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    .root_source_file = b.path(<span class="st">"hello.zig"</span>),</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    .target = b.host,</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    .version = .<span class="op">{</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        .major = <span class="dv">2</span>, .minor = <span class="dv">9</span>, .patch = <span class="dv">7</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>);</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>b.installArtifact(exe);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="sec-detect-os" class="level2" data-number="9.6">
<h2 data-number="9.6" class="anchored" data-anchor-id="sec-detect-os"><span class="header-section-number">9.6</span> Detecting the OS in your build script</h2>
<p>It’s very common in Build Systems to use different options, or, to include different modules, or, to link against different libraries depending on the Operational System (OS) that you are targeting in the build process.</p>
<p>In Zig, you can detect the target OS of the build process, by looking at the <code>os.tag</code> inside the <code>builtin</code> module from the Zig library. In the example below, we are using an if statement to run some arbitrary code when the target of the build process is a Windows system.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> builtin = <span class="bu">@import</span>(<span class="st">"builtin"</span>);</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> (builtin.target.os.tag == .windows) <span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Code that runs only when the target of</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// the compilation process is Windows.</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="adding-a-run-step-to-your-build-process" class="level2" data-number="9.7">
<h2 data-number="9.7" class="anchored" data-anchor-id="adding-a-run-step-to-your-build-process"><span class="header-section-number">9.7</span> Adding a run step to your build process</h2>
<p>One thing that is neat in Rust is that you can compile and run your source code with one single command (<code>cargo run</code>) from the Rust compiler. We saw in <a href="01-zig-weird.html#sec-compile-run-code" class="quarto-xref"><span>Section 1.2.5</span></a> how can we perform a similar job in Zig, by building and running our Zig source code through the <code>run</code> command from the <code>zig</code> compiler.</p>
<p>But how can we, at the same time, build and run the binary file specified by a target object in our build script? The answer is by including a “run artifact” in our build script. A run artifact is created through the <code>addRunArtifact()</code> method from the <code>Build</code> struct. We simply provide as input to this function the target object that describes the binary file that we want to execute. As a result, this function creates a run artifact that is capable of executing this binary file.</p>
<p>In the example below, we are defining an executable binary file named <code>hello</code>, and we use this <code>addRunArtifact()</code> method to create a run artifact that will execute this <code>hello</code> executable file.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> exe = b.addExecutable(.<span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    .name = <span class="st">"hello"</span>,</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    .root_source_file = b.path(<span class="st">"src/hello.zig"</span>),</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    .target = b.host</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>);</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>b.installArtifact(exe);</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> run_arti = b.addRunArtifact(exe);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Now that we have created this run artifact, we need to include it in the build process. We do that by declaring a new step in our build script to call this artifact, through the <code>step()</code> method of the <code>Build</code> struct.</p>
<p>We can give any name we want to this step, but, for our context here, I’m going to name this step as “run”. Also, I give it a brief description to this step (“Run the project”).</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> run_step = b.step(</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">"run"</span>, <span class="st">"Run the project"</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Now that we have declared this “run step” we need to tell Zig that this “run step” depends on the run artifact. In other words, a run artifact always depends on a “step” to effectively be executed. By creating this dependency we finally stablish the necessary commands to build and run the executable file from the build script.</p>
<p>We can establish a dependency between the run step and the run artifact by using the <code>dependsOn()</code> method from the run step. So, we first create the run step, and then, we link it with the run artifact, by using this <code>dependsOn()</code> method from the run step.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>run_step.dependOn(&amp;run_arti.step);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The entire source code of this specific build script that we wrote, piece by piece, in this section, is available in the <code>build_and_run.zig</code> module. You can see this module by <a href="https://github.com/pedropark99/zig-book/blob/main/ZigExamples/build_system/build_and_run.zig">visiting the official repository of this book</a> <a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>.</p>
<p>When you declare a new step in your build script, this step becomes available through the <code>build</code> command in the <code>zig</code> compiler. You can actually see this step by running <code>zig build --help</code> in the terminal, like in the example below, where we can see that this new “run” step that we declared in the build script appeared in the output.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ex">zig</span> build <span class="at">--help</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>Steps:
  ...
  run   Run the project
  ...</code></pre>
<p>Now, everything that we need to is to call this “run” step that we created in our build script. We call it by using the name that we gave to this step after the <code>build</code> command from the <code>zig</code> compiler. This will cause the compiler to build our executable file and execute it at the same time.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ex">zig</span> build run</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="build-unit-tests-in-your-project" class="level2" data-number="9.8">
<h2 data-number="9.8" class="anchored" data-anchor-id="build-unit-tests-in-your-project"><span class="header-section-number">9.8</span> Build unit tests in your project</h2>
<p>We have talked at length about writing unit tests in Zig in <a href="03-unittests.html" class="quarto-xref"><span>Chapter 8</span></a>, and we also have talked about how to execute these unit tests through the <code>test</code> command of the <code>zig</code> compiler. However, as we did with the <code>run</code> command on the previous section, we also might want to include some commands in our build script to also build and execute the unit tests in our project.</p>
<p>So, once again, we are going to discuss how a specific built-in command from the <code>zig</code> compiler, (in this case, the <code>test</code> command) can be used in a build script in Zig. Here is where a “test target object” comes into play. As was described in <a href="#sec-targets" class="quarto-xref"><span>Section 9.3</span></a>, we can create a test target object by using the <code>addTest()</code> method of the <code>Build</code> struct. The first thing that we need to do is to declare a test target object in our build script.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> test_exe = b.addTest(.<span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    .name = <span class="st">"unit_tests"</span>,</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    .root_source_file = b.path(<span class="st">"src/main.zig"</span>),</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    .target = b.host,</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>);</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>b.installArtifact(test_exe);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>A test target object essentially selects all <code>test</code> blocks in all Zig modules across your project, and builds only the source code present inside these <code>test</code> blocks in your project. As a result, this target object creates an executable file that contains only the source code present in all of these <code>test</code> blocks (i.e., the unit tests) in your project.</p>
<p>Perfect! Now that we have declared this test target object, an executable file named <code>unit_tests</code> is built by the <code>zig</code> compiler when we trigger the build script with the <code>build</code> command. After the build process is finished, we can simply execute this <code>unit_tests</code> executable in the terminal.</p>
<p>However, if you remember the previous section, we already learned how can we create a run step in our build script, to execute an executable file built by the build script.</p>
<p>So, we could simply add a run step in our build script to run these unit tests from a single command in the <code>zig</code> compiler, to make our lifes easier. In the example below, we demonstrate the commands to register a new build step called “tests” in our build script to run these unit tests.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> run_arti = b.addRunArtifact(test_exe);</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> run_step = b.step(<span class="st">"tests"</span>, <span class="st">"Run unit tests"</span>);</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>run_step.dependOn(&amp;run_arti.step);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Now that we registered this new build step, we can trigger it by calling the command below in the terminal. You can also checkout the complete source code for this specific build script at the <code>build_tests.zig</code> module at the <a href="https://github.com/pedropark99/zig-book/blob/main/ZigExamples/build_system/build_tests.zig">official repository of this book</a> <a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ex">zig</span> build tests</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="tailoring-your-build-process-with-user-provided-options" class="level2" data-number="9.9">
<h2 data-number="9.9" class="anchored" data-anchor-id="tailoring-your-build-process-with-user-provided-options"><span class="header-section-number">9.9</span> Tailoring your build process with user-provided options</h2>
<p>Sometimes, you want to make a build script that is customizable by the user of your project. You can do that by creating user-provided options in your build script. We create an user-provided option by using the <code>option()</code> method from the <code>Build</code> struct.</p>
<p>With this method, we create a “build option” which can be passed to the <code>build.zig</code> script at the command line. The user have the power of setting this option at the <code>build</code> command from the <code>zig</code> compiler. In other words, each build option that we create becomes a new command line argument that is accessible through the <code>build</code> command of the compiler.</p>
<p>These “user-provided options” are set by using the prefix <code>-D</code> in the command line. For example, if we declare an option named <code>use_zlib</code>, that receives a boolean value which indicates if we should link our source code to <code>zlib</code> or not, we can set the value of this option in the command line with <code>-Duse_zlib</code>. The code example below demonstrates this idea:</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> build(b: *std.Build) <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> use_zlib = b.option(</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span>,</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">"use_zlib"</span>,</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Should link to zlib?"</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    ) <span class="kw">orelse</span> <span class="cn">false</span>;</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> exe = b.addExecutable(.<span class="op">{</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>        .name = <span class="st">"hello"</span>,</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>        .root_source_file = b.path(<span class="st">"example.zig"</span>),</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>        .target = b.host,</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>);</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> (use_zlib) <span class="op">{</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>        exe.linkSystemLibrary(<span class="st">"zlib"</span>);</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    b.installArtifact(exe);</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="sourceCode" id="cb17"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ex">zig</span> build <span class="at">-Duse_zlib</span><span class="op">=</span>false</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="linking-to-external-libraries" class="level2" data-number="9.10">
<h2 data-number="9.10" class="anchored" data-anchor-id="linking-to-external-libraries"><span class="header-section-number">9.10</span> Linking to external libraries</h2>
<p>One essential part of every build process is the linking stage. This stage is responsible for combining the multiple object files that represent your code, into a single executable file. It also links this executable file to external libraries, if you use any in your code.</p>
<p>In Zig, we have two notions of a “library”, which are: 1) a system’s library; 2) a local library. A system’s library is just a library that is already installed in your system. While a local library is a library that belongs to the current project; a library that is present in your project directory, and that you are building together with your project source code.</p>
<p>The basic difference between the two, is that a system’s library is already built and installed in your system, supposedly, and all you need to do is to link your source code to this library to start using it. We do that by using the <code>linkSystemLibrary()</code> method from a <code>Compile</code> object. This method accepts the name of the library in a string as input. Remember from <a href="#sec-targets" class="quarto-xref"><span>Section 9.3</span></a> that a <code>Compile</code> object is a target object that you declare in your build script.</p>
<p>When you link a particular target object with a system’s library, the <code>zig</code> compiler will use <code>pkg-config</code> to find where are the binary files and also the header files of this library in your system. When it finds these files, the linker present in the <code>zig</code> compiler will link your object files with the files of this library to produce a single binary file for you.</p>
<p>In the example below, we are creating an executable file named <code>image_filter</code>, and, we are linking this executable file to the C Standard Library with the method <code>linkLibC()</code>, but we also are linking this executable file to the C library <code>libpng</code> that is currently installed in my system.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> build(b: *std.Build) <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> exe = b.addExecutable(.<span class="op">{</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>        .name = <span class="st">"image_filter"</span>,</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>        .root_source_file = b.path(<span class="st">"src/main.zig"</span>),</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>        .target = target,</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>        .optimize = optimize,</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>);</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    exe.linkLibC();</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    exe.linkSystemLibrary(<span class="st">"png"</span>);</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    b.installArtifact(exe);</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>If you are linking with a C library in your project, is generally a good idea to also link your code with the C Standard Library. Because is very likely that this C library uses some functionality of the C Standard Library at some point. The same goes to C++ libraries. So, if you are linking with C++ libraries, is a good idea to link your project with the C++ Standard Library by using the <code>linkLibCpp()</code> method.</p>
<p>On the order side, when you want to link with a local library, you should use the <code>linkLibrary()</code> method of a <code>Compile</code> object. This method expects to receive another <code>Compile</code> object as input. That is, another target object defined in your build script, using either the <code>addStaticLibrary()</code> or <code>addSharedLibrary()</code> methods which defines a library to be built.</p>
<p>As we discussed earlier, a local library is a library that is local to your project, and that is being built together with your project. So, you need to create a target object in your build script to build this local library. Then, you link the target objects of interest in your project, with this target object that identifies this local library.</p>
<p>Take a look at this example extracted from the build script of the <a href="https://github.com/mitchellh/libxev/tree/main"><code>libxev</code> library</a><a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>. You can see in this snippet that we are declaring a shared library file, from the <code>c_api.zig</code> module. Then, later in the build script, we declare an executable file named <code>"dynamic-binding-test"</code>, which links to this shared library that we defined earlier in the script.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> optimize = b.standardOptimizeOption(.<span class="op">{}</span>);</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> target = b.standardTargetOptions(.<span class="op">{}</span>);</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> dynamic_lib = b.addSharedLibrary(.<span class="op">{</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    .name = dynamic_lib_name,</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    .root_source_file = b.path(<span class="st">"src/c_api.zig"</span>),</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    .target = target,</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    .optimize = optimize,</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>);</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>b.installArtifact(dynamic_lib);</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="co">// ... more lines in the script</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> dynamic_binding_test = b.addExecutable(.<span class="op">{</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>    .name = <span class="st">"dynamic-binding-test"</span>,</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>    .target = target,</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>    .optimize = optimize,</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>);</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>dynamic_binding_test.linkLibrary(dynamic_lib);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="sec-building-c-code" class="level2" data-number="9.11">
<h2 data-number="9.11" class="anchored" data-anchor-id="sec-building-c-code"><span class="header-section-number">9.11</span> Building C code</h2>
<p>The <code>zig</code> compiler comes with a C compiler embedded in it. In other words, you can use the <code>zig</code> compiler to build C projects. This C compiler is available through the <code>cc</code> command of the <code>zig</code> compiler.</p>
<p>As an example, let’s use the famous <a href="https://freetype.org/">FreeType library</a><a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>. FreeType is one of the most widely used pieces of software in the world. It’s a C library designed to produce high-quality fonts. But it’s also heavily used in the industry to natively render text and fonts in the screen of your computer.</p>
<p>In this section, we are going to write a build script, piece by piece, that is capable of building the FreeType project from source. You can find the source code of this build script on the <a href="https://github.com/pedropark99/freetype-zig/tree/main"><code>freetype-zig</code> repository</a><a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a> available at GitHub.</p>
<p>After you download the source code of FreeType from the official website<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>, you can start writing the <code>build.zig</code> module. We begin by defining the target object that defines the binary file that we want to compile.</p>
<p>As an example, I will build the project as a static library file using the <code>addStaticLibrary()</code> method to create the target object. Also, since FreeType is a C library, I will also link the library against <code>libc</code> through the <code>linkLibC()</code> method, to guarantee that any use of the C Standard Library is covered in the compilation process.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> target = b.standardTargetOptions(.<span class="op">{}</span>);</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> opti = b.standardOptimizeOption(.<span class="op">{}</span>);</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> lib = b.addStaticLibrary(.<span class="op">{</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    .name = <span class="st">"freetype"</span>,</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    .optimize = opti,</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    .target = target,</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>);</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>lib.linkLibC();</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<section id="creating-c-compiler-flags" class="level3" data-number="9.11.1">
<h3 data-number="9.11.1" class="anchored" data-anchor-id="creating-c-compiler-flags"><span class="header-section-number">9.11.1</span> Creating C compiler flags</h3>
<p>Compiler flags are also known as “compiler options” by many programmers, or also, as “command options” in the GCC official documentation. It’s fair to also call them as the “command-line arguments” of the C compiler. In general, we use compiler flags to turn on (or turn off) some features from the compiler, or to tweak the compilation process to fit the needs of our project.</p>
<p>In build scripts written in Zig, we normally list the C compiler flags to be used in the compilation process in a simple array, like in the example below.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> c_flags = [_][]<span class="kw">const</span> <span class="dt">u8</span><span class="op">{</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">"-Wall"</span>,</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"-Wextra"</span>,</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">"-Werror"</span>,</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>In theory, there is nothing stopping you from using this array to add “include paths” (with the <code>-I</code> flag) or “library paths” (with the <code>-L</code> flag) to the compilation process. But there are formal ways in Zig to add these types of paths in the compilation process. Both are discussed in <a href="#sec-include-paths" class="quarto-xref"><span>Section 9.11.5</span></a> and <a href="#sec-library-paths" class="quarto-xref"><span>Section 9.11.4</span></a>.</p>
<p>Anyway, in Zig, we add C flags to the build process together with the C files that we want to compile, by using the <code>addCSourceFile()</code> and <code>addCSourceFiles()</code> methods. In the example above, we have just declared the C flags that we want to use. But we haven’t added them to the build process yet. To do that, we also need to list the C files to be compiled.</p>
</section>
<section id="listing-your-c-files" class="level3" data-number="9.11.2">
<h3 data-number="9.11.2" class="anchored" data-anchor-id="listing-your-c-files"><span class="header-section-number">9.11.2</span> Listing your C files</h3>
<p>The C files that contains “cross-platform” source code are listed in the <code>c_source_files</code> object below. These are the C files that are included by default in every platform supported by the FreeType library. Now, since the amount of C files in the FreeType library is big, I have omitted the rest of the files in the code example below, for brevity purposes.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> c_source_files = [_][]<span class="kw">const</span> <span class="dt">u8</span><span class="op">{</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">"src/autofit/autofit.c"</span>,</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"src/base/ftbase.c"</span>,</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ... and many other C files.</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Now, in addition to “cross-platform” source code, we also have some C files in the FreeType project that are platform-specific, meaning that, they contain source code that can only be compiled in specific platforms, and, as a result, they are only included in the build process on these specific target platforms. The objects that list these C files are exposed in the code example below.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> windows_c_source_files = [_][]<span class="kw">const</span> <span class="dt">u8</span><span class="op">{</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">"builds/windows/ftdebug.c"</span>,</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"builds/windows/ftsystem.c"</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> linux_c_source_files = [_][]<span class="kw">const</span> <span class="dt">u8</span><span class="op">{</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">"src/base/ftsystem.c"</span>,</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">"src/base/ftdebug.c"</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Now that we declared both the files that we want to include and the C compiler flags to be used, we can add them to the target object that describes the FreeType library, by using the <code>addCSourceFile()</code> and <code>addCSourceFiles()</code> methods.</p>
<p>Both of these functions are methods from a <code>Compile</code> object (i.e., a target object). The <code>addCSourceFile()</code> method is capable of adding a single C file to the target object, while the <code>addCSourceFiles()</code> method is used to add multiple C files in a single command. You might prefer to use <code>addCSourceFile()</code> when you need to use different compiler flags on specific C files in your project. But, if you can use the same compiler flags across all C files, then, you will probably find <code>addCSourceFiles()</code> a better choice.</p>
<p>Notice that we are using the <code>addCSourceFiles()</code> method in the example below, to add both the C files and the C compiler flags. Also notice that we are using the <code>os.tag</code> that we learned about in <a href="#sec-detect-os" class="quarto-xref"><span>Section 9.6</span></a>, to add the platform-specific C files.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> builtin = <span class="bu">@import</span>(<span class="st">"builtin"</span>);</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>lib.addCSourceFiles(</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    &amp;c_source_files, &amp;c_flags</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>);</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="kw">switch</span> (builtin.target.os.tag) <span class="op">{</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    .windows =&gt; <span class="op">{</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>        lib.addCSourceFiles(</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>            &amp;windows_c_source_files,</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>            &amp;c_flags</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>        );</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>,</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>    .linux =&gt; <span class="op">{</span></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>        lib.addCSourceFiles(</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>            &amp;linux_c_source_files,</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>            &amp;c_flags</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>        );</span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>,</span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> =&gt; <span class="op">{}</span>,</span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="defining-c-macros" class="level3" data-number="9.11.3">
<h3 data-number="9.11.3" class="anchored" data-anchor-id="defining-c-macros"><span class="header-section-number">9.11.3</span> Defining C Macros</h3>
<p>C Macros are an essential part of the C programming language, and they are commonly defined through the <code>-D</code> flag from a C compiler. In Zig, you can define a C Macro to be used in your build process by using the <code>defineCMacro()</code> method from the target object that defines the binary file that you are building.</p>
<p>In the example below, we are using the <code>lib</code> object that we have defined in the previous sections to define some C Macros used by the FreeType project in the compilation process. These C Macros specify if FreeType should (or should not) include functionalities from different external libraries.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>lib.defineCMacro(<span class="st">"FT_DISABLE_ZLIB"</span>, <span class="st">"TRUE"</span>);</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>lib.defineCMacro(<span class="st">"FT_DISABLE_PNG"</span>, <span class="st">"TRUE"</span>);</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>lib.defineCMacro(<span class="st">"FT_DISABLE_HARFBUZZ"</span>, <span class="st">"TRUE"</span>);</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>lib.defineCMacro(<span class="st">"FT_DISABLE_BZIP2"</span>, <span class="st">"TRUE"</span>);</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>lib.defineCMacro(<span class="st">"FT_DISABLE_BROTLI"</span>, <span class="st">"TRUE"</span>);</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>lib.defineCMacro(<span class="st">"FT2_BUILD_LIBRARY"</span>, <span class="st">"TRUE"</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="sec-library-paths" class="level3" data-number="9.11.4">
<h3 data-number="9.11.4" class="anchored" data-anchor-id="sec-library-paths"><span class="header-section-number">9.11.4</span> Adding library paths</h3>
<p>Library paths are paths in your computer where the C compiler will look (or search) for library files to link against your source code. In other words, when you use a library in your C source code, and you ask the C compiler to link your source code against this library, the C compiler will search for the binary files of this library across the paths listed in this “library paths” set.</p>
<p>These paths are platform specific, and, by default, the C compiler starts by looking at a pre-defined set of places in your computer. But you can add more paths (or more places) to this list. For example, you may have a library installed in a non-conventional place of your computer, and you can make the C compiler “see” this “non-conventional place” by adding this path to this list of pre-defined paths.</p>
<p>In Zig, you can add more paths to this set by using the <code>addLibraryPath()</code> method from your target object. First, you defined a <code>LazyPath</code> object, containing the path you want to add, then, you provide this object as input to the <code>addLibraryPath()</code> method, like in the example below:</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> lib_path: std.Build.LazyPath = .<span class="op">{</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    .cwd_relative = <span class="st">"/usr/local/lib/"</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>lib.addLibraryPath(lib_path);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="sec-include-paths" class="level3" data-number="9.11.5">
<h3 data-number="9.11.5" class="anchored" data-anchor-id="sec-include-paths"><span class="header-section-number">9.11.5</span> Adding include paths</h3>
<p>The preprocessor search path is a popular concept from the C community, but it’s also known by many C programmers as “include paths”, because the paths in this “search path” relate to the <code>#include</code> statements found in the C files.</p>
<p>Include paths are similar to library paths. They are a set of pre-defined places in your computer where the C compiler will look for files during the compilation process. But instead of looking for library files, the include paths are places where the compiler looks for header files included in your C source code. This is why many C programmers prefer to call these paths as the “preprocessor search path”. Because header files are processed during the preprocessor stage of the compilation process.</p>
<p>So, every header file that you include in your C source code, through a <code>#include</code> statements needs to be found somewhere, and the C compiler will search for this header file across the paths listed in this “include paths” set. Include paths are added to the compilation process through the <code>-I</code> flag.</p>
<p>In Zig, you can add new paths to this pre-defined set of paths, by using the <code>addIncludePath()</code> method from your target object. This method also accepts a <code>LazyPath</code> object as input.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> inc_path: std.Build.LazyPath = .<span class="op">{</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    .path = <span class="st">"./include"</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>lib.addIncludePath(inc_path);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>


<!-- -->

</section>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p><a href="https://ziglang.org/learn/build-system/#user-provided-options" class="uri">https://ziglang.org/learn/build-system/#user-provided-options</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><a href="https://zig.news/xq/zig-build-explained-part-1-59lf" class="uri">https://zig.news/xq/zig-build-explained-part-1-59lf</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p><a href="https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html" class="uri">https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p><a href="https://ziglang.org/learn/build-system/#handy-examples" class="uri">https://ziglang.org/learn/build-system/#handy-examples</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p><a href="https://semver.org/" class="uri">https://semver.org/</a><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p><a href="https://github.com/pedropark99/zig-book/blob/main/ZigExamples/build_system/build_and_run.zig" class="uri">https://github.com/pedropark99/zig-book/blob/main/ZigExamples/build_system/build_and_run.zig</a><a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p><a href="https://github.com/pedropark99/zig-book/blob/main/ZigExamples/build_system/build_tests.zig" class="uri">https://github.com/pedropark99/zig-book/blob/main/ZigExamples/build_system/build_tests.zig</a><a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p><a href="https://github.com/mitchellh/libxev/tree/main" class="uri">https://github.com/mitchellh/libxev/tree/main</a><a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p><a href="https://freetype.org/" class="uri">https://freetype.org/</a><a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p><a href="https://github.com/pedropark99/freetype-zig/tree/main" class="uri">https://github.com/pedropark99/freetype-zig/tree/main</a><a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11"><p><a href="https://freetype.org/" class="uri">https://freetype.org/</a><a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../Chapters/03-unittests.html" class="pagination-link" aria-label="Unit tests">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Unit tests</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../Chapters/09-error-handling.html" class="pagination-link" aria-label="Error handling and unions">
        <span class="nav-page-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Error handling and unions</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb28" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="an">engine:</span><span class="co"> knitr</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="an">knitr:</span><span class="co"> true</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="an">syntax-definition:</span><span class="co"> "../Assets/zig.xml"</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a><span class="co">#| include: false</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a><span class="fu">source</span>(<span class="st">"../zig_engine.R"</span>)</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>knitr<span class="sc">::</span>opts_chunk<span class="sc">$</span><span class="fu">set</span>(</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>    <span class="at">auto_main =</span> <span class="cn">FALSE</span>,</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>    <span class="at">build_type =</span> <span class="st">"lib"</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a><span class="fu"># Build System {#sec-build-system}</span></span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a>In this chapter, we are going to talk about the build system, and how an entire project</span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a>is built in Zig.</span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a>One key advantage of Zig is that it includes a build system embedded in the language itself.</span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a>This is great, because then you do not have to depend on an external system, separated</span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a>from the compiler, to build your code.</span>
<span id="cb28-29"><a href="#cb28-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-30"><a href="#cb28-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-31"><a href="#cb28-31" aria-hidden="true" tabindex="-1"></a>You can find a good description of Zig's build system</span>
<span id="cb28-32"><a href="#cb28-32" aria-hidden="true" tabindex="-1"></a>in the <span class="co">[</span><span class="ot">article entitled "Build System"</span><span class="co">](https://ziglang.org/learn/build-system/#user-provided-options)</span><span class="ot">[^zig-art1]</span></span>
<span id="cb28-33"><a href="#cb28-33" aria-hidden="true" tabindex="-1"></a>from the official Zig's website.</span>
<span id="cb28-34"><a href="#cb28-34" aria-hidden="true" tabindex="-1"></a>We also have the excellent <span class="co">[</span><span class="ot">series of posts written by Felix</span><span class="co">](https://zig.news/xq/zig-build-explained-part-1-59lf)</span><span class="ot">[^felix]</span>.</span>
<span id="cb28-35"><a href="#cb28-35" aria-hidden="true" tabindex="-1"></a>Hence, this chapter represents an extra resource for you to consult and rely on.</span>
<span id="cb28-36"><a href="#cb28-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-37"><a href="#cb28-37" aria-hidden="true" tabindex="-1"></a><span class="ot">[^felix]: &lt;https://zig.news/xq/zig-build-explained-part-1-59lf&gt;</span></span>
<span id="cb28-38"><a href="#cb28-38" aria-hidden="true" tabindex="-1"></a><span class="ot">[^zig-art1]: &lt;https://ziglang.org/learn/build-system/#user-provided-options&gt;</span></span>
<span id="cb28-39"><a href="#cb28-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-40"><a href="#cb28-40" aria-hidden="true" tabindex="-1"></a>Building code is one of the things that Zig is best at. One thing that is particularly</span>
<span id="cb28-41"><a href="#cb28-41" aria-hidden="true" tabindex="-1"></a>difficult in C/C++ and even in Rust, is to cross-compile source code to multiple targets</span>
<span id="cb28-42"><a href="#cb28-42" aria-hidden="true" tabindex="-1"></a>(e.g. multiple computer architectures and operating systems),</span>
<span id="cb28-43"><a href="#cb28-43" aria-hidden="true" tabindex="-1"></a>and the <span class="in">`zig`</span> compiler is known for being one of the best existing pieces of software</span>
<span id="cb28-44"><a href="#cb28-44" aria-hidden="true" tabindex="-1"></a>for this particular task.</span>
<span id="cb28-45"><a href="#cb28-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-46"><a href="#cb28-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-47"><a href="#cb28-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-48"><a href="#cb28-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-49"><a href="#cb28-49" aria-hidden="true" tabindex="-1"></a><span class="fu">## How source code is built?</span></span>
<span id="cb28-50"><a href="#cb28-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-51"><a href="#cb28-51" aria-hidden="true" tabindex="-1"></a>We already have talked about the challenges of building source code in low-level languages</span>
<span id="cb28-52"><a href="#cb28-52" aria-hidden="true" tabindex="-1"></a>in @sec-project-files. As we described at that section, programmers invented Build Systems</span>
<span id="cb28-53"><a href="#cb28-53" aria-hidden="true" tabindex="-1"></a>to surpass these challenges on the process of building source code in low-level languages.</span>
<span id="cb28-54"><a href="#cb28-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-55"><a href="#cb28-55" aria-hidden="true" tabindex="-1"></a>Low-level languages uses a compiler to compile (or to build) your source code into binary instructions.</span>
<span id="cb28-56"><a href="#cb28-56" aria-hidden="true" tabindex="-1"></a>In C and C++, we normally use compilers like <span class="in">`gcc`</span>, <span class="in">`g++`</span> or <span class="in">`clang`</span> to compile</span>
<span id="cb28-57"><a href="#cb28-57" aria-hidden="true" tabindex="-1"></a>our C and C++ source code into these instructions.</span>
<span id="cb28-58"><a href="#cb28-58" aria-hidden="true" tabindex="-1"></a>Every language have its own compiler, and this is no different in Zig.</span>
<span id="cb28-59"><a href="#cb28-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-60"><a href="#cb28-60" aria-hidden="true" tabindex="-1"></a>In Zig, we have the <span class="in">`zig`</span> compiler to compile our Zig source code into</span>
<span id="cb28-61"><a href="#cb28-61" aria-hidden="true" tabindex="-1"></a>binary instructions that can be executed by our computer.</span>
<span id="cb28-62"><a href="#cb28-62" aria-hidden="true" tabindex="-1"></a>In Zig, the compilation (or the build) process involves</span>
<span id="cb28-63"><a href="#cb28-63" aria-hidden="true" tabindex="-1"></a>the following components:</span>
<span id="cb28-64"><a href="#cb28-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-65"><a href="#cb28-65" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The Zig modules that contains your source code;</span>
<span id="cb28-66"><a href="#cb28-66" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Library files (either a dynamic library or a static library);</span>
<span id="cb28-67"><a href="#cb28-67" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Compiler flags that tailors the build process to your needs.</span>
<span id="cb28-68"><a href="#cb28-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-69"><a href="#cb28-69" aria-hidden="true" tabindex="-1"></a>These are the things that you need to connect together in order to build your</span>
<span id="cb28-70"><a href="#cb28-70" aria-hidden="true" tabindex="-1"></a>source code in Zig. In C and C++, you would have an extra component, which are the header files of</span>
<span id="cb28-71"><a href="#cb28-71" aria-hidden="true" tabindex="-1"></a>the libraries that you are using. But header files do not exist in Zig, so, you only need</span>
<span id="cb28-72"><a href="#cb28-72" aria-hidden="true" tabindex="-1"></a>to care about them if you are linking your Zig source code with a C library.</span>
<span id="cb28-73"><a href="#cb28-73" aria-hidden="true" tabindex="-1"></a>If that is not your case, you can forget about it.</span>
<span id="cb28-74"><a href="#cb28-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-75"><a href="#cb28-75" aria-hidden="true" tabindex="-1"></a>Your build process is usually organized in a build script. In Zig, we normally</span>
<span id="cb28-76"><a href="#cb28-76" aria-hidden="true" tabindex="-1"></a>write this build script into a Zig module in the root directory of our project,</span>
<span id="cb28-77"><a href="#cb28-77" aria-hidden="true" tabindex="-1"></a>named as <span class="in">`build.zig`</span>. You write this build script, then, when you run it, your project</span>
<span id="cb28-78"><a href="#cb28-78" aria-hidden="true" tabindex="-1"></a>gets built into binary files that you can use and distribute to your users.</span>
<span id="cb28-79"><a href="#cb28-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-80"><a href="#cb28-80" aria-hidden="true" tabindex="-1"></a>This build script is normally organized around *target objects*. A target is simply</span>
<span id="cb28-81"><a href="#cb28-81" aria-hidden="true" tabindex="-1"></a>something to be built, or, in other words, it's something that you want the <span class="in">`zig`</span> compiler</span>
<span id="cb28-82"><a href="#cb28-82" aria-hidden="true" tabindex="-1"></a>to build for you. This concept of "targets" is present in most Build Systems,</span>
<span id="cb28-83"><a href="#cb28-83" aria-hidden="true" tabindex="-1"></a>especially in CMake<span class="ot">[^cmake]</span>.</span>
<span id="cb28-84"><a href="#cb28-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-85"><a href="#cb28-85" aria-hidden="true" tabindex="-1"></a><span class="ot">[^cmake]: &lt;https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html&gt;</span></span>
<span id="cb28-86"><a href="#cb28-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-87"><a href="#cb28-87" aria-hidden="true" tabindex="-1"></a>There are four types of target objects that you can build in Zig, which are:</span>
<span id="cb28-88"><a href="#cb28-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-89"><a href="#cb28-89" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>An executable (e.g. a <span class="in">`.exe`</span> file on Windows).</span>
<span id="cb28-90"><a href="#cb28-90" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>A shared library (e.g. a <span class="in">`.so`</span> file in Linux or a <span class="in">`.dll`</span> file on Windows).</span>
<span id="cb28-91"><a href="#cb28-91" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>A static library (e.g. a <span class="in">`.a`</span> file in Linux or a <span class="in">`.lib`</span> file on Windows).</span>
<span id="cb28-92"><a href="#cb28-92" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>An executable file that executes only unit tests (or, a "unit tests executable").</span>
<span id="cb28-93"><a href="#cb28-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-94"><a href="#cb28-94" aria-hidden="true" tabindex="-1"></a>We are going to talk more about these target objects in @sec-targets.</span>
<span id="cb28-95"><a href="#cb28-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-96"><a href="#cb28-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-97"><a href="#cb28-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-98"><a href="#cb28-98" aria-hidden="true" tabindex="-1"></a><span class="fu">## The `build()` function {#sec-build-fun}</span></span>
<span id="cb28-99"><a href="#cb28-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-100"><a href="#cb28-100" aria-hidden="true" tabindex="-1"></a>A build script in Zig always contains a public (and top-level) <span class="in">`build()`</span> function declared.</span>
<span id="cb28-101"><a href="#cb28-101" aria-hidden="true" tabindex="-1"></a>It's like the <span class="in">`main()`</span> function in the main Zig module of your project, that we discussed in @sec-main-file.</span>
<span id="cb28-102"><a href="#cb28-102" aria-hidden="true" tabindex="-1"></a>But instead of creating the entrypoint to your code, this <span class="in">`build()`</span> function is the entrypoint to the build process.</span>
<span id="cb28-103"><a href="#cb28-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-104"><a href="#cb28-104" aria-hidden="true" tabindex="-1"></a>This <span class="in">`build()`</span> function should accept a pointer to a <span class="in">`Build`</span> object as input, and it should use this "build object" to perform</span>
<span id="cb28-105"><a href="#cb28-105" aria-hidden="true" tabindex="-1"></a>the necessary steps to build your project. The return type of this function is always <span class="in">`void`</span>,</span>
<span id="cb28-106"><a href="#cb28-106" aria-hidden="true" tabindex="-1"></a>and this <span class="in">`Build`</span> struct comes directly from the Zig Standard Library (<span class="in">`std.Build`</span>). So, you can</span>
<span id="cb28-107"><a href="#cb28-107" aria-hidden="true" tabindex="-1"></a>access this struct by just importing the Zig Standard Library into your <span class="in">`build.zig`</span> module.</span>
<span id="cb28-108"><a href="#cb28-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-109"><a href="#cb28-109" aria-hidden="true" tabindex="-1"></a>Just as a very simple example, here you can see the source code necessary to build</span>
<span id="cb28-110"><a href="#cb28-110" aria-hidden="true" tabindex="-1"></a>an executable file from the <span class="in">`hello.zig`</span> Zig module.</span>
<span id="cb28-111"><a href="#cb28-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-114"><a href="#cb28-114" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb28-115"><a href="#cb28-115" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb28-116"><a href="#cb28-116" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb28-117"><a href="#cb28-117" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn build(b: *std.Build) void {</span></span>
<span id="cb28-118"><a href="#cb28-118" aria-hidden="true" tabindex="-1"></a><span class="in">    const exe = b.addExecutable(.{</span></span>
<span id="cb28-119"><a href="#cb28-119" aria-hidden="true" tabindex="-1"></a><span class="in">        .name = "hello",</span></span>
<span id="cb28-120"><a href="#cb28-120" aria-hidden="true" tabindex="-1"></a><span class="in">        .root_source_file = b.path("hello.zig"),</span></span>
<span id="cb28-121"><a href="#cb28-121" aria-hidden="true" tabindex="-1"></a><span class="in">        .target = b.host,</span></span>
<span id="cb28-122"><a href="#cb28-122" aria-hidden="true" tabindex="-1"></a><span class="in">    });</span></span>
<span id="cb28-123"><a href="#cb28-123" aria-hidden="true" tabindex="-1"></a><span class="in">    b.installArtifact(exe);</span></span>
<span id="cb28-124"><a href="#cb28-124" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-125"><a href="#cb28-125" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-126"><a href="#cb28-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-127"><a href="#cb28-127" aria-hidden="true" tabindex="-1"></a>You can define and use other functions and objects in this build script. You can also import</span>
<span id="cb28-128"><a href="#cb28-128" aria-hidden="true" tabindex="-1"></a>other Zig modules as you would normally do in any other module of your project.</span>
<span id="cb28-129"><a href="#cb28-129" aria-hidden="true" tabindex="-1"></a>The only real requirement for this build script, is to have a public and top-level</span>
<span id="cb28-130"><a href="#cb28-130" aria-hidden="true" tabindex="-1"></a><span class="in">`build()`</span> function defined, that accepts a pointer to a <span class="in">`Build`</span> struct as input.</span>
<span id="cb28-131"><a href="#cb28-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-132"><a href="#cb28-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-133"><a href="#cb28-133" aria-hidden="true" tabindex="-1"></a><span class="fu">## Target objects {#sec-targets}</span></span>
<span id="cb28-134"><a href="#cb28-134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-135"><a href="#cb28-135" aria-hidden="true" tabindex="-1"></a>As we described over the previous sections, a build script is composed around target objects.</span>
<span id="cb28-136"><a href="#cb28-136" aria-hidden="true" tabindex="-1"></a>Each target object is normally a binary file (or an output) that you want to get from the build process. You can list</span>
<span id="cb28-137"><a href="#cb28-137" aria-hidden="true" tabindex="-1"></a>multiple target objects in your build script, so that the build process generates multiple</span>
<span id="cb28-138"><a href="#cb28-138" aria-hidden="true" tabindex="-1"></a>binary files for you at once.</span>
<span id="cb28-139"><a href="#cb28-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-140"><a href="#cb28-140" aria-hidden="true" tabindex="-1"></a>For example, maybe you are a developer working in a cross-platform application,</span>
<span id="cb28-141"><a href="#cb28-141" aria-hidden="true" tabindex="-1"></a>and, because this application is cross-platform, you probably need to release</span>
<span id="cb28-142"><a href="#cb28-142" aria-hidden="true" tabindex="-1"></a>binary files of your software for each OS supported by your application to your end users.</span>
<span id="cb28-143"><a href="#cb28-143" aria-hidden="true" tabindex="-1"></a>Thus, you can define a different target object in your build script</span>
<span id="cb28-144"><a href="#cb28-144" aria-hidden="true" tabindex="-1"></a>for each OS (Windows, Linux, etc.) where you want to publish your software.</span>
<span id="cb28-145"><a href="#cb28-145" aria-hidden="true" tabindex="-1"></a>This will make the <span class="in">`zig`</span> compiler to build your project to multiple target OS's at once.</span>
<span id="cb28-146"><a href="#cb28-146" aria-hidden="true" tabindex="-1"></a>The Zig Build System official documentation have a <span class="co">[</span><span class="ot">great code example that demonstrates this strategy</span><span class="co">](https://ziglang.org/learn/build-system/#handy-examples)</span><span class="ot">[^zig-ex]</span>.</span>
<span id="cb28-147"><a href="#cb28-147" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-148"><a href="#cb28-148" aria-hidden="true" tabindex="-1"></a><span class="ot">[^zig-ex]: &lt;https://ziglang.org/learn/build-system/#handy-examples&gt;</span></span>
<span id="cb28-149"><a href="#cb28-149" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-150"><a href="#cb28-150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-151"><a href="#cb28-151" aria-hidden="true" tabindex="-1"></a>A target object is created by the following methods of the <span class="in">`Build`</span> struct that we introduced</span>
<span id="cb28-152"><a href="#cb28-152" aria-hidden="true" tabindex="-1"></a>in @sec-build-fun:</span>
<span id="cb28-153"><a href="#cb28-153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-154"><a href="#cb28-154" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`addExecutable()`</span> creates an executable file;</span>
<span id="cb28-155"><a href="#cb28-155" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`addSharedLibrary()`</span> creates a shared library file;</span>
<span id="cb28-156"><a href="#cb28-156" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`addStaticLibrary()`</span> creates a static library file;</span>
<span id="cb28-157"><a href="#cb28-157" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`addTest()`</span> creates an executable file that executes unit tests.</span>
<span id="cb28-158"><a href="#cb28-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-159"><a href="#cb28-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-160"><a href="#cb28-160" aria-hidden="true" tabindex="-1"></a>These functions are methods from the <span class="in">`Build`</span> struct that you receive</span>
<span id="cb28-161"><a href="#cb28-161" aria-hidden="true" tabindex="-1"></a>as input of the <span class="in">`build()`</span> function. All of them, create as output</span>
<span id="cb28-162"><a href="#cb28-162" aria-hidden="true" tabindex="-1"></a>a <span class="in">`Compile`</span> object, which represents a target object to be compiled</span>
<span id="cb28-163"><a href="#cb28-163" aria-hidden="true" tabindex="-1"></a>by the <span class="in">`zig`</span> compiler. All of these functions accept a similar struct literal as input.</span>
<span id="cb28-164"><a href="#cb28-164" aria-hidden="true" tabindex="-1"></a>This struct literal defines three essential specs about this target object that you are building:</span>
<span id="cb28-165"><a href="#cb28-165" aria-hidden="true" tabindex="-1"></a><span class="in">`name`</span>, <span class="in">`target`</span> and <span class="in">`root_source_file`</span>.</span>
<span id="cb28-166"><a href="#cb28-166" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-167"><a href="#cb28-167" aria-hidden="true" tabindex="-1"></a>We have already seen these three options being used on the previous example,</span>
<span id="cb28-168"><a href="#cb28-168" aria-hidden="true" tabindex="-1"></a>where we used the <span class="in">`addExecutable()`</span> method to create an executable target object.</span>
<span id="cb28-169"><a href="#cb28-169" aria-hidden="true" tabindex="-1"></a>This example is reproduced below. Notice the use of the <span class="in">`path()`</span> method</span>
<span id="cb28-170"><a href="#cb28-170" aria-hidden="true" tabindex="-1"></a>from the <span class="in">`Build`</span> struct, to define a path in the <span class="in">`root_source_file`</span> option.</span>
<span id="cb28-171"><a href="#cb28-171" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-174"><a href="#cb28-174" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb28-175"><a href="#cb28-175" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb28-176"><a href="#cb28-176" aria-hidden="true" tabindex="-1"></a><span class="in">const exe = b.addExecutable(.{</span></span>
<span id="cb28-177"><a href="#cb28-177" aria-hidden="true" tabindex="-1"></a><span class="in">    .name = "hello",</span></span>
<span id="cb28-178"><a href="#cb28-178" aria-hidden="true" tabindex="-1"></a><span class="in">    .root_source_file = b.path("hello.zig"),</span></span>
<span id="cb28-179"><a href="#cb28-179" aria-hidden="true" tabindex="-1"></a><span class="in">    .target = b.host,</span></span>
<span id="cb28-180"><a href="#cb28-180" aria-hidden="true" tabindex="-1"></a><span class="in">});</span></span>
<span id="cb28-181"><a href="#cb28-181" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-182"><a href="#cb28-182" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-183"><a href="#cb28-183" aria-hidden="true" tabindex="-1"></a>The <span class="in">`name`</span> option specify the name that you want to give to the binary file defined</span>
<span id="cb28-184"><a href="#cb28-184" aria-hidden="true" tabindex="-1"></a>by this target object. So, in this example, we are building an executable file named <span class="in">`hello`</span>.</span>
<span id="cb28-185"><a href="#cb28-185" aria-hidden="true" tabindex="-1"></a>It's common to set this <span class="in">`name`</span> option to the name of your project.</span>
<span id="cb28-186"><a href="#cb28-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-187"><a href="#cb28-187" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-188"><a href="#cb28-188" aria-hidden="true" tabindex="-1"></a>Furthermore, the <span class="in">`target`</span> option specify the target computer architecture (or the target operating system) of this</span>
<span id="cb28-189"><a href="#cb28-189" aria-hidden="true" tabindex="-1"></a>binary file. For example, if you want this target object to run on a Windows machine</span>
<span id="cb28-190"><a href="#cb28-190" aria-hidden="true" tabindex="-1"></a>that uses a <span class="in">`x86_64`</span> architecture, you can set this <span class="in">`target`</span> option to <span class="in">`x86_64-windows-gnu`</span> for example.</span>
<span id="cb28-191"><a href="#cb28-191" aria-hidden="true" tabindex="-1"></a>This will make the <span class="in">`zig`</span> compiler to compile the project to run on a <span class="in">`x86_64`</span> Windows machine.</span>
<span id="cb28-192"><a href="#cb28-192" aria-hidden="true" tabindex="-1"></a>You can see the full list of architectures and OS's that the <span class="in">`zig`</span> compiler supports by running</span>
<span id="cb28-193"><a href="#cb28-193" aria-hidden="true" tabindex="-1"></a>the <span class="in">`zig targets`</span> command in the terminal.</span>
<span id="cb28-194"><a href="#cb28-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-195"><a href="#cb28-195" aria-hidden="true" tabindex="-1"></a>Now, if you are building the project to run on the current machine</span>
<span id="cb28-196"><a href="#cb28-196" aria-hidden="true" tabindex="-1"></a>that you are using to run this build script, you can set this <span class="in">`target`</span></span>
<span id="cb28-197"><a href="#cb28-197" aria-hidden="true" tabindex="-1"></a>option to the <span class="in">`host`</span> method of the <span class="in">`Build`</span> object, like we did in the example above.</span>
<span id="cb28-198"><a href="#cb28-198" aria-hidden="true" tabindex="-1"></a>This <span class="in">`host`</span> method identifies the current machine where you are</span>
<span id="cb28-199"><a href="#cb28-199" aria-hidden="true" tabindex="-1"></a>currently running the <span class="in">`zig`</span> compiler.</span>
<span id="cb28-200"><a href="#cb28-200" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-201"><a href="#cb28-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-202"><a href="#cb28-202" aria-hidden="true" tabindex="-1"></a>At last, the <span class="in">`root_source_file`</span> option specifies the root Zig module of your project.</span>
<span id="cb28-203"><a href="#cb28-203" aria-hidden="true" tabindex="-1"></a>That is the Zig module that contains the entrypoint to your application (i.e., the <span class="in">`main()`</span> function), or, the main API of your library.</span>
<span id="cb28-204"><a href="#cb28-204" aria-hidden="true" tabindex="-1"></a>This also means that, all the Zig modules that compose your project are automatically discovered</span>
<span id="cb28-205"><a href="#cb28-205" aria-hidden="true" tabindex="-1"></a>from the import statements you have inside this "root source file".</span>
<span id="cb28-206"><a href="#cb28-206" aria-hidden="true" tabindex="-1"></a>The <span class="in">`zig`</span> compiler can detect when a Zig module depends on the other through the import statements,</span>
<span id="cb28-207"><a href="#cb28-207" aria-hidden="true" tabindex="-1"></a>and, as a result, it can discover the entire map of Zig modules used in your project.</span>
<span id="cb28-208"><a href="#cb28-208" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-209"><a href="#cb28-209" aria-hidden="true" tabindex="-1"></a>This is handy, and it's different from what happens in other build systems.</span>
<span id="cb28-210"><a href="#cb28-210" aria-hidden="true" tabindex="-1"></a>In CMake for example, you have to explicitly list the paths to all source files that you want to</span>
<span id="cb28-211"><a href="#cb28-211" aria-hidden="true" tabindex="-1"></a>include in your build process. This is probably a symptom of the "lack of conditional</span>
<span id="cb28-212"><a href="#cb28-212" aria-hidden="true" tabindex="-1"></a>compilation" in the C and C++ compilers. Since they lack this feature, you have</span>
<span id="cb28-213"><a href="#cb28-213" aria-hidden="true" tabindex="-1"></a>to explicitly choose which source files should be sent to the C/C++ compiler, because not</span>
<span id="cb28-214"><a href="#cb28-214" aria-hidden="true" tabindex="-1"></a>every C/C++ code is portable or supported in every operating system, and, therefore,</span>
<span id="cb28-215"><a href="#cb28-215" aria-hidden="true" tabindex="-1"></a>would cause a compilation error in the C/C++ compiler.</span>
<span id="cb28-216"><a href="#cb28-216" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-217"><a href="#cb28-217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-218"><a href="#cb28-218" aria-hidden="true" tabindex="-1"></a>Now, one important detail about the build process is that, you have to **explicitly</span>
<span id="cb28-219"><a href="#cb28-219" aria-hidden="true" tabindex="-1"></a>install the target objects that you create in your build script**, by using the</span>
<span id="cb28-220"><a href="#cb28-220" aria-hidden="true" tabindex="-1"></a><span class="in">`installArtifact()`</span> method of the <span class="in">`Build`</span> struct.</span>
<span id="cb28-221"><a href="#cb28-221" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-222"><a href="#cb28-222" aria-hidden="true" tabindex="-1"></a>Everytime you invoke the build process of your project, by calling the <span class="in">`build`</span> command</span>
<span id="cb28-223"><a href="#cb28-223" aria-hidden="true" tabindex="-1"></a>of the <span class="in">`zig`</span> compiler, a new directory named <span class="in">`zig-out`</span> is created in the root</span>
<span id="cb28-224"><a href="#cb28-224" aria-hidden="true" tabindex="-1"></a>directory of your project. This new directory contains the outputs of the build process,</span>
<span id="cb28-225"><a href="#cb28-225" aria-hidden="true" tabindex="-1"></a>that is, the binary files built from your source code.</span>
<span id="cb28-226"><a href="#cb28-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-227"><a href="#cb28-227" aria-hidden="true" tabindex="-1"></a>What the <span class="in">`installArtifact()`</span> method do is to install (or copy) the built target objects</span>
<span id="cb28-228"><a href="#cb28-228" aria-hidden="true" tabindex="-1"></a>that you defined to this <span class="in">`zig-out`</span> directory.</span>
<span id="cb28-229"><a href="#cb28-229" aria-hidden="true" tabindex="-1"></a>This means that, if you do not</span>
<span id="cb28-230"><a href="#cb28-230" aria-hidden="true" tabindex="-1"></a>install the target objects you define in your build script, these target objects are</span>
<span id="cb28-231"><a href="#cb28-231" aria-hidden="true" tabindex="-1"></a>essentially discarded at the end of the build process.</span>
<span id="cb28-232"><a href="#cb28-232" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-233"><a href="#cb28-233" aria-hidden="true" tabindex="-1"></a>For example, you might be building a project that uses a third party library that is built</span>
<span id="cb28-234"><a href="#cb28-234" aria-hidden="true" tabindex="-1"></a>together with the project. So, when you build your project, you would need first, to</span>
<span id="cb28-235"><a href="#cb28-235" aria-hidden="true" tabindex="-1"></a>build the third party library, and then, you link it with the source code of your project.</span>
<span id="cb28-236"><a href="#cb28-236" aria-hidden="true" tabindex="-1"></a>So, in this case, we have two binary files that are generated in the build process (the executable file of your project, and the third party library).</span>
<span id="cb28-237"><a href="#cb28-237" aria-hidden="true" tabindex="-1"></a>But only one is of interest, which is the executable file of our project.</span>
<span id="cb28-238"><a href="#cb28-238" aria-hidden="true" tabindex="-1"></a>We can discard the binary file of the third party library, by simply not installing it</span>
<span id="cb28-239"><a href="#cb28-239" aria-hidden="true" tabindex="-1"></a>into this <span class="in">`zig-out`</span> directory.</span>
<span id="cb28-240"><a href="#cb28-240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-241"><a href="#cb28-241" aria-hidden="true" tabindex="-1"></a>This <span class="in">`installArtifact()`</span> method is pretty straightforward. Just remember to apply it to every</span>
<span id="cb28-242"><a href="#cb28-242" aria-hidden="true" tabindex="-1"></a>target object that you want to save into the <span class="in">`zig-out`</span> directory, like in the example below:</span>
<span id="cb28-243"><a href="#cb28-243" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-244"><a href="#cb28-244" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-247"><a href="#cb28-247" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb28-248"><a href="#cb28-248" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb28-249"><a href="#cb28-249" aria-hidden="true" tabindex="-1"></a><span class="in">const exe = b.addExecutable(.{</span></span>
<span id="cb28-250"><a href="#cb28-250" aria-hidden="true" tabindex="-1"></a><span class="in">    .name = "hello",</span></span>
<span id="cb28-251"><a href="#cb28-251" aria-hidden="true" tabindex="-1"></a><span class="in">    .root_source_file = b.path("hello.zig"),</span></span>
<span id="cb28-252"><a href="#cb28-252" aria-hidden="true" tabindex="-1"></a><span class="in">    .target = b.host,</span></span>
<span id="cb28-253"><a href="#cb28-253" aria-hidden="true" tabindex="-1"></a><span class="in">});</span></span>
<span id="cb28-254"><a href="#cb28-254" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-255"><a href="#cb28-255" aria-hidden="true" tabindex="-1"></a><span class="in">b.installArtifact(exe);</span></span>
<span id="cb28-256"><a href="#cb28-256" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-257"><a href="#cb28-257" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-258"><a href="#cb28-258" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-259"><a href="#cb28-259" aria-hidden="true" tabindex="-1"></a><span class="fu">## Setting the build mode</span></span>
<span id="cb28-260"><a href="#cb28-260" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-261"><a href="#cb28-261" aria-hidden="true" tabindex="-1"></a>We have talked about the three essential options that are set when you create a new target object.</span>
<span id="cb28-262"><a href="#cb28-262" aria-hidden="true" tabindex="-1"></a>But there is also a fourth option that you can use to set the build mode of this target object,</span>
<span id="cb28-263"><a href="#cb28-263" aria-hidden="true" tabindex="-1"></a>which is the <span class="in">`optimize`</span> option.</span>
<span id="cb28-264"><a href="#cb28-264" aria-hidden="true" tabindex="-1"></a>This option is called this way, because the build modes in Zig are treated more of</span>
<span id="cb28-265"><a href="#cb28-265" aria-hidden="true" tabindex="-1"></a>an "optimization vs safety" problem. So optimization plays an important role here.</span>
<span id="cb28-266"><a href="#cb28-266" aria-hidden="true" tabindex="-1"></a>Don't worry, I'm going back to this question very soon.</span>
<span id="cb28-267"><a href="#cb28-267" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-268"><a href="#cb28-268" aria-hidden="true" tabindex="-1"></a>In Zig, we have four build modes (which are listed below). Each one of these build modes offer</span>
<span id="cb28-269"><a href="#cb28-269" aria-hidden="true" tabindex="-1"></a>different advantages and characteristics. As we described in @sec-compile-debug-mode, the <span class="in">`zig`</span> compiler</span>
<span id="cb28-270"><a href="#cb28-270" aria-hidden="true" tabindex="-1"></a>uses the <span class="in">`Debug`</span> build mode by default, when you don't explicitly choose a build mode.</span>
<span id="cb28-271"><a href="#cb28-271" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-272"><a href="#cb28-272" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`Debug`</span>, mode that produces and includes debugging information in the output of the build process (i.e., the binary file defined by the target object);</span>
<span id="cb28-273"><a href="#cb28-273" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`ReleaseSmall`</span>, mode that tries to produce a binary file that is small in size;</span>
<span id="cb28-274"><a href="#cb28-274" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`ReleaseFast`</span>, mode that tries to optimize your code, in order to produce a binary file that is as fast as possible;</span>
<span id="cb28-275"><a href="#cb28-275" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`ReleaseSafe`</span>, mode that tries to make your code as safe as possible, by including safeguards when possible.</span>
<span id="cb28-276"><a href="#cb28-276" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-277"><a href="#cb28-277" aria-hidden="true" tabindex="-1"></a>So, when you build your project, you can set the build mode of your target object to <span class="in">`ReleaseFast`</span> for example, which will tell</span>
<span id="cb28-278"><a href="#cb28-278" aria-hidden="true" tabindex="-1"></a>the <span class="in">`zig`</span> compiler to apply important optimizations in your code. This creates a binary file</span>
<span id="cb28-279"><a href="#cb28-279" aria-hidden="true" tabindex="-1"></a>that simply runs faster on most contexts, because it contains a more optimized version of your code.</span>
<span id="cb28-280"><a href="#cb28-280" aria-hidden="true" tabindex="-1"></a>However, as a result, we often lose some safety features in our code.</span>
<span id="cb28-281"><a href="#cb28-281" aria-hidden="true" tabindex="-1"></a>Because some safety checks are removed from the final binary file,</span>
<span id="cb28-282"><a href="#cb28-282" aria-hidden="true" tabindex="-1"></a>which makes your code run faster, but in a less safe manner.</span>
<span id="cb28-283"><a href="#cb28-283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-284"><a href="#cb28-284" aria-hidden="true" tabindex="-1"></a>This choice depends on your current priorities. If you are building a cryptography or banking system, you might</span>
<span id="cb28-285"><a href="#cb28-285" aria-hidden="true" tabindex="-1"></a>prefer to prioritize safety in your code, so, you would choose the <span class="in">`ReleaseSafe`</span> build mode, which is a little</span>
<span id="cb28-286"><a href="#cb28-286" aria-hidden="true" tabindex="-1"></a>slower to run, but much more secure, because it includes all possible runtime safety checks in the binary file</span>
<span id="cb28-287"><a href="#cb28-287" aria-hidden="true" tabindex="-1"></a>built in the build process. In the other hand, if you are writing a game for example, you might prefer to prioritize performance</span>
<span id="cb28-288"><a href="#cb28-288" aria-hidden="true" tabindex="-1"></a>over safety, by using the <span class="in">`ReleaseFast`</span> build mode, so that your users can experience faster frame rates in your game.</span>
<span id="cb28-289"><a href="#cb28-289" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-290"><a href="#cb28-290" aria-hidden="true" tabindex="-1"></a>In the example below, we are creating the same target object that we have used on previous examples.</span>
<span id="cb28-291"><a href="#cb28-291" aria-hidden="true" tabindex="-1"></a>But this time, we are specifying the build mode of this target object to the <span class="in">`ReleaseSafe`</span> mode.</span>
<span id="cb28-292"><a href="#cb28-292" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-295"><a href="#cb28-295" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb28-296"><a href="#cb28-296" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb28-297"><a href="#cb28-297" aria-hidden="true" tabindex="-1"></a><span class="in">const exe = b.addExecutable(.{</span></span>
<span id="cb28-298"><a href="#cb28-298" aria-hidden="true" tabindex="-1"></a><span class="in">    .name = "hello",</span></span>
<span id="cb28-299"><a href="#cb28-299" aria-hidden="true" tabindex="-1"></a><span class="in">    .root_source_file = b.path("hello.zig"),</span></span>
<span id="cb28-300"><a href="#cb28-300" aria-hidden="true" tabindex="-1"></a><span class="in">    .target = b.host,</span></span>
<span id="cb28-301"><a href="#cb28-301" aria-hidden="true" tabindex="-1"></a><span class="in">    .optimize = .ReleaseSafe</span></span>
<span id="cb28-302"><a href="#cb28-302" aria-hidden="true" tabindex="-1"></a><span class="in">});</span></span>
<span id="cb28-303"><a href="#cb28-303" aria-hidden="true" tabindex="-1"></a><span class="in">b.installArtifact(exe);</span></span>
<span id="cb28-304"><a href="#cb28-304" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-305"><a href="#cb28-305" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-306"><a href="#cb28-306" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-307"><a href="#cb28-307" aria-hidden="true" tabindex="-1"></a><span class="fu">## Setting the version of your build</span></span>
<span id="cb28-308"><a href="#cb28-308" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-309"><a href="#cb28-309" aria-hidden="true" tabindex="-1"></a>Everytime you build a target object in your build script, you can assign a version</span>
<span id="cb28-310"><a href="#cb28-310" aria-hidden="true" tabindex="-1"></a>number to this specific build, following a semantic versioning framework.</span>
<span id="cb28-311"><a href="#cb28-311" aria-hidden="true" tabindex="-1"></a>You can find more about semantic versioning by visiting the <span class="co">[</span><span class="ot">Semantic Versioning website</span><span class="co">](https://semver.org/)</span><span class="ot">[^semver]</span>.</span>
<span id="cb28-312"><a href="#cb28-312" aria-hidden="true" tabindex="-1"></a>Anyway, in Zig, you can specify the version of your build, by providing a <span class="in">`SemanticVersion`</span> struct to</span>
<span id="cb28-313"><a href="#cb28-313" aria-hidden="true" tabindex="-1"></a>the <span class="in">`version`</span> option, like in the example below:</span>
<span id="cb28-314"><a href="#cb28-314" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-315"><a href="#cb28-315" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-316"><a href="#cb28-316" aria-hidden="true" tabindex="-1"></a><span class="ot">[^semver]: &lt;https://semver.org/&gt;</span></span>
<span id="cb28-317"><a href="#cb28-317" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-318"><a href="#cb28-318" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-321"><a href="#cb28-321" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb28-322"><a href="#cb28-322" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb28-323"><a href="#cb28-323" aria-hidden="true" tabindex="-1"></a><span class="in">const exe = b.addExecutable(.{</span></span>
<span id="cb28-324"><a href="#cb28-324" aria-hidden="true" tabindex="-1"></a><span class="in">    .name = "hello",</span></span>
<span id="cb28-325"><a href="#cb28-325" aria-hidden="true" tabindex="-1"></a><span class="in">    .root_source_file = b.path("hello.zig"),</span></span>
<span id="cb28-326"><a href="#cb28-326" aria-hidden="true" tabindex="-1"></a><span class="in">    .target = b.host,</span></span>
<span id="cb28-327"><a href="#cb28-327" aria-hidden="true" tabindex="-1"></a><span class="in">    .version = .{</span></span>
<span id="cb28-328"><a href="#cb28-328" aria-hidden="true" tabindex="-1"></a><span class="in">        .major = 2, .minor = 9, .patch = 7</span></span>
<span id="cb28-329"><a href="#cb28-329" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb28-330"><a href="#cb28-330" aria-hidden="true" tabindex="-1"></a><span class="in">});</span></span>
<span id="cb28-331"><a href="#cb28-331" aria-hidden="true" tabindex="-1"></a><span class="in">b.installArtifact(exe);</span></span>
<span id="cb28-332"><a href="#cb28-332" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-333"><a href="#cb28-333" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-334"><a href="#cb28-334" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-335"><a href="#cb28-335" aria-hidden="true" tabindex="-1"></a><span class="fu">## Detecting the OS in your build script {#sec-detect-os}</span></span>
<span id="cb28-336"><a href="#cb28-336" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-337"><a href="#cb28-337" aria-hidden="true" tabindex="-1"></a>It's very common in Build Systems to use different options, or, to include different modules, or,</span>
<span id="cb28-338"><a href="#cb28-338" aria-hidden="true" tabindex="-1"></a>to link against different libraries depending on the Operational System (OS)</span>
<span id="cb28-339"><a href="#cb28-339" aria-hidden="true" tabindex="-1"></a>that you are targeting in the build process.</span>
<span id="cb28-340"><a href="#cb28-340" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-341"><a href="#cb28-341" aria-hidden="true" tabindex="-1"></a>In Zig, you can detect the target OS of the build process, by looking</span>
<span id="cb28-342"><a href="#cb28-342" aria-hidden="true" tabindex="-1"></a>at the <span class="in">`os.tag`</span> inside the <span class="in">`builtin`</span> module from the Zig library.</span>
<span id="cb28-343"><a href="#cb28-343" aria-hidden="true" tabindex="-1"></a>In the example below, we are using an if statement to run some</span>
<span id="cb28-344"><a href="#cb28-344" aria-hidden="true" tabindex="-1"></a>arbitrary code when the target of the build process is a</span>
<span id="cb28-345"><a href="#cb28-345" aria-hidden="true" tabindex="-1"></a>Windows system.</span>
<span id="cb28-346"><a href="#cb28-346" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-349"><a href="#cb28-349" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb28-350"><a href="#cb28-350" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb28-351"><a href="#cb28-351" aria-hidden="true" tabindex="-1"></a><span class="in">const builtin = @import("builtin");</span></span>
<span id="cb28-352"><a href="#cb28-352" aria-hidden="true" tabindex="-1"></a><span class="in">if (builtin.target.os.tag == .windows) {</span></span>
<span id="cb28-353"><a href="#cb28-353" aria-hidden="true" tabindex="-1"></a><span class="in">    // Code that runs only when the target of</span></span>
<span id="cb28-354"><a href="#cb28-354" aria-hidden="true" tabindex="-1"></a><span class="in">    // the compilation process is Windows.</span></span>
<span id="cb28-355"><a href="#cb28-355" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-356"><a href="#cb28-356" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-357"><a href="#cb28-357" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-358"><a href="#cb28-358" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-359"><a href="#cb28-359" aria-hidden="true" tabindex="-1"></a><span class="fu">## Adding a run step to your build process</span></span>
<span id="cb28-360"><a href="#cb28-360" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-361"><a href="#cb28-361" aria-hidden="true" tabindex="-1"></a>One thing that is neat in Rust is that you can compile and run your</span>
<span id="cb28-362"><a href="#cb28-362" aria-hidden="true" tabindex="-1"></a>source code with one single command (<span class="in">`cargo run`</span>) from the Rust compiler.</span>
<span id="cb28-363"><a href="#cb28-363" aria-hidden="true" tabindex="-1"></a>We saw in @sec-compile-run-code how can we perform a similar job in Zig, by</span>
<span id="cb28-364"><a href="#cb28-364" aria-hidden="true" tabindex="-1"></a>building and running our Zig source code through the <span class="in">`run`</span> command from the <span class="in">`zig`</span> compiler.</span>
<span id="cb28-365"><a href="#cb28-365" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-366"><a href="#cb28-366" aria-hidden="true" tabindex="-1"></a>But how can we, at the same time, build and run the binary file specified by a target object in our</span>
<span id="cb28-367"><a href="#cb28-367" aria-hidden="true" tabindex="-1"></a>build script?</span>
<span id="cb28-368"><a href="#cb28-368" aria-hidden="true" tabindex="-1"></a>The answer is by including a "run artifact" in our build script.</span>
<span id="cb28-369"><a href="#cb28-369" aria-hidden="true" tabindex="-1"></a>A run artifact is created through the <span class="in">`addRunArtifact()`</span> method from the <span class="in">`Build`</span> struct.</span>
<span id="cb28-370"><a href="#cb28-370" aria-hidden="true" tabindex="-1"></a>We simply provide as input to this function the target object that describes the binary file that we</span>
<span id="cb28-371"><a href="#cb28-371" aria-hidden="true" tabindex="-1"></a>want to execute. As a result, this function creates a run artifact that is capable of executing</span>
<span id="cb28-372"><a href="#cb28-372" aria-hidden="true" tabindex="-1"></a>this binary file.</span>
<span id="cb28-373"><a href="#cb28-373" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-374"><a href="#cb28-374" aria-hidden="true" tabindex="-1"></a>In the example below, we are defining an executable binary file named <span class="in">`hello`</span>,</span>
<span id="cb28-375"><a href="#cb28-375" aria-hidden="true" tabindex="-1"></a>and we use this <span class="in">`addRunArtifact()`</span> method to create a run artifact that will execute</span>
<span id="cb28-376"><a href="#cb28-376" aria-hidden="true" tabindex="-1"></a>this <span class="in">`hello`</span> executable file.</span>
<span id="cb28-377"><a href="#cb28-377" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-380"><a href="#cb28-380" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb28-381"><a href="#cb28-381" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb28-382"><a href="#cb28-382" aria-hidden="true" tabindex="-1"></a><span class="in">const exe = b.addExecutable(.{</span></span>
<span id="cb28-383"><a href="#cb28-383" aria-hidden="true" tabindex="-1"></a><span class="in">    .name = "hello",</span></span>
<span id="cb28-384"><a href="#cb28-384" aria-hidden="true" tabindex="-1"></a><span class="in">    .root_source_file = b.path("src/hello.zig"),</span></span>
<span id="cb28-385"><a href="#cb28-385" aria-hidden="true" tabindex="-1"></a><span class="in">    .target = b.host</span></span>
<span id="cb28-386"><a href="#cb28-386" aria-hidden="true" tabindex="-1"></a><span class="in">});</span></span>
<span id="cb28-387"><a href="#cb28-387" aria-hidden="true" tabindex="-1"></a><span class="in">b.installArtifact(exe);</span></span>
<span id="cb28-388"><a href="#cb28-388" aria-hidden="true" tabindex="-1"></a><span class="in">const run_arti = b.addRunArtifact(exe);</span></span>
<span id="cb28-389"><a href="#cb28-389" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-390"><a href="#cb28-390" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-391"><a href="#cb28-391" aria-hidden="true" tabindex="-1"></a>Now that we have created this run artifact, we need to include it in</span>
<span id="cb28-392"><a href="#cb28-392" aria-hidden="true" tabindex="-1"></a>the build process. We do that by declaring a new step in our build</span>
<span id="cb28-393"><a href="#cb28-393" aria-hidden="true" tabindex="-1"></a>script to call this artifact, through the <span class="in">`step()`</span> method of the <span class="in">`Build`</span></span>
<span id="cb28-394"><a href="#cb28-394" aria-hidden="true" tabindex="-1"></a>struct.</span>
<span id="cb28-395"><a href="#cb28-395" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-396"><a href="#cb28-396" aria-hidden="true" tabindex="-1"></a>We can give any name we want to this step, but, for our</span>
<span id="cb28-397"><a href="#cb28-397" aria-hidden="true" tabindex="-1"></a>context here, I'm going to name this step as "run".</span>
<span id="cb28-398"><a href="#cb28-398" aria-hidden="true" tabindex="-1"></a>Also, I give it a brief description to this step ("Run the project").</span>
<span id="cb28-399"><a href="#cb28-399" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-402"><a href="#cb28-402" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb28-403"><a href="#cb28-403" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb28-404"><a href="#cb28-404" aria-hidden="true" tabindex="-1"></a><span class="in">const run_step = b.step(</span></span>
<span id="cb28-405"><a href="#cb28-405" aria-hidden="true" tabindex="-1"></a><span class="in">    "run", "Run the project"</span></span>
<span id="cb28-406"><a href="#cb28-406" aria-hidden="true" tabindex="-1"></a><span class="in">);</span></span>
<span id="cb28-407"><a href="#cb28-407" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-408"><a href="#cb28-408" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-409"><a href="#cb28-409" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-410"><a href="#cb28-410" aria-hidden="true" tabindex="-1"></a>Now that we have declared this "run step" we need to tell Zig that</span>
<span id="cb28-411"><a href="#cb28-411" aria-hidden="true" tabindex="-1"></a>this "run step" depends on the run artifact.</span>
<span id="cb28-412"><a href="#cb28-412" aria-hidden="true" tabindex="-1"></a>In other words, a run artifact always depends on a "step" to effectively be executed.</span>
<span id="cb28-413"><a href="#cb28-413" aria-hidden="true" tabindex="-1"></a>By creating this dependency</span>
<span id="cb28-414"><a href="#cb28-414" aria-hidden="true" tabindex="-1"></a>we finally stablish the necessary commands to build and run the executable file</span>
<span id="cb28-415"><a href="#cb28-415" aria-hidden="true" tabindex="-1"></a>from the build script.</span>
<span id="cb28-416"><a href="#cb28-416" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-417"><a href="#cb28-417" aria-hidden="true" tabindex="-1"></a>We can establish a dependency between the run step and the run artifact</span>
<span id="cb28-418"><a href="#cb28-418" aria-hidden="true" tabindex="-1"></a>by using the <span class="in">`dependsOn()`</span> method from the run step. So, we first</span>
<span id="cb28-419"><a href="#cb28-419" aria-hidden="true" tabindex="-1"></a>create the run step, and then, we link it with the run artifact, by</span>
<span id="cb28-420"><a href="#cb28-420" aria-hidden="true" tabindex="-1"></a>using this <span class="in">`dependsOn()`</span> method from the run step.</span>
<span id="cb28-421"><a href="#cb28-421" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-424"><a href="#cb28-424" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb28-425"><a href="#cb28-425" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb28-426"><a href="#cb28-426" aria-hidden="true" tabindex="-1"></a><span class="in">run_step.dependOn(&amp;run_arti.step);</span></span>
<span id="cb28-427"><a href="#cb28-427" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-428"><a href="#cb28-428" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-429"><a href="#cb28-429" aria-hidden="true" tabindex="-1"></a>The entire source code of this specific build script that</span>
<span id="cb28-430"><a href="#cb28-430" aria-hidden="true" tabindex="-1"></a>we wrote, piece by piece, in this section, is</span>
<span id="cb28-431"><a href="#cb28-431" aria-hidden="true" tabindex="-1"></a>available in the <span class="in">`build_and_run.zig`</span> module. You can</span>
<span id="cb28-432"><a href="#cb28-432" aria-hidden="true" tabindex="-1"></a>see this module by</span>
<span id="cb28-433"><a href="#cb28-433" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">visiting the official repository of this book</span><span class="co">](https://github.com/pedropark99/zig-book/blob/main/ZigExamples/build_system/build_and_run.zig)</span></span>
<span id="cb28-434"><a href="#cb28-434" aria-hidden="true" tabindex="-1"></a><span class="ot">[^module-src]</span>.</span>
<span id="cb28-435"><a href="#cb28-435" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-436"><a href="#cb28-436" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-437"><a href="#cb28-437" aria-hidden="true" tabindex="-1"></a><span class="ot">[^module-src]: &lt;https://github.com/pedropark99/zig-book/blob/main/ZigExamples/build_system/build_and_run.zig&gt;</span></span>
<span id="cb28-438"><a href="#cb28-438" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-439"><a href="#cb28-439" aria-hidden="true" tabindex="-1"></a>When you declare a new step in your build script, this step</span>
<span id="cb28-440"><a href="#cb28-440" aria-hidden="true" tabindex="-1"></a>becomes available through the <span class="in">`build`</span> command in the <span class="in">`zig`</span> compiler.</span>
<span id="cb28-441"><a href="#cb28-441" aria-hidden="true" tabindex="-1"></a>You can actually see this step by running <span class="in">`zig build --help`</span> in the terminal, like</span>
<span id="cb28-442"><a href="#cb28-442" aria-hidden="true" tabindex="-1"></a>in the example below, where we can see that this new "run"</span>
<span id="cb28-443"><a href="#cb28-443" aria-hidden="true" tabindex="-1"></a>step that we declared in the build script appeared in the output.</span>
<span id="cb28-444"><a href="#cb28-444" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-445"><a href="#cb28-445" aria-hidden="true" tabindex="-1"></a><span class="in">```bash</span></span>
<span id="cb28-446"><a href="#cb28-446" aria-hidden="true" tabindex="-1"></a><span class="ex">zig</span> build <span class="at">--help</span></span>
<span id="cb28-447"><a href="#cb28-447" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-448"><a href="#cb28-448" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-449"><a href="#cb28-449" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-450"><a href="#cb28-450" aria-hidden="true" tabindex="-1"></a><span class="in">Steps:</span></span>
<span id="cb28-451"><a href="#cb28-451" aria-hidden="true" tabindex="-1"></a><span class="in">  ...</span></span>
<span id="cb28-452"><a href="#cb28-452" aria-hidden="true" tabindex="-1"></a><span class="in">  run   Run the project</span></span>
<span id="cb28-453"><a href="#cb28-453" aria-hidden="true" tabindex="-1"></a><span class="in">  ...</span></span>
<span id="cb28-454"><a href="#cb28-454" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-455"><a href="#cb28-455" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-456"><a href="#cb28-456" aria-hidden="true" tabindex="-1"></a>Now, everything that we need to is to</span>
<span id="cb28-457"><a href="#cb28-457" aria-hidden="true" tabindex="-1"></a>call this "run" step that we created in our build script. We</span>
<span id="cb28-458"><a href="#cb28-458" aria-hidden="true" tabindex="-1"></a>call it by using the name that we gave to this step</span>
<span id="cb28-459"><a href="#cb28-459" aria-hidden="true" tabindex="-1"></a>after the <span class="in">`build`</span> command from the <span class="in">`zig`</span> compiler.</span>
<span id="cb28-460"><a href="#cb28-460" aria-hidden="true" tabindex="-1"></a>This will cause the compiler to build our executable file</span>
<span id="cb28-461"><a href="#cb28-461" aria-hidden="true" tabindex="-1"></a>and execute it at the same time.</span>
<span id="cb28-462"><a href="#cb28-462" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-463"><a href="#cb28-463" aria-hidden="true" tabindex="-1"></a><span class="in">```bash</span></span>
<span id="cb28-464"><a href="#cb28-464" aria-hidden="true" tabindex="-1"></a><span class="ex">zig</span> build run</span>
<span id="cb28-465"><a href="#cb28-465" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-466"><a href="#cb28-466" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-467"><a href="#cb28-467" aria-hidden="true" tabindex="-1"></a><span class="fu">## Build unit tests in your project</span></span>
<span id="cb28-468"><a href="#cb28-468" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-469"><a href="#cb28-469" aria-hidden="true" tabindex="-1"></a>We have talked at length about writing unit tests in Zig in @sec-unittests,</span>
<span id="cb28-470"><a href="#cb28-470" aria-hidden="true" tabindex="-1"></a>and we also have talked about how to execute these unit tests through</span>
<span id="cb28-471"><a href="#cb28-471" aria-hidden="true" tabindex="-1"></a>the <span class="in">`test`</span> command of the <span class="in">`zig`</span> compiler. However,</span>
<span id="cb28-472"><a href="#cb28-472" aria-hidden="true" tabindex="-1"></a>as we did with the <span class="in">`run`</span> command on the previous section, we also might want to</span>
<span id="cb28-473"><a href="#cb28-473" aria-hidden="true" tabindex="-1"></a>include some commands in our build script to also build and execute the unit tests in our project.</span>
<span id="cb28-474"><a href="#cb28-474" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-475"><a href="#cb28-475" aria-hidden="true" tabindex="-1"></a>So, once again, we are going to discuss how a specific built-in command from the <span class="in">`zig`</span> compiler,</span>
<span id="cb28-476"><a href="#cb28-476" aria-hidden="true" tabindex="-1"></a>(in this case, the <span class="in">`test`</span> command) can be used in a build script in Zig.</span>
<span id="cb28-477"><a href="#cb28-477" aria-hidden="true" tabindex="-1"></a>Here is where a "test target object" comes into play.</span>
<span id="cb28-478"><a href="#cb28-478" aria-hidden="true" tabindex="-1"></a>As was described in @sec-targets, we can create a test target object by using the <span class="in">`addTest()`</span> method of</span>
<span id="cb28-479"><a href="#cb28-479" aria-hidden="true" tabindex="-1"></a>the <span class="in">`Build`</span> struct. The first thing that we need to do is to</span>
<span id="cb28-480"><a href="#cb28-480" aria-hidden="true" tabindex="-1"></a>declare a test target object in our build script.</span>
<span id="cb28-481"><a href="#cb28-481" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-482"><a href="#cb28-482" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-485"><a href="#cb28-485" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb28-486"><a href="#cb28-486" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb28-487"><a href="#cb28-487" aria-hidden="true" tabindex="-1"></a><span class="in">const test_exe = b.addTest(.{</span></span>
<span id="cb28-488"><a href="#cb28-488" aria-hidden="true" tabindex="-1"></a><span class="in">    .name = "unit_tests",</span></span>
<span id="cb28-489"><a href="#cb28-489" aria-hidden="true" tabindex="-1"></a><span class="in">    .root_source_file = b.path("src/main.zig"),</span></span>
<span id="cb28-490"><a href="#cb28-490" aria-hidden="true" tabindex="-1"></a><span class="in">    .target = b.host,</span></span>
<span id="cb28-491"><a href="#cb28-491" aria-hidden="true" tabindex="-1"></a><span class="in">});</span></span>
<span id="cb28-492"><a href="#cb28-492" aria-hidden="true" tabindex="-1"></a><span class="in">b.installArtifact(test_exe);</span></span>
<span id="cb28-493"><a href="#cb28-493" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-494"><a href="#cb28-494" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-495"><a href="#cb28-495" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-496"><a href="#cb28-496" aria-hidden="true" tabindex="-1"></a>A test target object essentially selects all <span class="in">`test`</span> blocks in all Zig modules</span>
<span id="cb28-497"><a href="#cb28-497" aria-hidden="true" tabindex="-1"></a>across your project, and builds only the source code present inside</span>
<span id="cb28-498"><a href="#cb28-498" aria-hidden="true" tabindex="-1"></a>these <span class="in">`test`</span> blocks in your project. As a result, this target object</span>
<span id="cb28-499"><a href="#cb28-499" aria-hidden="true" tabindex="-1"></a>creates an executable file that contains only the source code present</span>
<span id="cb28-500"><a href="#cb28-500" aria-hidden="true" tabindex="-1"></a>in all of these <span class="in">`test`</span> blocks (i.e., the unit tests) in your project.</span>
<span id="cb28-501"><a href="#cb28-501" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-502"><a href="#cb28-502" aria-hidden="true" tabindex="-1"></a>Perfect! Now that we have declared this test target object, an executable file</span>
<span id="cb28-503"><a href="#cb28-503" aria-hidden="true" tabindex="-1"></a>named <span class="in">`unit_tests`</span> is built by the <span class="in">`zig`</span> compiler when we trigger the build</span>
<span id="cb28-504"><a href="#cb28-504" aria-hidden="true" tabindex="-1"></a>script with the <span class="in">`build`</span> command. After the build</span>
<span id="cb28-505"><a href="#cb28-505" aria-hidden="true" tabindex="-1"></a>process is finished, we can simply execute this <span class="in">`unit_tests`</span> executable</span>
<span id="cb28-506"><a href="#cb28-506" aria-hidden="true" tabindex="-1"></a>in the terminal.</span>
<span id="cb28-507"><a href="#cb28-507" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-508"><a href="#cb28-508" aria-hidden="true" tabindex="-1"></a>However, if you remember the previous section, we already learned</span>
<span id="cb28-509"><a href="#cb28-509" aria-hidden="true" tabindex="-1"></a>how can we create a run step in our build script, to execute an executable file</span>
<span id="cb28-510"><a href="#cb28-510" aria-hidden="true" tabindex="-1"></a>built by the build script.</span>
<span id="cb28-511"><a href="#cb28-511" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-512"><a href="#cb28-512" aria-hidden="true" tabindex="-1"></a>So, we could simply add a run step in our build script to run these unit tests</span>
<span id="cb28-513"><a href="#cb28-513" aria-hidden="true" tabindex="-1"></a>from a single command in the <span class="in">`zig`</span> compiler, to make our lifes easier.</span>
<span id="cb28-514"><a href="#cb28-514" aria-hidden="true" tabindex="-1"></a>In the example below, we demonstrate the commands to</span>
<span id="cb28-515"><a href="#cb28-515" aria-hidden="true" tabindex="-1"></a>register a new build step called "tests" in our build script</span>
<span id="cb28-516"><a href="#cb28-516" aria-hidden="true" tabindex="-1"></a>to run these unit tests.</span>
<span id="cb28-517"><a href="#cb28-517" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-520"><a href="#cb28-520" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb28-521"><a href="#cb28-521" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb28-522"><a href="#cb28-522" aria-hidden="true" tabindex="-1"></a><span class="in">const run_arti = b.addRunArtifact(test_exe);</span></span>
<span id="cb28-523"><a href="#cb28-523" aria-hidden="true" tabindex="-1"></a><span class="in">const run_step = b.step("tests", "Run unit tests");</span></span>
<span id="cb28-524"><a href="#cb28-524" aria-hidden="true" tabindex="-1"></a><span class="in">run_step.dependOn(&amp;run_arti.step);</span></span>
<span id="cb28-525"><a href="#cb28-525" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-526"><a href="#cb28-526" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-527"><a href="#cb28-527" aria-hidden="true" tabindex="-1"></a>Now that we registered this new build step, we can trigger it by calling the command below</span>
<span id="cb28-528"><a href="#cb28-528" aria-hidden="true" tabindex="-1"></a>in the terminal. You can also checkout the complete source</span>
<span id="cb28-529"><a href="#cb28-529" aria-hidden="true" tabindex="-1"></a>code for this specific build script at the <span class="in">`build_tests.zig`</span> module at the</span>
<span id="cb28-530"><a href="#cb28-530" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">official repository of this book</span><span class="co">](https://github.com/pedropark99/zig-book/blob/main/ZigExamples/build_system/build_tests.zig)</span></span>
<span id="cb28-531"><a href="#cb28-531" aria-hidden="true" tabindex="-1"></a><span class="ot">[^module-src2]</span>.</span>
<span id="cb28-532"><a href="#cb28-532" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-533"><a href="#cb28-533" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-534"><a href="#cb28-534" aria-hidden="true" tabindex="-1"></a><span class="ot">[^module-src2]: &lt;https://github.com/pedropark99/zig-book/blob/main/ZigExamples/build_system/build_tests.zig&gt;</span></span>
<span id="cb28-535"><a href="#cb28-535" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-536"><a href="#cb28-536" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-537"><a href="#cb28-537" aria-hidden="true" tabindex="-1"></a><span class="in">```bash</span></span>
<span id="cb28-538"><a href="#cb28-538" aria-hidden="true" tabindex="-1"></a><span class="ex">zig</span> build tests</span>
<span id="cb28-539"><a href="#cb28-539" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-540"><a href="#cb28-540" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-541"><a href="#cb28-541" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-542"><a href="#cb28-542" aria-hidden="true" tabindex="-1"></a><span class="fu">## Tailoring your build process with user-provided options</span></span>
<span id="cb28-543"><a href="#cb28-543" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-544"><a href="#cb28-544" aria-hidden="true" tabindex="-1"></a>Sometimes, you want to make a build script that is customizable by the user</span>
<span id="cb28-545"><a href="#cb28-545" aria-hidden="true" tabindex="-1"></a>of your project. You can do that by creating user-provided options in</span>
<span id="cb28-546"><a href="#cb28-546" aria-hidden="true" tabindex="-1"></a>your build script. We create an user-provided option by using the</span>
<span id="cb28-547"><a href="#cb28-547" aria-hidden="true" tabindex="-1"></a><span class="in">`option()`</span> method from the <span class="in">`Build`</span> struct.</span>
<span id="cb28-548"><a href="#cb28-548" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-549"><a href="#cb28-549" aria-hidden="true" tabindex="-1"></a>With this method, we create a "build option" which can be passed</span>
<span id="cb28-550"><a href="#cb28-550" aria-hidden="true" tabindex="-1"></a>to the <span class="in">`build.zig`</span> script at the command line. The user have the power of setting</span>
<span id="cb28-551"><a href="#cb28-551" aria-hidden="true" tabindex="-1"></a>this option at the <span class="in">`build`</span> command from the</span>
<span id="cb28-552"><a href="#cb28-552" aria-hidden="true" tabindex="-1"></a><span class="in">`zig`</span> compiler. In other words, each build option that we create</span>
<span id="cb28-553"><a href="#cb28-553" aria-hidden="true" tabindex="-1"></a>becomes a new command line argument that is accessible through the <span class="in">`build`</span> command</span>
<span id="cb28-554"><a href="#cb28-554" aria-hidden="true" tabindex="-1"></a>of the compiler.</span>
<span id="cb28-555"><a href="#cb28-555" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-556"><a href="#cb28-556" aria-hidden="true" tabindex="-1"></a>These "user-provided options" are set by using the prefix <span class="in">`-D`</span> in the command line.</span>
<span id="cb28-557"><a href="#cb28-557" aria-hidden="true" tabindex="-1"></a>For example, if we declare an option named <span class="in">`use_zlib`</span>, that receives a boolean value which</span>
<span id="cb28-558"><a href="#cb28-558" aria-hidden="true" tabindex="-1"></a>indicates if we should link our source code to <span class="in">`zlib`</span> or not, we can set the value</span>
<span id="cb28-559"><a href="#cb28-559" aria-hidden="true" tabindex="-1"></a>of this option in the command line with <span class="in">`-Duse_zlib`</span>. The code example below</span>
<span id="cb28-560"><a href="#cb28-560" aria-hidden="true" tabindex="-1"></a>demonstrates this idea:</span>
<span id="cb28-561"><a href="#cb28-561" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-564"><a href="#cb28-564" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb28-565"><a href="#cb28-565" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb28-566"><a href="#cb28-566" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb28-567"><a href="#cb28-567" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn build(b: *std.Build) void {</span></span>
<span id="cb28-568"><a href="#cb28-568" aria-hidden="true" tabindex="-1"></a><span class="in">    const use_zlib = b.option(</span></span>
<span id="cb28-569"><a href="#cb28-569" aria-hidden="true" tabindex="-1"></a><span class="in">        bool,</span></span>
<span id="cb28-570"><a href="#cb28-570" aria-hidden="true" tabindex="-1"></a><span class="in">        "use_zlib",</span></span>
<span id="cb28-571"><a href="#cb28-571" aria-hidden="true" tabindex="-1"></a><span class="in">        "Should link to zlib?"</span></span>
<span id="cb28-572"><a href="#cb28-572" aria-hidden="true" tabindex="-1"></a><span class="in">    ) orelse false;</span></span>
<span id="cb28-573"><a href="#cb28-573" aria-hidden="true" tabindex="-1"></a><span class="in">    const exe = b.addExecutable(.{</span></span>
<span id="cb28-574"><a href="#cb28-574" aria-hidden="true" tabindex="-1"></a><span class="in">        .name = "hello",</span></span>
<span id="cb28-575"><a href="#cb28-575" aria-hidden="true" tabindex="-1"></a><span class="in">        .root_source_file = b.path("example.zig"),</span></span>
<span id="cb28-576"><a href="#cb28-576" aria-hidden="true" tabindex="-1"></a><span class="in">        .target = b.host,</span></span>
<span id="cb28-577"><a href="#cb28-577" aria-hidden="true" tabindex="-1"></a><span class="in">    });</span></span>
<span id="cb28-578"><a href="#cb28-578" aria-hidden="true" tabindex="-1"></a><span class="in">    if (use_zlib) {</span></span>
<span id="cb28-579"><a href="#cb28-579" aria-hidden="true" tabindex="-1"></a><span class="in">        exe.linkSystemLibrary("zlib");</span></span>
<span id="cb28-580"><a href="#cb28-580" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb28-581"><a href="#cb28-581" aria-hidden="true" tabindex="-1"></a><span class="in">    b.installArtifact(exe);</span></span>
<span id="cb28-582"><a href="#cb28-582" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-583"><a href="#cb28-583" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-584"><a href="#cb28-584" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-585"><a href="#cb28-585" aria-hidden="true" tabindex="-1"></a><span class="in">```bash</span></span>
<span id="cb28-586"><a href="#cb28-586" aria-hidden="true" tabindex="-1"></a><span class="ex">zig</span> build <span class="at">-Duse_zlib</span><span class="op">=</span>false</span>
<span id="cb28-587"><a href="#cb28-587" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-588"><a href="#cb28-588" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-589"><a href="#cb28-589" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-590"><a href="#cb28-590" aria-hidden="true" tabindex="-1"></a><span class="fu">## Linking to external libraries</span></span>
<span id="cb28-591"><a href="#cb28-591" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-592"><a href="#cb28-592" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-593"><a href="#cb28-593" aria-hidden="true" tabindex="-1"></a>One essential part of every build process is the linking stage.</span>
<span id="cb28-594"><a href="#cb28-594" aria-hidden="true" tabindex="-1"></a>This stage is responsible for combining the multiple object files</span>
<span id="cb28-595"><a href="#cb28-595" aria-hidden="true" tabindex="-1"></a>that represent your code, into a single executable file. It also links</span>
<span id="cb28-596"><a href="#cb28-596" aria-hidden="true" tabindex="-1"></a>this executable file to external libraries, if you use any in your code.</span>
<span id="cb28-597"><a href="#cb28-597" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-598"><a href="#cb28-598" aria-hidden="true" tabindex="-1"></a>In Zig, we have two notions of a "library", which are: 1) a system's library;</span>
<span id="cb28-599"><a href="#cb28-599" aria-hidden="true" tabindex="-1"></a>2) a local library. A system's library is just a library that is already installed</span>
<span id="cb28-600"><a href="#cb28-600" aria-hidden="true" tabindex="-1"></a>in your system. While a local library is a library that belongs to the current</span>
<span id="cb28-601"><a href="#cb28-601" aria-hidden="true" tabindex="-1"></a>project; a library that is present in your project directory, and</span>
<span id="cb28-602"><a href="#cb28-602" aria-hidden="true" tabindex="-1"></a>that you are building together with your project source code.</span>
<span id="cb28-603"><a href="#cb28-603" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-604"><a href="#cb28-604" aria-hidden="true" tabindex="-1"></a>The basic difference between the two, is that a system's library is already</span>
<span id="cb28-605"><a href="#cb28-605" aria-hidden="true" tabindex="-1"></a>built and installed in your system, supposedly, and all you need to do</span>
<span id="cb28-606"><a href="#cb28-606" aria-hidden="true" tabindex="-1"></a>is to link your source code to this library to start using it.</span>
<span id="cb28-607"><a href="#cb28-607" aria-hidden="true" tabindex="-1"></a>We do that by using the <span class="in">`linkSystemLibrary()`</span> method from a</span>
<span id="cb28-608"><a href="#cb28-608" aria-hidden="true" tabindex="-1"></a><span class="in">`Compile`</span> object. This method accepts the name of the library</span>
<span id="cb28-609"><a href="#cb28-609" aria-hidden="true" tabindex="-1"></a>in a string as input. Remember from @sec-targets that a <span class="in">`Compile`</span> object</span>
<span id="cb28-610"><a href="#cb28-610" aria-hidden="true" tabindex="-1"></a>is a target object that you declare in your build script.</span>
<span id="cb28-611"><a href="#cb28-611" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-612"><a href="#cb28-612" aria-hidden="true" tabindex="-1"></a>When you link a particular target object with a system's library,</span>
<span id="cb28-613"><a href="#cb28-613" aria-hidden="true" tabindex="-1"></a>the <span class="in">`zig`</span> compiler will use <span class="in">`pkg-config`</span> to find where</span>
<span id="cb28-614"><a href="#cb28-614" aria-hidden="true" tabindex="-1"></a>are the binary files and also the header files of this library</span>
<span id="cb28-615"><a href="#cb28-615" aria-hidden="true" tabindex="-1"></a>in your system.</span>
<span id="cb28-616"><a href="#cb28-616" aria-hidden="true" tabindex="-1"></a>When it finds these files, the linker present in the <span class="in">`zig`</span> compiler</span>
<span id="cb28-617"><a href="#cb28-617" aria-hidden="true" tabindex="-1"></a>will link your object files with the files of this library to</span>
<span id="cb28-618"><a href="#cb28-618" aria-hidden="true" tabindex="-1"></a>produce a single binary file for you.</span>
<span id="cb28-619"><a href="#cb28-619" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-620"><a href="#cb28-620" aria-hidden="true" tabindex="-1"></a>In the example below, we are creating an executable file named <span class="in">`image_filter`</span>,</span>
<span id="cb28-621"><a href="#cb28-621" aria-hidden="true" tabindex="-1"></a>and, we are linking this executable file to the C Standard Library with the</span>
<span id="cb28-622"><a href="#cb28-622" aria-hidden="true" tabindex="-1"></a>method <span class="in">`linkLibC()`</span>, but we also are linking this executable file to the</span>
<span id="cb28-623"><a href="#cb28-623" aria-hidden="true" tabindex="-1"></a>C library <span class="in">`libpng`</span> that is currently installed in my system.</span>
<span id="cb28-624"><a href="#cb28-624" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-627"><a href="#cb28-627" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb28-628"><a href="#cb28-628" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb28-629"><a href="#cb28-629" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb28-630"><a href="#cb28-630" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn build(b: *std.Build) void {</span></span>
<span id="cb28-631"><a href="#cb28-631" aria-hidden="true" tabindex="-1"></a><span class="in">    const exe = b.addExecutable(.{</span></span>
<span id="cb28-632"><a href="#cb28-632" aria-hidden="true" tabindex="-1"></a><span class="in">        .name = "image_filter",</span></span>
<span id="cb28-633"><a href="#cb28-633" aria-hidden="true" tabindex="-1"></a><span class="in">        .root_source_file = b.path("src/main.zig"),</span></span>
<span id="cb28-634"><a href="#cb28-634" aria-hidden="true" tabindex="-1"></a><span class="in">        .target = target,</span></span>
<span id="cb28-635"><a href="#cb28-635" aria-hidden="true" tabindex="-1"></a><span class="in">        .optimize = optimize,</span></span>
<span id="cb28-636"><a href="#cb28-636" aria-hidden="true" tabindex="-1"></a><span class="in">    });</span></span>
<span id="cb28-637"><a href="#cb28-637" aria-hidden="true" tabindex="-1"></a><span class="in">    exe.linkLibC();</span></span>
<span id="cb28-638"><a href="#cb28-638" aria-hidden="true" tabindex="-1"></a><span class="in">    exe.linkSystemLibrary("png");</span></span>
<span id="cb28-639"><a href="#cb28-639" aria-hidden="true" tabindex="-1"></a><span class="in">    b.installArtifact(exe);</span></span>
<span id="cb28-640"><a href="#cb28-640" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-641"><a href="#cb28-641" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-642"><a href="#cb28-642" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-643"><a href="#cb28-643" aria-hidden="true" tabindex="-1"></a>If you are linking with a C library in your project, is generally a good idea</span>
<span id="cb28-644"><a href="#cb28-644" aria-hidden="true" tabindex="-1"></a>to also link your code with the C Standard Library. Because is very likely</span>
<span id="cb28-645"><a href="#cb28-645" aria-hidden="true" tabindex="-1"></a>that this C library uses some functionality of the C Standard Library at some point.</span>
<span id="cb28-646"><a href="#cb28-646" aria-hidden="true" tabindex="-1"></a>The same goes to C++ libraries. So, if you are linking with</span>
<span id="cb28-647"><a href="#cb28-647" aria-hidden="true" tabindex="-1"></a>C++ libraries, is a good idea to link your project with the C++</span>
<span id="cb28-648"><a href="#cb28-648" aria-hidden="true" tabindex="-1"></a>Standard Library by using the <span class="in">`linkLibCpp()`</span> method.</span>
<span id="cb28-649"><a href="#cb28-649" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-650"><a href="#cb28-650" aria-hidden="true" tabindex="-1"></a>On the order side, when you want to link with a local library,</span>
<span id="cb28-651"><a href="#cb28-651" aria-hidden="true" tabindex="-1"></a>you should use the <span class="in">`linkLibrary()`</span> method of a <span class="in">`Compile`</span> object.</span>
<span id="cb28-652"><a href="#cb28-652" aria-hidden="true" tabindex="-1"></a>This method expects to receive another <span class="in">`Compile`</span> object as input.</span>
<span id="cb28-653"><a href="#cb28-653" aria-hidden="true" tabindex="-1"></a>That is, another target object defined in your build script,</span>
<span id="cb28-654"><a href="#cb28-654" aria-hidden="true" tabindex="-1"></a>using either the <span class="in">`addStaticLibrary()`</span> or <span class="in">`addSharedLibrary()`</span> methods</span>
<span id="cb28-655"><a href="#cb28-655" aria-hidden="true" tabindex="-1"></a>which defines a library to be built.</span>
<span id="cb28-656"><a href="#cb28-656" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-657"><a href="#cb28-657" aria-hidden="true" tabindex="-1"></a>As we discussed earlier, a local library is a library</span>
<span id="cb28-658"><a href="#cb28-658" aria-hidden="true" tabindex="-1"></a>that is local to your project, and that is being built together</span>
<span id="cb28-659"><a href="#cb28-659" aria-hidden="true" tabindex="-1"></a>with your project. So, you need to create a target object in your build script</span>
<span id="cb28-660"><a href="#cb28-660" aria-hidden="true" tabindex="-1"></a>to build this local library. Then, you link the target objects of interest in your project,</span>
<span id="cb28-661"><a href="#cb28-661" aria-hidden="true" tabindex="-1"></a>with this target object that identifies this local library.</span>
<span id="cb28-662"><a href="#cb28-662" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-663"><a href="#cb28-663" aria-hidden="true" tabindex="-1"></a>Take a look at this example extracted from the build script of the <span class="co">[</span><span class="ot">`libxev` library</span><span class="co">](https://github.com/mitchellh/libxev/tree/main)</span><span class="ot">[^libxev2]</span>.</span>
<span id="cb28-664"><a href="#cb28-664" aria-hidden="true" tabindex="-1"></a>You can see in this snippet that</span>
<span id="cb28-665"><a href="#cb28-665" aria-hidden="true" tabindex="-1"></a>we are declaring a shared library file, from the <span class="in">`c_api.zig`</span></span>
<span id="cb28-666"><a href="#cb28-666" aria-hidden="true" tabindex="-1"></a>module. Then, later in the build script, we declare an</span>
<span id="cb28-667"><a href="#cb28-667" aria-hidden="true" tabindex="-1"></a>executable file named <span class="in">`"dynamic-binding-test"`</span>, which</span>
<span id="cb28-668"><a href="#cb28-668" aria-hidden="true" tabindex="-1"></a>links to this shared library that we defined earlier</span>
<span id="cb28-669"><a href="#cb28-669" aria-hidden="true" tabindex="-1"></a>in the script.</span>
<span id="cb28-670"><a href="#cb28-670" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-671"><a href="#cb28-671" aria-hidden="true" tabindex="-1"></a><span class="ot">[^libxev2]: &lt;https://github.com/mitchellh/libxev/tree/main&gt;</span></span>
<span id="cb28-672"><a href="#cb28-672" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-673"><a href="#cb28-673" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-676"><a href="#cb28-676" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb28-677"><a href="#cb28-677" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb28-678"><a href="#cb28-678" aria-hidden="true" tabindex="-1"></a><span class="in">const optimize = b.standardOptimizeOption(.{});</span></span>
<span id="cb28-679"><a href="#cb28-679" aria-hidden="true" tabindex="-1"></a><span class="in">const target = b.standardTargetOptions(.{});</span></span>
<span id="cb28-680"><a href="#cb28-680" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-681"><a href="#cb28-681" aria-hidden="true" tabindex="-1"></a><span class="in">const dynamic_lib = b.addSharedLibrary(.{</span></span>
<span id="cb28-682"><a href="#cb28-682" aria-hidden="true" tabindex="-1"></a><span class="in">    .name = dynamic_lib_name,</span></span>
<span id="cb28-683"><a href="#cb28-683" aria-hidden="true" tabindex="-1"></a><span class="in">    .root_source_file = b.path("src/c_api.zig"),</span></span>
<span id="cb28-684"><a href="#cb28-684" aria-hidden="true" tabindex="-1"></a><span class="in">    .target = target,</span></span>
<span id="cb28-685"><a href="#cb28-685" aria-hidden="true" tabindex="-1"></a><span class="in">    .optimize = optimize,</span></span>
<span id="cb28-686"><a href="#cb28-686" aria-hidden="true" tabindex="-1"></a><span class="in">});</span></span>
<span id="cb28-687"><a href="#cb28-687" aria-hidden="true" tabindex="-1"></a><span class="in">b.installArtifact(dynamic_lib);</span></span>
<span id="cb28-688"><a href="#cb28-688" aria-hidden="true" tabindex="-1"></a><span class="in">// ... more lines in the script</span></span>
<span id="cb28-689"><a href="#cb28-689" aria-hidden="true" tabindex="-1"></a><span class="in">const dynamic_binding_test = b.addExecutable(.{</span></span>
<span id="cb28-690"><a href="#cb28-690" aria-hidden="true" tabindex="-1"></a><span class="in">    .name = "dynamic-binding-test",</span></span>
<span id="cb28-691"><a href="#cb28-691" aria-hidden="true" tabindex="-1"></a><span class="in">    .target = target,</span></span>
<span id="cb28-692"><a href="#cb28-692" aria-hidden="true" tabindex="-1"></a><span class="in">    .optimize = optimize,</span></span>
<span id="cb28-693"><a href="#cb28-693" aria-hidden="true" tabindex="-1"></a><span class="in">});</span></span>
<span id="cb28-694"><a href="#cb28-694" aria-hidden="true" tabindex="-1"></a><span class="in">dynamic_binding_test.linkLibrary(dynamic_lib);</span></span>
<span id="cb28-695"><a href="#cb28-695" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-696"><a href="#cb28-696" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-697"><a href="#cb28-697" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-698"><a href="#cb28-698" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-699"><a href="#cb28-699" aria-hidden="true" tabindex="-1"></a><span class="fu">## Building C code {#sec-building-c-code}</span></span>
<span id="cb28-700"><a href="#cb28-700" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-701"><a href="#cb28-701" aria-hidden="true" tabindex="-1"></a>The <span class="in">`zig`</span> compiler comes with a C compiler embedded in it. In other words,</span>
<span id="cb28-702"><a href="#cb28-702" aria-hidden="true" tabindex="-1"></a>you can use the <span class="in">`zig`</span> compiler to build C projects. This C compiler is available</span>
<span id="cb28-703"><a href="#cb28-703" aria-hidden="true" tabindex="-1"></a>through the <span class="in">`cc`</span> command of the <span class="in">`zig`</span> compiler.</span>
<span id="cb28-704"><a href="#cb28-704" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-705"><a href="#cb28-705" aria-hidden="true" tabindex="-1"></a>As an example, let's use the famous <span class="co">[</span><span class="ot">FreeType library</span><span class="co">](https://freetype.org/)</span><span class="ot">[^freetype]</span>.</span>
<span id="cb28-706"><a href="#cb28-706" aria-hidden="true" tabindex="-1"></a>FreeType is one of the most widely used pieces of software in the world.</span>
<span id="cb28-707"><a href="#cb28-707" aria-hidden="true" tabindex="-1"></a>It's a C library designed to produce high-quality fonts. But it's also</span>
<span id="cb28-708"><a href="#cb28-708" aria-hidden="true" tabindex="-1"></a>heavily used in the industry to natively render text and fonts</span>
<span id="cb28-709"><a href="#cb28-709" aria-hidden="true" tabindex="-1"></a>in the screen of your computer.</span>
<span id="cb28-710"><a href="#cb28-710" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-711"><a href="#cb28-711" aria-hidden="true" tabindex="-1"></a>In this section, we are going to write a build script, piece by piece, that is capable</span>
<span id="cb28-712"><a href="#cb28-712" aria-hidden="true" tabindex="-1"></a>of building the FreeType project from source.</span>
<span id="cb28-713"><a href="#cb28-713" aria-hidden="true" tabindex="-1"></a>You can find the source code of this build script on the</span>
<span id="cb28-714"><a href="#cb28-714" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">`freetype-zig` repository</span><span class="co">](https://github.com/pedropark99/freetype-zig/tree/main)</span><span class="ot">[^freetype-zig]</span></span>
<span id="cb28-715"><a href="#cb28-715" aria-hidden="true" tabindex="-1"></a>available at GitHub.</span>
<span id="cb28-716"><a href="#cb28-716" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-717"><a href="#cb28-717" aria-hidden="true" tabindex="-1"></a><span class="ot">[^freetype]: &lt;https://freetype.org/&gt;</span></span>
<span id="cb28-718"><a href="#cb28-718" aria-hidden="true" tabindex="-1"></a><span class="ot">[^freetype-zig]: &lt;https://github.com/pedropark99/freetype-zig/tree/main&gt;</span></span>
<span id="cb28-719"><a href="#cb28-719" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-720"><a href="#cb28-720" aria-hidden="true" tabindex="-1"></a>After you download the source code of FreeType from the official website<span class="ot">[^freetype]</span>,</span>
<span id="cb28-721"><a href="#cb28-721" aria-hidden="true" tabindex="-1"></a>you can start writing the <span class="in">`build.zig`</span> module. We begin by defining the target object</span>
<span id="cb28-722"><a href="#cb28-722" aria-hidden="true" tabindex="-1"></a>that defines the binary file that we want to compile.</span>
<span id="cb28-723"><a href="#cb28-723" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-724"><a href="#cb28-724" aria-hidden="true" tabindex="-1"></a>As an example, I will build the project as a static library file using the <span class="in">`addStaticLibrary()`</span> method</span>
<span id="cb28-725"><a href="#cb28-725" aria-hidden="true" tabindex="-1"></a>to create the target object.</span>
<span id="cb28-726"><a href="#cb28-726" aria-hidden="true" tabindex="-1"></a>Also, since FreeType is a C library, I will also link the library</span>
<span id="cb28-727"><a href="#cb28-727" aria-hidden="true" tabindex="-1"></a>against <span class="in">`libc`</span> through the <span class="in">`linkLibC()`</span> method, to guarantee that any use</span>
<span id="cb28-728"><a href="#cb28-728" aria-hidden="true" tabindex="-1"></a>of the C Standard Library is covered in the compilation process.</span>
<span id="cb28-729"><a href="#cb28-729" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-730"><a href="#cb28-730" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-733"><a href="#cb28-733" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb28-734"><a href="#cb28-734" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb28-735"><a href="#cb28-735" aria-hidden="true" tabindex="-1"></a><span class="in">const target = b.standardTargetOptions(.{});</span></span>
<span id="cb28-736"><a href="#cb28-736" aria-hidden="true" tabindex="-1"></a><span class="in">const opti = b.standardOptimizeOption(.{});</span></span>
<span id="cb28-737"><a href="#cb28-737" aria-hidden="true" tabindex="-1"></a><span class="in">const lib = b.addStaticLibrary(.{</span></span>
<span id="cb28-738"><a href="#cb28-738" aria-hidden="true" tabindex="-1"></a><span class="in">    .name = "freetype",</span></span>
<span id="cb28-739"><a href="#cb28-739" aria-hidden="true" tabindex="-1"></a><span class="in">    .optimize = opti,</span></span>
<span id="cb28-740"><a href="#cb28-740" aria-hidden="true" tabindex="-1"></a><span class="in">    .target = target,</span></span>
<span id="cb28-741"><a href="#cb28-741" aria-hidden="true" tabindex="-1"></a><span class="in">});</span></span>
<span id="cb28-742"><a href="#cb28-742" aria-hidden="true" tabindex="-1"></a><span class="in">lib.linkLibC();</span></span>
<span id="cb28-743"><a href="#cb28-743" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-744"><a href="#cb28-744" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-745"><a href="#cb28-745" aria-hidden="true" tabindex="-1"></a><span class="fu">### Creating C compiler flags</span></span>
<span id="cb28-746"><a href="#cb28-746" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-747"><a href="#cb28-747" aria-hidden="true" tabindex="-1"></a>Compiler flags are also known as "compiler options" by many programmers,</span>
<span id="cb28-748"><a href="#cb28-748" aria-hidden="true" tabindex="-1"></a>or also, as "command options" in the GCC official documentation.</span>
<span id="cb28-749"><a href="#cb28-749" aria-hidden="true" tabindex="-1"></a>It's fair to also call them as the "command-line arguments" of the C compiler.</span>
<span id="cb28-750"><a href="#cb28-750" aria-hidden="true" tabindex="-1"></a>In general, we use compiler flags to turn on (or turn off) some features from the compiler,</span>
<span id="cb28-751"><a href="#cb28-751" aria-hidden="true" tabindex="-1"></a>or to tweak the compilation process to fit the needs of our project.</span>
<span id="cb28-752"><a href="#cb28-752" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-753"><a href="#cb28-753" aria-hidden="true" tabindex="-1"></a>In build scripts written in Zig, we normally list the C compiler flags to be used in the compilation process</span>
<span id="cb28-754"><a href="#cb28-754" aria-hidden="true" tabindex="-1"></a>in a simple array, like in the example below.</span>
<span id="cb28-755"><a href="#cb28-755" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-758"><a href="#cb28-758" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb28-759"><a href="#cb28-759" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb28-760"><a href="#cb28-760" aria-hidden="true" tabindex="-1"></a><span class="in">const c_flags = [_][]const u8{</span></span>
<span id="cb28-761"><a href="#cb28-761" aria-hidden="true" tabindex="-1"></a><span class="in">    "-Wall",</span></span>
<span id="cb28-762"><a href="#cb28-762" aria-hidden="true" tabindex="-1"></a><span class="in">    "-Wextra",</span></span>
<span id="cb28-763"><a href="#cb28-763" aria-hidden="true" tabindex="-1"></a><span class="in">    "-Werror",</span></span>
<span id="cb28-764"><a href="#cb28-764" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb28-765"><a href="#cb28-765" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-766"><a href="#cb28-766" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-767"><a href="#cb28-767" aria-hidden="true" tabindex="-1"></a>In theory, there is nothing stopping you from using this array to add "include paths" (with the <span class="in">`-I`</span> flag)</span>
<span id="cb28-768"><a href="#cb28-768" aria-hidden="true" tabindex="-1"></a>or "library paths" (with the <span class="in">`-L`</span> flag) to the compilation process. But there are formal ways in Zig to</span>
<span id="cb28-769"><a href="#cb28-769" aria-hidden="true" tabindex="-1"></a>add these types of paths in the compilation process. Both are discussed in @sec-include-paths</span>
<span id="cb28-770"><a href="#cb28-770" aria-hidden="true" tabindex="-1"></a>and @sec-library-paths.</span>
<span id="cb28-771"><a href="#cb28-771" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-772"><a href="#cb28-772" aria-hidden="true" tabindex="-1"></a>Anyway, in Zig, we add C flags to the build process together with the C files that we want to compile, by using the</span>
<span id="cb28-773"><a href="#cb28-773" aria-hidden="true" tabindex="-1"></a><span class="in">`addCSourceFile()`</span> and <span class="in">`addCSourceFiles()`</span> methods. In the example above, we have just declared</span>
<span id="cb28-774"><a href="#cb28-774" aria-hidden="true" tabindex="-1"></a>the C flags that we want to use. But we haven't added them to the build process yet.</span>
<span id="cb28-775"><a href="#cb28-775" aria-hidden="true" tabindex="-1"></a>To do that, we also need to list the C files to be compiled.</span>
<span id="cb28-776"><a href="#cb28-776" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-777"><a href="#cb28-777" aria-hidden="true" tabindex="-1"></a><span class="fu">### Listing your C files</span></span>
<span id="cb28-778"><a href="#cb28-778" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-779"><a href="#cb28-779" aria-hidden="true" tabindex="-1"></a>The C files that contains "cross-platform" source code are listed in the <span class="in">`c_source_files`</span></span>
<span id="cb28-780"><a href="#cb28-780" aria-hidden="true" tabindex="-1"></a>object below. These are the C files that are included by default in every platform</span>
<span id="cb28-781"><a href="#cb28-781" aria-hidden="true" tabindex="-1"></a>supported by the FreeType library. Now, since the amount of C files in the FreeType library is big,</span>
<span id="cb28-782"><a href="#cb28-782" aria-hidden="true" tabindex="-1"></a>I have omitted the rest of the files in the code example below, for brevity purposes.</span>
<span id="cb28-783"><a href="#cb28-783" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-786"><a href="#cb28-786" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb28-787"><a href="#cb28-787" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb28-788"><a href="#cb28-788" aria-hidden="true" tabindex="-1"></a><span class="in">const c_source_files = [_][]const u8{</span></span>
<span id="cb28-789"><a href="#cb28-789" aria-hidden="true" tabindex="-1"></a><span class="in">    "src/autofit/autofit.c",</span></span>
<span id="cb28-790"><a href="#cb28-790" aria-hidden="true" tabindex="-1"></a><span class="in">    "src/base/ftbase.c",</span></span>
<span id="cb28-791"><a href="#cb28-791" aria-hidden="true" tabindex="-1"></a><span class="in">    // ... and many other C files.</span></span>
<span id="cb28-792"><a href="#cb28-792" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb28-793"><a href="#cb28-793" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-794"><a href="#cb28-794" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-795"><a href="#cb28-795" aria-hidden="true" tabindex="-1"></a>Now, in addition to "cross-platform" source code, we also have some C files in the FreeType project</span>
<span id="cb28-796"><a href="#cb28-796" aria-hidden="true" tabindex="-1"></a>that are platform-specific, meaning that, they contain source code that can only be compiled in specific platforms,</span>
<span id="cb28-797"><a href="#cb28-797" aria-hidden="true" tabindex="-1"></a>and, as a result, they are only included in the build process on these specific target platforms.</span>
<span id="cb28-798"><a href="#cb28-798" aria-hidden="true" tabindex="-1"></a>The objects that list these C files are exposed in the code example below.</span>
<span id="cb28-799"><a href="#cb28-799" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-802"><a href="#cb28-802" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb28-803"><a href="#cb28-803" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb28-804"><a href="#cb28-804" aria-hidden="true" tabindex="-1"></a><span class="in">const windows_c_source_files = [_][]const u8{</span></span>
<span id="cb28-805"><a href="#cb28-805" aria-hidden="true" tabindex="-1"></a><span class="in">    "builds/windows/ftdebug.c",</span></span>
<span id="cb28-806"><a href="#cb28-806" aria-hidden="true" tabindex="-1"></a><span class="in">    "builds/windows/ftsystem.c"</span></span>
<span id="cb28-807"><a href="#cb28-807" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb28-808"><a href="#cb28-808" aria-hidden="true" tabindex="-1"></a><span class="in">const linux_c_source_files = [_][]const u8{</span></span>
<span id="cb28-809"><a href="#cb28-809" aria-hidden="true" tabindex="-1"></a><span class="in">    "src/base/ftsystem.c",</span></span>
<span id="cb28-810"><a href="#cb28-810" aria-hidden="true" tabindex="-1"></a><span class="in">    "src/base/ftdebug.c"</span></span>
<span id="cb28-811"><a href="#cb28-811" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb28-812"><a href="#cb28-812" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-813"><a href="#cb28-813" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-814"><a href="#cb28-814" aria-hidden="true" tabindex="-1"></a>Now that we declared both the files that we want to include and the C compiler flags to be used,</span>
<span id="cb28-815"><a href="#cb28-815" aria-hidden="true" tabindex="-1"></a>we can add them to the target object that describes the FreeType library, by using the</span>
<span id="cb28-816"><a href="#cb28-816" aria-hidden="true" tabindex="-1"></a><span class="in">`addCSourceFile()`</span> and <span class="in">`addCSourceFiles()`</span> methods.</span>
<span id="cb28-817"><a href="#cb28-817" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-818"><a href="#cb28-818" aria-hidden="true" tabindex="-1"></a>Both of these functions are methods from a <span class="in">`Compile`</span> object (i.e., a target object).</span>
<span id="cb28-819"><a href="#cb28-819" aria-hidden="true" tabindex="-1"></a>The <span class="in">`addCSourceFile()`</span> method is capable of adding a single C file to the target object,</span>
<span id="cb28-820"><a href="#cb28-820" aria-hidden="true" tabindex="-1"></a>while the <span class="in">`addCSourceFiles()`</span> method is used to add multiple C files in a single command.</span>
<span id="cb28-821"><a href="#cb28-821" aria-hidden="true" tabindex="-1"></a>You might prefer to use <span class="in">`addCSourceFile()`</span> when you need to use different compiler flags</span>
<span id="cb28-822"><a href="#cb28-822" aria-hidden="true" tabindex="-1"></a>on specific C files in your project. But, if you can use the same compiler flags</span>
<span id="cb28-823"><a href="#cb28-823" aria-hidden="true" tabindex="-1"></a>across all C files, then, you will probably find <span class="in">`addCSourceFiles()`</span> a better choice.</span>
<span id="cb28-824"><a href="#cb28-824" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-825"><a href="#cb28-825" aria-hidden="true" tabindex="-1"></a>Notice that we are using the <span class="in">`addCSourceFiles()`</span> method in the example below,</span>
<span id="cb28-826"><a href="#cb28-826" aria-hidden="true" tabindex="-1"></a>to add both the C files and the C compiler flags. Also notice that we</span>
<span id="cb28-827"><a href="#cb28-827" aria-hidden="true" tabindex="-1"></a>are using the <span class="in">`os.tag`</span> that we learned about in @sec-detect-os, to add the platform-specific</span>
<span id="cb28-828"><a href="#cb28-828" aria-hidden="true" tabindex="-1"></a>C files.</span>
<span id="cb28-829"><a href="#cb28-829" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-832"><a href="#cb28-832" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb28-833"><a href="#cb28-833" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb28-834"><a href="#cb28-834" aria-hidden="true" tabindex="-1"></a><span class="in">const builtin = @import("builtin");</span></span>
<span id="cb28-835"><a href="#cb28-835" aria-hidden="true" tabindex="-1"></a><span class="in">lib.addCSourceFiles(</span></span>
<span id="cb28-836"><a href="#cb28-836" aria-hidden="true" tabindex="-1"></a><span class="in">    &amp;c_source_files, &amp;c_flags</span></span>
<span id="cb28-837"><a href="#cb28-837" aria-hidden="true" tabindex="-1"></a><span class="in">);</span></span>
<span id="cb28-838"><a href="#cb28-838" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-839"><a href="#cb28-839" aria-hidden="true" tabindex="-1"></a><span class="in">switch (builtin.target.os.tag) {</span></span>
<span id="cb28-840"><a href="#cb28-840" aria-hidden="true" tabindex="-1"></a><span class="in">    .windows =&gt; {</span></span>
<span id="cb28-841"><a href="#cb28-841" aria-hidden="true" tabindex="-1"></a><span class="in">        lib.addCSourceFiles(</span></span>
<span id="cb28-842"><a href="#cb28-842" aria-hidden="true" tabindex="-1"></a><span class="in">            &amp;windows_c_source_files,</span></span>
<span id="cb28-843"><a href="#cb28-843" aria-hidden="true" tabindex="-1"></a><span class="in">            &amp;c_flags</span></span>
<span id="cb28-844"><a href="#cb28-844" aria-hidden="true" tabindex="-1"></a><span class="in">        );</span></span>
<span id="cb28-845"><a href="#cb28-845" aria-hidden="true" tabindex="-1"></a><span class="in">    },</span></span>
<span id="cb28-846"><a href="#cb28-846" aria-hidden="true" tabindex="-1"></a><span class="in">    .linux =&gt; {</span></span>
<span id="cb28-847"><a href="#cb28-847" aria-hidden="true" tabindex="-1"></a><span class="in">        lib.addCSourceFiles(</span></span>
<span id="cb28-848"><a href="#cb28-848" aria-hidden="true" tabindex="-1"></a><span class="in">            &amp;linux_c_source_files,</span></span>
<span id="cb28-849"><a href="#cb28-849" aria-hidden="true" tabindex="-1"></a><span class="in">            &amp;c_flags</span></span>
<span id="cb28-850"><a href="#cb28-850" aria-hidden="true" tabindex="-1"></a><span class="in">        );</span></span>
<span id="cb28-851"><a href="#cb28-851" aria-hidden="true" tabindex="-1"></a><span class="in">    },</span></span>
<span id="cb28-852"><a href="#cb28-852" aria-hidden="true" tabindex="-1"></a><span class="in">    else =&gt; {},</span></span>
<span id="cb28-853"><a href="#cb28-853" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-854"><a href="#cb28-854" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-855"><a href="#cb28-855" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-856"><a href="#cb28-856" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-857"><a href="#cb28-857" aria-hidden="true" tabindex="-1"></a><span class="fu">### Defining C Macros</span></span>
<span id="cb28-858"><a href="#cb28-858" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-859"><a href="#cb28-859" aria-hidden="true" tabindex="-1"></a>C Macros are an essential part of the C programming language,</span>
<span id="cb28-860"><a href="#cb28-860" aria-hidden="true" tabindex="-1"></a>and they are commonly defined through the <span class="in">`-D`</span> flag from a C compiler.</span>
<span id="cb28-861"><a href="#cb28-861" aria-hidden="true" tabindex="-1"></a>In Zig, you can define a C Macro to be used in your build process</span>
<span id="cb28-862"><a href="#cb28-862" aria-hidden="true" tabindex="-1"></a>by using the <span class="in">`defineCMacro()`</span> method from the target object that</span>
<span id="cb28-863"><a href="#cb28-863" aria-hidden="true" tabindex="-1"></a>defines the binary file that you are building.</span>
<span id="cb28-864"><a href="#cb28-864" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-865"><a href="#cb28-865" aria-hidden="true" tabindex="-1"></a>In the example below, we are using the <span class="in">`lib`</span> object that we have defined</span>
<span id="cb28-866"><a href="#cb28-866" aria-hidden="true" tabindex="-1"></a>in the previous sections to define some C Macros used by the FreeType project</span>
<span id="cb28-867"><a href="#cb28-867" aria-hidden="true" tabindex="-1"></a>in the compilation process. These C Macros specify if FreeType</span>
<span id="cb28-868"><a href="#cb28-868" aria-hidden="true" tabindex="-1"></a>should (or should not) include functionalities from different</span>
<span id="cb28-869"><a href="#cb28-869" aria-hidden="true" tabindex="-1"></a>external libraries.</span>
<span id="cb28-870"><a href="#cb28-870" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-873"><a href="#cb28-873" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb28-874"><a href="#cb28-874" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb28-875"><a href="#cb28-875" aria-hidden="true" tabindex="-1"></a><span class="in">lib.defineCMacro("FT_DISABLE_ZLIB", "TRUE");</span></span>
<span id="cb28-876"><a href="#cb28-876" aria-hidden="true" tabindex="-1"></a><span class="in">lib.defineCMacro("FT_DISABLE_PNG", "TRUE");</span></span>
<span id="cb28-877"><a href="#cb28-877" aria-hidden="true" tabindex="-1"></a><span class="in">lib.defineCMacro("FT_DISABLE_HARFBUZZ", "TRUE");</span></span>
<span id="cb28-878"><a href="#cb28-878" aria-hidden="true" tabindex="-1"></a><span class="in">lib.defineCMacro("FT_DISABLE_BZIP2", "TRUE");</span></span>
<span id="cb28-879"><a href="#cb28-879" aria-hidden="true" tabindex="-1"></a><span class="in">lib.defineCMacro("FT_DISABLE_BROTLI", "TRUE");</span></span>
<span id="cb28-880"><a href="#cb28-880" aria-hidden="true" tabindex="-1"></a><span class="in">lib.defineCMacro("FT2_BUILD_LIBRARY", "TRUE");</span></span>
<span id="cb28-881"><a href="#cb28-881" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-882"><a href="#cb28-882" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-883"><a href="#cb28-883" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-884"><a href="#cb28-884" aria-hidden="true" tabindex="-1"></a><span class="fu">### Adding library paths {#sec-library-paths}</span></span>
<span id="cb28-885"><a href="#cb28-885" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-886"><a href="#cb28-886" aria-hidden="true" tabindex="-1"></a>Library paths are paths in your computer where the C compiler will look (or search) for</span>
<span id="cb28-887"><a href="#cb28-887" aria-hidden="true" tabindex="-1"></a>library files to link against your source code. In other words, when you use a library in your</span>
<span id="cb28-888"><a href="#cb28-888" aria-hidden="true" tabindex="-1"></a>C source code, and you ask the C compiler to link your source code against this library,</span>
<span id="cb28-889"><a href="#cb28-889" aria-hidden="true" tabindex="-1"></a>the C compiler will search for the binary files of this library across the paths listed</span>
<span id="cb28-890"><a href="#cb28-890" aria-hidden="true" tabindex="-1"></a>in this "library paths" set.</span>
<span id="cb28-891"><a href="#cb28-891" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-892"><a href="#cb28-892" aria-hidden="true" tabindex="-1"></a>These paths are platform specific, and, by default, the C compiler starts by looking at a</span>
<span id="cb28-893"><a href="#cb28-893" aria-hidden="true" tabindex="-1"></a>pre-defined set of places in your computer. But you can add more paths (or more places)</span>
<span id="cb28-894"><a href="#cb28-894" aria-hidden="true" tabindex="-1"></a>to this list. For example, you may have a library installed in a non-conventional place of your</span>
<span id="cb28-895"><a href="#cb28-895" aria-hidden="true" tabindex="-1"></a>computer, and you can make the C compiler "see" this "non-conventional place" by adding this path</span>
<span id="cb28-896"><a href="#cb28-896" aria-hidden="true" tabindex="-1"></a>to this list of pre-defined paths.</span>
<span id="cb28-897"><a href="#cb28-897" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-898"><a href="#cb28-898" aria-hidden="true" tabindex="-1"></a>In Zig, you can add more paths to this set by using the <span class="in">`addLibraryPath()`</span> method from your target object.</span>
<span id="cb28-899"><a href="#cb28-899" aria-hidden="true" tabindex="-1"></a>First, you defined a <span class="in">`LazyPath`</span> object, containing the path you want to add, then,</span>
<span id="cb28-900"><a href="#cb28-900" aria-hidden="true" tabindex="-1"></a>you provide this object as input to the <span class="in">`addLibraryPath()`</span> method, like in the example below:</span>
<span id="cb28-901"><a href="#cb28-901" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-904"><a href="#cb28-904" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb28-905"><a href="#cb28-905" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb28-906"><a href="#cb28-906" aria-hidden="true" tabindex="-1"></a><span class="in">const lib_path: std.Build.LazyPath = .{</span></span>
<span id="cb28-907"><a href="#cb28-907" aria-hidden="true" tabindex="-1"></a><span class="in">    .cwd_relative = "/usr/local/lib/"</span></span>
<span id="cb28-908"><a href="#cb28-908" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb28-909"><a href="#cb28-909" aria-hidden="true" tabindex="-1"></a><span class="in">lib.addLibraryPath(lib_path);</span></span>
<span id="cb28-910"><a href="#cb28-910" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-911"><a href="#cb28-911" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-912"><a href="#cb28-912" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-913"><a href="#cb28-913" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-914"><a href="#cb28-914" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-915"><a href="#cb28-915" aria-hidden="true" tabindex="-1"></a><span class="fu">### Adding include paths {#sec-include-paths}</span></span>
<span id="cb28-916"><a href="#cb28-916" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-917"><a href="#cb28-917" aria-hidden="true" tabindex="-1"></a>The preprocessor search path is a popular concept from the</span>
<span id="cb28-918"><a href="#cb28-918" aria-hidden="true" tabindex="-1"></a>C community, but it's also known by many C programmers as "include paths", because</span>
<span id="cb28-919"><a href="#cb28-919" aria-hidden="true" tabindex="-1"></a>the paths in this "search path" relate to the <span class="in">`#include`</span> statements found in the C files.</span>
<span id="cb28-920"><a href="#cb28-920" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-921"><a href="#cb28-921" aria-hidden="true" tabindex="-1"></a>Include paths are similar to library paths. They are a set of pre-defined places in your computer where</span>
<span id="cb28-922"><a href="#cb28-922" aria-hidden="true" tabindex="-1"></a>the C compiler will look for files during the compilation process. But instead of looking for</span>
<span id="cb28-923"><a href="#cb28-923" aria-hidden="true" tabindex="-1"></a>library files, the include paths are places where the compiler looks for header files included</span>
<span id="cb28-924"><a href="#cb28-924" aria-hidden="true" tabindex="-1"></a>in your C source code.</span>
<span id="cb28-925"><a href="#cb28-925" aria-hidden="true" tabindex="-1"></a>This is why many C programmers prefer to call these paths as the "preprocessor search path".</span>
<span id="cb28-926"><a href="#cb28-926" aria-hidden="true" tabindex="-1"></a>Because header files are processed during the preprocessor stage of the compilation</span>
<span id="cb28-927"><a href="#cb28-927" aria-hidden="true" tabindex="-1"></a>process.</span>
<span id="cb28-928"><a href="#cb28-928" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-929"><a href="#cb28-929" aria-hidden="true" tabindex="-1"></a>So, every header file that you include in your C source code, through a <span class="in">`#include`</span> statements needs to</span>
<span id="cb28-930"><a href="#cb28-930" aria-hidden="true" tabindex="-1"></a>be found somewhere, and the C compiler will search for this header file across the paths listed in this "include paths" set.</span>
<span id="cb28-931"><a href="#cb28-931" aria-hidden="true" tabindex="-1"></a>Include paths are added to the compilation process through the <span class="in">`-I`</span> flag.</span>
<span id="cb28-932"><a href="#cb28-932" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-933"><a href="#cb28-933" aria-hidden="true" tabindex="-1"></a>In Zig, you can add new paths to this pre-defined set of paths, by using the <span class="in">`addIncludePath()`</span> method</span>
<span id="cb28-934"><a href="#cb28-934" aria-hidden="true" tabindex="-1"></a>from your target object. This method also accepts a <span class="in">`LazyPath`</span> object as input.</span>
<span id="cb28-935"><a href="#cb28-935" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-938"><a href="#cb28-938" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb28-939"><a href="#cb28-939" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb28-940"><a href="#cb28-940" aria-hidden="true" tabindex="-1"></a><span class="in">const inc_path: std.Build.LazyPath = .{</span></span>
<span id="cb28-941"><a href="#cb28-941" aria-hidden="true" tabindex="-1"></a><span class="in">    .path = "./include"</span></span>
<span id="cb28-942"><a href="#cb28-942" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb28-943"><a href="#cb28-943" aria-hidden="true" tabindex="-1"></a><span class="in">lib.addIncludePath(inc_path);</span></span>
<span id="cb28-944"><a href="#cb28-944" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>