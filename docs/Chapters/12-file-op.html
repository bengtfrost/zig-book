<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Introduction to Zig - 13&nbsp; Filesystem and Input/Output (IO)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../Chapters/14-zig-c-interop.html" rel="next">
<link href="../Chapters/10-stack-project.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-6CHJXK4CEV"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-6CHJXK4CEV', { 'anonymize_ip': true});
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../Chapters/12-file-op.html"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Filesystem and Input/Output (IO)</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Introduction to Zig</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Welcome</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/01-zig-weird.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introducing Zig</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/03-structs.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Control flow, structs, modules and types</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/01-memory.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Memory and Allocators</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/01-base64.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Project 1 - Building a base64 encoder/decoder</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/02-debugging.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Debugging Zig applications</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/05-pointers.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Pointers and Optionals</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/04-http-server.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Project 2 - Building a HTTP Server from scratch</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/03-unittests.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Unit tests</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/07-build-system.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Build System</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/09-error-handling.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Error handling and unions</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/09-data-structures.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Data Structures</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/10-stack-project.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Project 3 - Building a stack data structure</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/12-file-op.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Filesystem and Input/Output (IO)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/14-zig-c-interop.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Zig interoperability with C</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/13-image-filter.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Project 4 - Developing an image filter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/14-threads.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Introducing threads and parallelism in Zig</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/15-vectors.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Introducing Vectors and SIMD</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#sec-io-basics" id="toc-sec-io-basics" class="nav-link active" data-scroll-target="#sec-io-basics"><span class="header-section-number">13.1</span> Input/Output basics</a>
  <ul class="collapse">
  <li><a href="#sec-writer-reader" id="toc-sec-writer-reader" class="nav-link" data-scroll-target="#sec-writer-reader"><span class="header-section-number">13.1.1</span> The writer and reader pattern</a></li>
  <li><a href="#sec-file-descriptor" id="toc-sec-file-descriptor" class="nav-link" data-scroll-target="#sec-file-descriptor"><span class="header-section-number">13.1.2</span> Introducing file descriptors</a></li>
  <li><a href="#the-standard-output" id="toc-the-standard-output" class="nav-link" data-scroll-target="#the-standard-output"><span class="header-section-number">13.1.3</span> The <em>standard output</em></a></li>
  <li><a href="#the-standard-input" id="toc-the-standard-input" class="nav-link" data-scroll-target="#the-standard-input"><span class="header-section-number">13.1.4</span> The <em>standard input</em></a></li>
  <li><a href="#the-standard-error" id="toc-the-standard-error" class="nav-link" data-scroll-target="#the-standard-error"><span class="header-section-number">13.1.5</span> The <em>standard error</em></a></li>
  </ul></li>
  <li><a href="#buffered-io" id="toc-buffered-io" class="nav-link" data-scroll-target="#buffered-io"><span class="header-section-number">13.2</span> Buffered IO</a>
  <ul class="collapse">
  <li><a href="#understanding-how-buffered-io-works" id="toc-understanding-how-buffered-io-works" class="nav-link" data-scroll-target="#understanding-how-buffered-io-works"><span class="header-section-number">13.2.1</span> Understanding how buffered IO works</a></li>
  <li><a href="#buffered-io-across-different-languages" id="toc-buffered-io-across-different-languages" class="nav-link" data-scroll-target="#buffered-io-across-different-languages"><span class="header-section-number">13.2.2</span> Buffered IO across different languages</a></li>
  <li><a href="#using-buffered-io-in-zig" id="toc-using-buffered-io-in-zig" class="nav-link" data-scroll-target="#using-buffered-io-in-zig"><span class="header-section-number">13.2.3</span> Using buffered IO in Zig</a></li>
  </ul></li>
  <li><a href="#filesystem-basics" id="toc-filesystem-basics" class="nav-link" data-scroll-target="#filesystem-basics"><span class="header-section-number">13.3</span> Filesystem basics</a>
  <ul class="collapse">
  <li><a href="#the-concept-of-current-working-directory-cwd" id="toc-the-concept-of-current-working-directory-cwd" class="nav-link" data-scroll-target="#the-concept-of-current-working-directory-cwd"><span class="header-section-number">13.3.1</span> The concept of current working directory (CWD)</a></li>
  <li><a href="#the-concept-of-paths" id="toc-the-concept-of-paths" class="nav-link" data-scroll-target="#the-concept-of-paths"><span class="header-section-number">13.3.2</span> The concept of paths</a></li>
  <li><a href="#path-wildcards" id="toc-path-wildcards" class="nav-link" data-scroll-target="#path-wildcards"><span class="header-section-number">13.3.3</span> Path wildcards</a></li>
  </ul></li>
  <li><a href="#the-cwd-handler" id="toc-the-cwd-handler" class="nav-link" data-scroll-target="#the-cwd-handler"><span class="header-section-number">13.4</span> The CWD handler</a></li>
  <li><a href="#file-operations" id="toc-file-operations" class="nav-link" data-scroll-target="#file-operations"><span class="header-section-number">13.5</span> File operations</a>
  <ul class="collapse">
  <li><a href="#sec-creating-files" id="toc-sec-creating-files" class="nav-link" data-scroll-target="#sec-creating-files"><span class="header-section-number">13.5.1</span> Creating files</a></li>
  <li><a href="#opening-files-and-appending-data-to-it" id="toc-opening-files-and-appending-data-to-it" class="nav-link" data-scroll-target="#opening-files-and-appending-data-to-it"><span class="header-section-number">13.5.2</span> Opening files and appending data to it</a></li>
  <li><a href="#deleting-files" id="toc-deleting-files" class="nav-link" data-scroll-target="#deleting-files"><span class="header-section-number">13.5.3</span> Deleting files</a></li>
  <li><a href="#copying-files" id="toc-copying-files" class="nav-link" data-scroll-target="#copying-files"><span class="header-section-number">13.5.4</span> Copying files</a></li>
  <li><a href="#read-the-docs" id="toc-read-the-docs" class="nav-link" data-scroll-target="#read-the-docs"><span class="header-section-number">13.5.5</span> Read the docs!</a></li>
  </ul></li>
  <li><a href="#sec-indicators" id="toc-sec-indicators" class="nav-link" data-scroll-target="#sec-indicators"><span class="header-section-number">13.6</span> Position indicators</a></li>
  <li><a href="#directory-operations" id="toc-directory-operations" class="nav-link" data-scroll-target="#directory-operations"><span class="header-section-number">13.7</span> Directory operations</a>
  <ul class="collapse">
  <li><a href="#iterating-through-the-files-in-a-directory" id="toc-iterating-through-the-files-in-a-directory" class="nav-link" data-scroll-target="#iterating-through-the-files-in-a-directory"><span class="header-section-number">13.7.1</span> Iterating through the files in a directory</a></li>
  <li><a href="#creating-new-directories" id="toc-creating-new-directories" class="nav-link" data-scroll-target="#creating-new-directories"><span class="header-section-number">13.7.2</span> Creating new directories</a></li>
  <li><a href="#deleting-directories" id="toc-deleting-directories" class="nav-link" data-scroll-target="#deleting-directories"><span class="header-section-number">13.7.3</span> Deleting directories</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion"><span class="header-section-number">13.8</span> Conclusion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title"><span id="sec-filesystem" class="quarto-section-identifier"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Filesystem and Input/Output (IO)</span></span></h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">View Source</a></li></ul></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>In this chapter we are going to discuss how to use the cross-platform structs and functions from the Zig Standard Library that can execute filesystem operations. Most of these functions and structs comes from the <code>std.fs</code> module.</p>
<p>We are also going to talk about Input/Output (also known as IO) operations in Zig. Most of these operations are made by using the structs and functions from <code>std.io</code> module, which defines file descriptors for the <em>standard channels</em> of your system (<code>stdout</code> and <code>stdin</code>), and also, functions to create and use I/O streams.</p>
<section id="sec-io-basics" class="level2" data-number="13.1">
<h2 data-number="13.1" class="anchored" data-anchor-id="sec-io-basics"><span class="header-section-number">13.1</span> Input/Output basics</h2>
<p>If you have some experience in a high-level language, you have certainly used these input and output functionalities before in this language. In other words, you certainly have been in a situation where you needed to sent some output to the user, or, to receive an input from the user.</p>
<p>For example, in Python we can receive some input from the user by using the <code>input()</code> built-in function. But we can also print (or “show”) some output to the user by using the <code>print()</code> built-in function. So yes, if you have programmed before in Python, you certainly have used these functions once before.</p>
<p>But do you know how these functions relate back to your operating system (OS)? How exactly they are interacting with the resources of your OS to receive or sent some input/output. In essence, these input/output functions from high-level languages are just abstractions over the <em>standard output</em> and <em>standard input</em> channels of your operating system.</p>
<p>This means that we receive an input, or send some output, through the operating system. It’s the OS that makes the bridge between the user and your program. Your program does not have a direct access to the user. It’s the OS that intermediates every message exchanged between your program and the user.</p>
<p>The <em>standard output</em> and <em>standard input</em> channels of your OS are commonly known as the <code>stdout</code> and <code>stdin</code> channels of your OS, respectively. In some contexts, they are also called the <em>standard output device</em> and the <em>standard input device</em>. As the name suggests, the <em>standard output</em> is the channel through which output flows, while the <em>standard input</em> is the channel in which input flows.</p>
<p>Furthermore, OS’s also normally create a dedicated channel for exchanging error messages, which is known as the <em>standard error</em> channel, or, the <code>stderr</code> channel. This is the channel to which error and warning messages are usually sent to. These are the messages that are normally displayed in red-like or orange-like colors into your terminal.</p>
<p>Normally, every OS (e.g.&nbsp;Windows, macOS, Linux, etc.) creates a dedicated and separate set of <em>standard output</em>, <em>standard error</em> and <em>standard input</em> channels for every single program (or process) that runs in your computer. This means that every program you write have a dedicated <code>stdin</code>, <code>stderr</code> and <code>stdout</code> that are separate from the <code>stdin</code>, <code>stderr</code> and <code>stdout</code> of other programs and processes that are currently running.</p>
<p>This is a behaviour from your OS. This does not come from the programming language that you are using. Because as I sad earlier, input and output in programming languages, especially in high-level ones, are just a simple abstraction over the <code>stdin</code>, <code>stderr</code> and <code>stdout</code> from your current OS. That is, your OS is the intermediary between every input/output operation made in your program, regardless of the programming language that you are using.</p>
<section id="sec-writer-reader" class="level3" data-number="13.1.1">
<h3 data-number="13.1.1" class="anchored" data-anchor-id="sec-writer-reader"><span class="header-section-number">13.1.1</span> The writer and reader pattern</h3>
<p>In Zig, there is a pattern around input/output (IO). I (the author of this book) don’t know if there is an official name for this pattern. But here, in this book, I will call it the “writer and reader pattern”. In essence, every IO operation in Zig is made through either a <code>GenericReader</code> or a <code>GenericWriter</code> object<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<p>These two data types come from the <code>std.io</code> module of the Zig Standard Library. As their names suggests, a <code>GenericReader</code> is an object that offers tools to read data from “something” (or “somewhere”), while a <code>GenericWriter</code> offers tools to write data into this “something”. This “something” might be different things: like a file that exists in your filesystem; or, it might be a network socket in your system<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>; or, a continuous stream of data, like a standard input device from your system, that might be constantly receiving new data from users, or, as another example, a live chat in a game that is constantly receiving and displaying new messages from the players of the game.</p>
<p>So, if you want to <strong>read</strong> data from something, or somewhere, it means that you need to use a <code>GenericReader</code> object. But if you need instead, to <strong>write</strong> data into this “something”, then, you need to use a <code>GenericWriter</code> object instead. Both of these objects are normally created from a file descriptor object. More specifically, through the <code>writer()</code> and <code>reader()</code> methods of this file descriptor object. If you are not familiar with this type of object, go to the next section.</p>
<p>Every <code>GenericWriter</code> object have methods like <code>print()</code>, which allows you to write/send a formatted string (i.e., this formatted string is like a <code>f</code> string in Python, or, similar to the <code>printf()</code> C function) into the “something” (file, socket, stream, etc.) that you are using. It also have a <code>writeAll()</code> method, which allows you to write a string, or, an array of bytes into the “something”.</p>
<p>Likewise, every <code>GenericReader</code> object have methods like <code>readAll()</code>, which allows you to read the data from the “something” (file, socket, stream, etc.) until it fills a particular array (i.e., a “buffer”) object. In other words, if you provide an array object of 300 <code>u8</code> values to <code>readAll()</code>, then, this method attempts to read 300 bytes of data from the “something”, and it stores them into the array object that you have provided.</p>
<p>We also have other methods, like the <code>readAtLeast()</code> method, which allows you to specify how many bytes exactly you want to read from the “something”. In more details, if you give the number <span class="math inline">\(n\)</span> as input to this method, then, it will attempt to read at least <span class="math inline">\(n\)</span> bytes of data from the “something”. The “something” might have less than <span class="math inline">\(n\)</span> bytes of data available for you to read, so, it’s not guaranteed that you will get precisely <span class="math inline">\(n\)</span> bytes as result.</p>
<p>Another useful method is <code>readUntilDelimiterOrEof()</code>. In this method, you specify a “delimiter character”. The idea is that this function will attempt to read as many bytes of data as possible from the “something”, until it encounters the end of the stream, or, it encounters the “delimiter character” that you have specified.</p>
<p>If you don’t know exactly how many bytes will come from the “something”, you may find the <code>readAllAlloc()</code> method useful. In essence, you provide an allocator object to this method, so that it can allocate more space if needed. As consequence, this method will try to read all bytes of the “something”, and, if it runs out of space at some point during the “reading process”, it uses the allocator object to allocate more space to continue reading the bytes. As result, this method returns a slice to the array object containing all the bytes read.</p>
<p>This is just a quick description of the methods present in these types of objects. But I recommend you to read the official docs, both for <a href="https://ziglang.org/documentation/master/std/#std.io.GenericWriter"><code>GenericWriter</code></a><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> and <a href="https://ziglang.org/documentation/master/std/#std.io.GenericReader"><code>GenericReader</code></a><a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. I also think it’s a good idea to read the source code of the modules in the Zig Standard Library that defines the methods present in these objects, which are the <a href="https://github.com/ziglang/zig/blob/master/lib/std/io/Reader.zig"><code>Reader.zig</code></a><a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> and <a href=""><code>Writer.zig</code></a><a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>.</p>
</section>
<section id="sec-file-descriptor" class="level3" data-number="13.1.2">
<h3 data-number="13.1.2" class="anchored" data-anchor-id="sec-file-descriptor"><span class="header-section-number">13.1.2</span> Introducing file descriptors</h3>
<p>A “file descriptor” object is a core component behind every IO operation that is made in any operating system (OS). Such object is an identifier for a particular input/output (IO) resource from your OS <span class="citation" data-cites="wiki_file_descriptor">(<a href="../references.html#ref-wiki_file_descriptor" role="doc-biblioref">Wikipedia 2024</a>)</span>. It describes and identifies this particular resource. An IO resource might be:</p>
<ul>
<li>an existing file in your filesystem.</li>
<li>an existing network socket.</li>
<li>other types of stream channels.</li>
<li>a pipeline (or just “pipe”) in your terminal<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>.</li>
</ul>
<p>From the bullet points listed above, we know that although the term “file” is present, a “file descriptor” might describe something more than just a file. This concept of a “file descriptor” comes from the Portable Operating System Interface (POSIX) API, which is a set of standards that guide how operating systems across the world should be implemented, to maintain compatibility between them.</p>
<p>A file descriptor not only identifies the input/output resource that you are using to receive or send some data, but it also describes where this resource is, and also, which IO mode this resource is currently using. For example, this IO resource might be using only the “read” IO mode, which means that this resource is open to “read operations”, while “write operations” are not authorized. These IO modes are essentially the modes that you provide to the argument <code>mode</code> from the <code>fopen()</code> C function, and also, from the <code>open()</code> Python built-in function.</p>
<p>In C, a “file descriptor” is a <code>FILE</code> pointer, but, in Zig, a file descriptor is a <code>File</code> object. This data type (<code>File</code>) is described in the <code>std.fs</code> module of the Zig Standard Library. We normally don’t create a <code>File</code> object directly in our Zig code. Instead, we normally get such object as result when we open an IO resource. In other words, we normally ask our OS to open a particular IO resource for us, and, if the OS do open successfully this IO resource, the OS normally handles back to us a file descriptor to this particular IO resource.</p>
<p>So you usually get a <code>File</code> object by using functions and methods from the Zig Standard Library that asks the OS to open some IO resource, like the <code>openFile()</code> method that opens a file in the filesystem. The <code>net.Stream</code> object that we have created in <a href="04-http-server.html#sec-create-socket" class="quarto-xref"><span>Section 7.4.1</span></a> is also a type of file descriptor object.</p>
</section>
<section id="the-standard-output" class="level3" data-number="13.1.3">
<h3 data-number="13.1.3" class="anchored" data-anchor-id="the-standard-output"><span class="header-section-number">13.1.3</span> The <em>standard output</em></h3>
<p>You already saw across this book, how can we access and use specifically the <code>stdout</code> in Zig to send some output to the user. For that, we use the <code>getStdOut()</code> function from the <code>std.io</code> module. This function returns a file descriptor that describes the <code>stdout</code> channel of your current OS. Through this file descriptor object, we can read from or write stuff to the <code>stdout</code> of our program.</p>
<p>Although we can read stuff recorded into the <code>stdout</code> channel, we normally only write to (or “print”) stuff into this channel. The reason is very similar to what we discussed at <a href="04-http-server.html#sec-read-http-message" class="quarto-xref"><span>Section 7.4.3</span></a>, when we were discussing what “reading from” versus “writing to” the connection object from our small HTTP Server project would mean.</p>
<p>When we write stuff into a channel, we are essentially sending data to the other end of this channel. In contrast, when we read stuff from this channel, we are essentially reading the data that was sent through this channel. Since the <code>stdout</code> is a channel to send output to the user, the key verb here is <strong>send</strong>. We want to send something to someone, and, as consequence, we want to <strong>write</strong> something into some channel.</p>
<p>That is why, when we use <code>getStdOut()</code>, most of the times, we also use the <code>writer()</code> method from the <code>stdout</code> file descriptor, to get access to a writer object that we can use to write stuff into this <code>stdout</code> channel. More specifically, this <code>writer()</code> method returns a <code>GenericWriter</code> object. One of the main methods of this <code>GenericWriter</code> object is the <code>print()</code> method that we have used before to write (or “print”) a formatted string into the <code>stdout</code> channel.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> stdout = std.io.getStdOut().writer();</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> stdout.writeAll(</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">"This message was written into stdout.</span><span class="sc">\n</span><span class="st">"</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    );</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>This message was written into stdout.</code></pre>
</div>
</div>
<p>This <code>GenericWriter</code> object is like any other generic writer object that you would normally get from a file descriptor object. So, the same methods from a generic writer object that you would use while writing files to the filesystem for example, you could also use them here, from the file descriptor object of <code>stdout</code>, and vice-versa.</p>
</section>
<section id="the-standard-input" class="level3" data-number="13.1.4">
<h3 data-number="13.1.4" class="anchored" data-anchor-id="the-standard-input"><span class="header-section-number">13.1.4</span> The <em>standard input</em></h3>
<p>You can access the <em>standard input</em> (i.e., <code>stdin</code>) in Zig by using the <code>getStdIn()</code> function from the <code>std.io</code> module. Like its brother (<code>getStdOut()</code>), this function also returns a file descriptor object that describes the <code>stdin</code> channel of your OS.</p>
<p>Because we want to receive some input from the user, the key verb here becomes <strong>receive</strong>, and, as consequence, we usually want to <strong>read</strong> data from the <code>stdin</code> channel, instead of writing data into it. So, we normally use the <code>reader()</code> method of the file descriptor object returned by <code>getStdIn()</code>, to get access to a <code>GenericReader</code> object that we can use to read data from <code>stdin</code>.</p>
<p>In the example below, we are creating a small buffer capable of holding 20 characters. Then, we try to read the data from the <code>stdin</code> with the <code>readUntilDelimiterOrEof()</code> method, and save this data into the <code>buffer</code> object. Also notice that we are reading the data from the <code>stdin</code> until we hit a new line character (<code>'\n'</code>).</p>
<p>If you execute this program, you will notice that it stops the execution, ands start to wait indefinitely for some input from the user. In other words, you need to type your name into the terminal, and then, you press Enter to send your name to <code>stdin</code>. After you send your name to <code>stdin</code>, the program reads this input, and continues with the execution, by printing the given name to <code>stdout</code>. In the example below, I typed my name (Pedro) into the terminal, and then, pressed Enter.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> stdout = std.io.getStdOut().writer();</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> stdin = std.io.getStdIn().reader();</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> stdout.writeAll(<span class="st">"Type your name</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> buffer: [<span class="dv">20</span>]<span class="dt">u8</span> = <span class="cn">undefined</span>;</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">@memset</span>(buffer[<span class="dv">0</span>..], <span class="dv">0</span>);</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    _ = <span class="kw">try</span> stdin.readUntilDelimiterOrEof(buffer[<span class="dv">0</span>..], <span class="ch">'\n'</span>);</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> stdout.print(<span class="st">"Your name is: {s}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span>buffer<span class="op">}</span>);</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>Type your name
Your name is: Pedro
</code></pre>
</section>
<section id="the-standard-error" class="level3" data-number="13.1.5">
<h3 data-number="13.1.5" class="anchored" data-anchor-id="the-standard-error"><span class="header-section-number">13.1.5</span> The <em>standard error</em></h3>
<p>The <em>standard error</em> (a.k.a. the <code>stderr</code>) works exactly the same as <code>stdout</code> and <code>stdin</code>. You just call the <code>getStdErr()</code> function from the <code>std.io</code> module, and you get the file descriptor to <code>stderr</code>. Ideally, you should write only error or warning messages to <code>stderr</code>, because this is the purpose of this channel.</p>
</section>
</section>
<section id="buffered-io" class="level2" data-number="13.2">
<h2 data-number="13.2" class="anchored" data-anchor-id="buffered-io"><span class="header-section-number">13.2</span> Buffered IO</h2>
<p>As we described in <a href="#sec-io-basics" class="quarto-xref"><span>Section 13.1</span></a>, input/output (IO) operations are made directly by the operating system. It’s the OS that manages the IO resource that you want to use for your IO operations. The consequence of this fact is that IO operations are heavily based on system calls (i.e., calling the operating system directly).</p>
<p>Just to be clear, there is nothing particularly wrong with system calls. We use them all the time on any serious codebase written in any low-level programming language. However, system calls are always orders of magnitude slower than many different types of operations.</p>
<p>So is perfectly fine to use a system call once in a while. But when these system calls are used often, you can clearly notice most of the time the loss of performance in your application. So, the good rule of thumb is to use a system call only when it’s needed, and also, only in infrequent situations, to reduce the number of system calls performed to a minimum.</p>
<section id="understanding-how-buffered-io-works" class="level3" data-number="13.2.1">
<h3 data-number="13.2.1" class="anchored" data-anchor-id="understanding-how-buffered-io-works"><span class="header-section-number">13.2.1</span> Understanding how buffered IO works</h3>
<p>Buffered IO is a strategy to achieve better performance. It’s used to reduce the number of system calls made by IO operations, and, as consequence, achieve a much higher performance. In <a href="#fig-unbuffered-io" class="quarto-xref">Figure&nbsp;<span>13.1</span></a> and <a href="#fig-buffered-io" class="quarto-xref">Figure&nbsp;<span>13.2</span></a> you can find two different diagrams which presents the difference between read operations performed in an unbuffered IO environment versus a buffered IO environment.</p>
<p>To give a better context to these diagrams, let’s suppose that we have a text file that contains the famous Lorem ipsum text<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> in our filesystem. Let’s also suppose that these diagrams in <a href="#fig-unbuffered-io" class="quarto-xref">Figure&nbsp;<span>13.1</span></a> and <a href="#fig-buffered-io" class="quarto-xref">Figure&nbsp;<span>13.2</span></a> are showing the read operations that we are performing to read the Lorem ipsum text from this text file. The first thing you will notice when looking at these diagrams, is that in an unbuffered environment the read operations leads to many system calls. More precisely, in the diagram exposed in <a href="#fig-unbuffered-io" class="quarto-xref">Figure&nbsp;<span>13.1</span></a> we get one system call per each byte that we read from the text file. On the other hand, in <a href="#fig-buffered-io" class="quarto-xref">Figure&nbsp;<span>13.2</span></a> we have only one system call at the very beginning.</p>
<p>When we use a buffered IO system, at the first read operation we perform, instead of sending one single byte directly to our program, the OS first sends a chunk of bytes from the file to a buffer object (i.e., an array). This chunk of bytes are cached/stored inside this buffer object.</p>
<p>Therefore, from now on, for every new read operation that you perform, instead of making a new system call to ask for the next byte in the file to the OS, this read operation is redirected to the buffer object, that have this next byte already cached and ready to go.</p>
<div id="fig-unbuffered-io" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-unbuffered-io-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./../Figures/unbuffered-io.png" class="img-fluid figure-img" style="width:60.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-unbuffered-io-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;13.1: Unbuffered IO
</figcaption>
</figure>
</div>
<div id="fig-buffered-io" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-buffered-io-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./../Figures/buffered-io.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-buffered-io-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;13.2: Buffered IO
</figcaption>
</figure>
</div>
<p>This is the basic logic behind buffered IO systems. The size of the buffer object depends on multiple factors. But it’s usually equal to the size of a full page of memory (4096 bytes). If we follow this logic, then, the OS reads the first 4096 bytes of the file and caches it into the buffer object. As long as your program does not consume all of these 4096 bytes from the buffer, you will not create new system calls.</p>
<p>However, as soon as you consume all of these 4096 bytes from the buffer, it means that there is no bytes left in the buffer. In this situation, a new system call is made to ask the OS to send the next 4096 bytes in the file, and once again, these bytes are cached into the buffer object, and the cycle starts once again.</p>
</section>
<section id="buffered-io-across-different-languages" class="level3" data-number="13.2.2">
<h3 data-number="13.2.2" class="anchored" data-anchor-id="buffered-io-across-different-languages"><span class="header-section-number">13.2.2</span> Buffered IO across different languages</h3>
<p>IO operations made through a <code>FILE</code> pointer in C are buffered by default, so, at least in C, you don’t need to worry about this subject. But in contrast, IO operations in both Rust and Zig are not buffered depending on which functions from the standard libraries that you are using.</p>
<p>For example, in Rust, buffered IO is implemented through the <code>BufReader</code> and <code>BufWriter</code> structs, while in Zig, it’s implemented through the <code>BufferedReader</code> and <code>BufferedWriter</code> structs. So any IO operation that you perform through the <code>GenericWriter</code> and <code>GenericReader</code> objects that I presented in <a href="#sec-writer-reader" class="quarto-xref"><span>Section 13.1.1</span></a> are not buffered, which means that these objects might create a lot of system calls depending on the situation.</p>
</section>
<section id="using-buffered-io-in-zig" class="level3" data-number="13.2.3">
<h3 data-number="13.2.3" class="anchored" data-anchor-id="using-buffered-io-in-zig"><span class="header-section-number">13.2.3</span> Using buffered IO in Zig</h3>
<p>Using buffered IO in Zig is actually very easy. All you have to do is to just give the <code>GenericWriter</code> object to the <code>bufferedWriter()</code> function, or, to give the <code>GenericReader</code> object to the <code>bufferedReader()</code> function. These functions come from the <code>std.io</code> module, and they will construct the <code>BufferedWriter</code> or <code>BufferedReader</code> object for you.</p>
<p>After you create this new <code>BufferedWriter</code> or <code>BufferedReader</code> object, you can call the <code>writer()</code> or <code>reader()</code> method of this new object, to get access to a new (and buffered) generic reader or generic writer.</p>
<p>Let’s describe the process once again. Every time that you have a file descriptor object, you first get the generic writer or generic reader object from it, by calling the <code>writer()</code> or <code>reader()</code> methods of this file descriptor object. Then, you provide this generic writer or generic reader to the <code>bufferedWriter()</code> or <code>bufferedReader()</code> function, which creates a new <code>BufferedWriter</code> or <code>BufferedReader</code> object. Then, you call the <code>writer()</code> or <code>reader()</code> methods of this buffered writer or buffered reader object, which gives you access to a generic writer or a generic reader object that is buffered.</p>
<p>Take this program as an example. This program is demonstrating the process exposed in <a href="#fig-buffered-io" class="quarto-xref">Figure&nbsp;<span>13.2</span></a>. We are simply opening a text file that contains the Lorem ipsum text, and then, we create a buffered IO reader object at <code>bufreader</code>, and we use this <code>bufreader</code> object to read the contents of this file into a buffer object, then, we end the program by printing this buffer to <code>stdout</code>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> file = <span class="kw">try</span> std.fs.cwd().openFile(</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">"ZigExamples/file-io/lorem.txt"</span>, .<span class="op">{}</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>);</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">defer</span> file.close();</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> buffered = std.io.bufferedReader(file.reader());</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> bufreader = buffered.reader();</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> buffer: [<span class="dv">1000</span>]<span class="dt">u8</span> = <span class="cn">undefined</span>;</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="bu">@memset</span>(buffer[<span class="dv">0</span>..], <span class="dv">0</span>);</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>_ = <span class="kw">try</span> bufreader.readUntilDelimiterOrEof(</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    buffer[<span class="dv">0</span>..], <span class="ch">'\n'</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>);</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="kw">try</span> stdout.print(<span class="st">"{s}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span>buffer<span class="op">}</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>Lorem ipsum dolor sit amet, consectetur
adipiscing elit. Sed tincidunt erat sed nulla ornare, nec
aliquet ex laoreet. Ut nec rhoncus nunc. Integer magna metus,
ultrices eleifend porttitor ut, finibus ut tortor. Maecenas
sapien justo, finibus tincidunt dictum ac, semper et lectus.
Vivamus molestie egestas orci ac viverra. Pellentesque nec
arcu facilisis, euismod eros eu, sodales nisl. Ut egestas
sagittis arcu, in accumsan sapien rhoncus sit amet. Aenean
neque lectus, imperdiet ac lobortis a, ullamcorper sed massa.
Nullam porttitor porttitor erat nec dapibus. Ut vel dui nec
nulla vulputate molestie eget non nunc. Ut commodo luctus ipsum,
in finibus libero feugiat eget. Etiam vel ante at urna tincidunt
posuere sit amet ut felis. Maecenas finibus suscipit tristique.
Donec viverra non sapien id suscipit.</code></pre>
<p>Despite being a buffered IO reader, this <code>bufreader</code> object is similar to any other <code>GenericReader</code> object, and have the exact same methods. So, although these two types of objects perform very different IO operations, they have the same interface, so you, the programmer, can interchangeably use them without the need to change anything in your source code. So a buffered IO reader or a buffered IO writer objects have the same methods than its generic and unbuffered brothers, i.e., the generic reader and generic writer objects that I presented in <a href="#sec-writer-reader" class="quarto-xref"><span>Section 13.1.1</span></a>.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>In general, you should always use a buffered IO reader or a buffered IO writer object to perform IO operations in Zig. Because they deliver better performance to your IO operations.</p>
</div>
</div>
</section>
</section>
<section id="filesystem-basics" class="level2" data-number="13.3">
<h2 data-number="13.3" class="anchored" data-anchor-id="filesystem-basics"><span class="header-section-number">13.3</span> Filesystem basics</h2>
<p>Now that we have discussed the basics around Input/Output operations in Zig, we need to talk about the basics around filesystems, which is another core part of any operating system. Also, filesystems are related to input/output, because the files that we store and create in our computer are considered an IO resource, as we described in <a href="#sec-file-descriptor" class="quarto-xref"><span>Section 13.1.2</span></a>.</p>
<section id="the-concept-of-current-working-directory-cwd" class="level3" data-number="13.3.1">
<h3 data-number="13.3.1" class="anchored" data-anchor-id="the-concept-of-current-working-directory-cwd"><span class="header-section-number">13.3.1</span> The concept of current working directory (CWD)</h3>
<p>The working directory is the folder on your computer where you are currently rooted at. In other words, it’s the folder that your program is currently looking at. Therefore, whenever you are executing a program, this program is always working with a specific folder on your computer. It’s always in this folder that the program will initially look for the files you require, and it’s also in this folder that the program will initially save all the files you ask it to save.</p>
<p>The working directory is determined by the folder from which you invoke your program in the terminal. In other words, if you are in the terminal of your OS, and you execute a binary file (i.e., a program) from this terminal, the folder to which your terminal is pointing at is the current working directory of your program that is being executed.</p>
<p>In <a href="#fig-cwd" class="quarto-xref">Figure&nbsp;<span>13.3</span></a> we have an example of me executing a program from the terminal. We are executing the program outputted by the <code>zig</code> compiler by compiling the Zig module named <code>hello.zig</code>. The CWD in this case is the <code>zig-book</code> folder. In other words, while the <code>hello.zig</code> program is executing, it will be looking at the <code>zig-book</code> folder, and any file operation that we perform inside this program, will be using this <code>zig-book</code> folder as the “starting point”, or, as the “central focus”.</p>
<div id="fig-cwd" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-cwd-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./../Figures/cwd.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-cwd-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;13.3: Executing a program from the terminal
</figcaption>
</figure>
</div>
<p>Just because we are rooted inside a particular folder (in the case of <a href="#fig-cwd" class="quarto-xref">Figure&nbsp;<span>13.3</span></a>, the <code>zig-book</code> folder) of our computer, it doesn’t mean that we cannot access or write resources in other locations of our computer. The current working directory (CWD) mechanism just defines where your program will look first for the files you ask for. This does not prevent you from accessing files that are located elsewhere on your computer. However, to access any file that is in a folder other than your current working directory, you must provide a path to that file or folder.</p>
</section>
<section id="the-concept-of-paths" class="level3" data-number="13.3.2">
<h3 data-number="13.3.2" class="anchored" data-anchor-id="the-concept-of-paths"><span class="header-section-number">13.3.2</span> The concept of paths</h3>
<p>A path is essentially a location. It points to a location in your filesystem. We use paths to describe the location of files and folders in our computer. One important aspect about paths is that they are always written inside strings, i.e., they are always provided as text values.</p>
<p>There are two types of paths that you can provide to any program in any OS: a relative path, or an absolute path. Absolute paths are paths that start at the root of your filesystem, and go all the way to the file name or the specific folder that you are referring to. This type of path is called absolute, because it points to an unique and absolute location on your computer. That is, there is no other existing location on your computer that corresponds to this path. It’s an unique identifier.</p>
<p>In Windows, an absolute path is a path that starts with a hard disk identifier (e.g.&nbsp;<code>C:/Users/pedro</code>). On the other hand, absolute paths in Linux and macOS, are paths that start with a forward slash character (e.g.&nbsp;<code>/usr/local/bin</code>). Notice that a path is composed by “segments”. Each segment is connected to each other by a slash character (<code>\</code> or <code>/</code>). On Windows, the backward slash (<code>\</code>) is normally used to connect the path segments. While on Linux and macOS, the forward slash (<code>/</code>) is the character used to connect path segments.</p>
<p>A relative path is a path that start at the CWD. In other words, a relative path is “relative to the CWD”. The path used to access the <code>hello.zig</code> file in <a href="#fig-cwd" class="quarto-xref">Figure&nbsp;<span>13.3</span></a> is an example of a relative path. This path is reproduced below. This path begins at the CWD, which in the context of <a href="#fig-cwd" class="quarto-xref">Figure&nbsp;<span>13.3</span></a>, is the <code>zig-book</code> folder, then, it goes to the <code>ZigExamples</code> folder, then, into <code>zig-basics</code>, then, to the <code>hello.zig</code> file.</p>
<pre><code>ZigExamples/zig-basics/hello_world.zig</code></pre>
</section>
<section id="path-wildcards" class="level3" data-number="13.3.3">
<h3 data-number="13.3.3" class="anchored" data-anchor-id="path-wildcards"><span class="header-section-number">13.3.3</span> Path wildcards</h3>
<p>When providing paths, especially relative paths, you have the option of using a <em>wildcard</em>. There are two commonly used <em>wildcards</em> in paths, which are “one period” (.) and “two periods” (..). In other words, these two specific characters have special meanings when used in paths, and can be used on any operating system (Mac, Windows, Linux, etc.). That is, they are “cross platform”.</p>
<p>The “one period” represents an alias for the current directory. This means that the relative paths <code>"./Course/Data/covid.csv"</code> and <code>"Course/Data/covid.csv"</code> are equivalent. On the other hand, the “two periods” refers to the previous directory. For example, the path <code>"Course/.."</code> is equivalent to the path <code>"."</code>, that is, the current working directory.</p>
<p>Therefore, the path <code>"Course/.."</code> refers to the folder before the <code>Course</code> folder. As another example, the path <code>"src/writexml/../xml.cpp"</code> refers to the file <code>xml.cpp</code> that is inside the folder before the <code>writexml</code> folder, which in this example is the <code>src</code> folder. Therefore, this path is equivalent to <code>"src/xml.cpp"</code>.</p>
</section>
</section>
<section id="the-cwd-handler" class="level2" data-number="13.4">
<h2 data-number="13.4" class="anchored" data-anchor-id="the-cwd-handler"><span class="header-section-number">13.4</span> The CWD handler</h2>
<p>In Zig, filesystem operations are usually made through a directory handler object. A directory handler in Zig is an object of type <code>Dir</code>, which is an object that describes a particular folder in the filesystem of our computer. You normally create a <code>Dir</code> object, by calling the <code>std.fs.cwd()</code> function. This function returns a <code>Dir</code> object that points to (or, that describes) the current working directory (CWD).</p>
<p>Through this <code>Dir</code> object, you can create new files, or modify, or read existing ones that are inside your CWD. In other words, a <code>Dir</code> object is the main entrypoint in Zig to perform multiple types of filesystem operations. In the example below, we are creating this <code>Dir</code> object, and storing it inside the <code>cwd</code> object. Although we are not using this object at this code example, we are going to use it a lot over the next examples.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> cwd = std.fs.cwd();</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>_ = cwd;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="file-operations" class="level2" data-number="13.5">
<h2 data-number="13.5" class="anchored" data-anchor-id="file-operations"><span class="header-section-number">13.5</span> File operations</h2>
<section id="sec-creating-files" class="level3" data-number="13.5.1">
<h3 data-number="13.5.1" class="anchored" data-anchor-id="sec-creating-files"><span class="header-section-number">13.5.1</span> Creating files</h3>
<p>We create new files by using the <code>createFile()</code> method from the <code>Dir</code> object. Just provide the name of the file that you want to create, and this function will do the necessary steps to create such file. You can also provide a relative path to this function, and it will create the file by following this path, which is relative to the CWD.</p>
<p>This function might return an error, so, you should use <code>try</code>, <code>catch</code>, or any of the other methods presented in <a href="09-error-handling.html" class="quarto-xref"><span>Chapter 10</span></a> to handle the possible error. But if everything goes well, this <code>createFile()</code> method returns a file descriptor object (i.e., a <code>File</code> object) as result, through which you can add content to the file with the IO operations that I presented before.</p>
<p>Take this code example below. In this example, we are creating a new text file named <code>foo.txt</code>. If the function <code>createFile()</code> succeeds, the object named <code>file</code> will contain a file descriptor object, which we can use to write (or add) new content to the file, like we do in this example, by using a buffered writer object to write a new line of text to the file.</p>
<p>Now, a quick note, when we create a file descriptor object in C, by using a C function like <code>fopen()</code>, we must always close the file at the end of our program, or, as soon as we complete all operations that we wanted to perform on the file. In Zig, this is no different. So everytime we create a new file, this file remains “open”, waiting for some operation to be performed. As soon as we are done with it, we always have to close this file, to free the resources associated with it. In Zig, we do this by calling the method <code>close()</code> from the file descriptor object.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> cwd = std.fs.cwd();</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> file = <span class="kw">try</span> cwd.createFile(<span class="st">"foo.txt"</span>, .<span class="op">{}</span>);</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Don't forget to close the file at the end.</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="kw">defer</span> file.close();</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Do things with the file ...</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> fw = file.writer();</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>_ = <span class="kw">try</span> fw.writeAll(</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Writing this line to the file</span><span class="sc">\n</span><span class="st">"</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>So, in this example we not only have created a file into the filesystem, but we also wrote some data into this file, using the file descriptor object returned by <code>createFile()</code>. If the file that you are trying to create already exists in your filesystem, this <code>createFile()</code> call will overwrite the contents of the file, or, in other words, it will in erase all the contents of the existing file.</p>
<p>If you don’t want this to happen, meaning, that you don’t want to overwrite the contents of the existing file, but you want to write data to this file anyway (i.e., you want to append data to the file), you should use the <code>openFile()</code> method from the <code>Dir</code> object.</p>
<p>Another important aspect about <code>createFile()</code> is that this method creates a file that is not open to read operations by default. It means that you cannot read this file. You are not allowed to. So for example, you might want to write some stuff into this file at the beginning of the execution of your program. Then, at a future point in your program you might need to read what you wrote in this file. If you try to read data from this file, you will likely get a <code>NotOpenForReading</code> error as result.</p>
<p>But how can you overcome this barrier? How can you create a file that is open to read operations? All you have to do, is to set the <code>read</code> flag to true in the second argument of <code>createFile()</code>. When you set this flag to true, then the file gets create with “read permissions”, and, as consequence, a program like this one below becomes valid:</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> cwd = std.fs.cwd();</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> file = <span class="kw">try</span> cwd.createFile(</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"foo.txt"</span>,</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    .<span class="op">{</span> .read = <span class="cn">true</span> <span class="op">}</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>);</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="kw">defer</span> file.close();</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> fw = file.writer();</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>_ = <span class="kw">try</span> fw.writeAll(<span class="st">"We are going to read this line</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> buffer: [<span class="dv">300</span>]<span class="dt">u8</span> = <span class="cn">undefined</span>;</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="bu">@memset</span>(buffer[<span class="dv">0</span>..], <span class="dv">0</span>);</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="kw">try</span> file.seekTo(<span class="dv">0</span>);</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> fr = file.reader();</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>_ = <span class="kw">try</span> fr.readAll(buffer[<span class="dv">0</span>..]);</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a><span class="kw">try</span> stdout.print(<span class="st">"{s}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span>buffer<span class="op">}</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>We are going to read this line</code></pre>
<p>If you are not familiar with position indicators, you might not recognize the method <code>seekTo()</code>. If that is your case, do not worry, we are going to talk more about this method in <a href="#sec-indicators" class="quarto-xref"><span>Section 13.6</span></a>. But essentially this method is moving the position indicator back to the beginning of the file, so that we can read the contents of the file from the beginning.</p>
</section>
<section id="opening-files-and-appending-data-to-it" class="level3" data-number="13.5.2">
<h3 data-number="13.5.2" class="anchored" data-anchor-id="opening-files-and-appending-data-to-it"><span class="header-section-number">13.5.2</span> Opening files and appending data to it</h3>
<p>Opening files is easy. Just use the <code>openFile()</code> method instead of <code>createFile()</code>. In the first argument of <code>openFile()</code> you provide the path to the file that you want to open. Then, on the second argument you provide the flags (or, the options) that dictates how the file is opened.</p>
<p>You can see the full list of options for <code>openFile()</code> by visiting the documentation for <a href="https://ziglang.org/documentation/master/std/#std.fs.File.OpenFlags"><code>OpenFlags</code></a><a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>. But the main flag that you will most certainly use is the <code>mode</code> flag. This flag specifies the IO mode that the file will be using when it gets opened. There are three IO modes, or, three values that you can provide to this flag, which are:</p>
<ul>
<li><code>read_only</code>, allows only read operations on the file. All write operations are blocked.</li>
<li><code>write_only</code>, allows only write operations on the file. All read operations are blocked.</li>
<li><code>read_write</code>, allows both write and read operations on the file.</li>
</ul>
<p>These modes are similar to the modes that you provide to the <code>mode</code> argument of the <code>open()</code> Python built-in function<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a>, or, the <code>mode</code> argument of the <code>fopen()</code> C function<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>. In the code example below, we are opening the <code>foo.txt</code> text file with a <code>write_only</code> mode, and appending a new line of text to the end of the file. We use <code>seekFromEnd()</code> this time to guarantee that we are going to append the text to the end of the file. Once again, methods such as <code>seekFromEnd()</code> are described in more depth in <a href="#sec-indicators" class="quarto-xref"><span>Section 13.6</span></a>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> cwd = std.fs.cwd();</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> file = <span class="kw">try</span> cwd.openFile(</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"foo.txt"</span>, .<span class="op">{</span> .mode = .write_only <span class="op">}</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>);</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="kw">defer</span> file.close();</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="kw">try</span> file.seekFromEnd(<span class="dv">0</span>);</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> fw = file.writer();</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>_ = <span class="kw">try</span> fw.writeAll(<span class="st">"Some random text to write</span><span class="sc">\n</span><span class="st">"</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="deleting-files" class="level3" data-number="13.5.3">
<h3 data-number="13.5.3" class="anchored" data-anchor-id="deleting-files"><span class="header-section-number">13.5.3</span> Deleting files</h3>
<p>Sometimes, we just need to delete/remove the files that we have. To do that, we use the <code>deleteFile()</code> method. You just provide the path of the file that you want to delete, and this method will try to delete the file located at this path.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> cwd = std.fs.cwd();</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">try</span> cwd.deleteFile(<span class="st">"foo.txt"</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="copying-files" class="level3" data-number="13.5.4">
<h3 data-number="13.5.4" class="anchored" data-anchor-id="copying-files"><span class="header-section-number">13.5.4</span> Copying files</h3>
<p>To copy existing files, we use the <code>copyFile()</code> method. The first argument in this method is the path to the file that you want to copy. The second argument is a <code>Dir</code> object, i.e., a directory handler, more specifically, a <code>Dir</code> object that points to the folder in your computer where you want to copy the file to. The third argument is the new path of the file, or, in other words, the new location of the file. The fourth argument is the options (or flags) to be used in the copy operation.</p>
<p>The <code>Dir</code> object that you provide as input to this method will be used to copy the file to the new location. You may create this <code>Dir</code> object before calling the <code>copyFile()</code> method. Maybe you are planning to copy the file to a completely different location in your computer, so it might be worth to create a directory handler to that location. But if you are copying the file to a subfolder of your CWD, then, you can just simply pass the CWD handler to this argument.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> cwd = std.fs.cwd();</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">try</span> cwd.copyFile(</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"foo.txt"</span>,</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    cwd,</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">"ZigExamples/file-io/foo.txt"</span>,</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    .<span class="op">{}</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="read-the-docs" class="level3" data-number="13.5.5">
<h3 data-number="13.5.5" class="anchored" data-anchor-id="read-the-docs"><span class="header-section-number">13.5.5</span> Read the docs!</h3>
<p>There are some other useful methods for file operations available at <code>Dir</code> objects, such as the <code>writeFile()</code> method, but I recommend you to read the docs for the <a href="https://ziglang.org/documentation/master/std/#std.fs.Dir"><code>Dir</code> type</a><a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a> to explore the other available methods, since I already talked too much about them.</p>
</section>
</section>
<section id="sec-indicators" class="level2" data-number="13.6">
<h2 data-number="13.6" class="anchored" data-anchor-id="sec-indicators"><span class="header-section-number">13.6</span> Position indicators</h2>
<p>A position indicator is like a type of cursor, or, an index. This “index” identifies the current location in the file (or, in the data stream) that the file descriptor object that you have is currently looking at. When you create a file descriptor, the position indicator starts at the beginning of the file, or, at the beginning of the stream. When you read from or write into the file (or socket, or data stream, etc.) described by this file descriptor object, you end up moving the position indicator.</p>
<p>In other words, any IO operation have a common side effect, which is to move the position indicator. For example, suppose that we have a file of 300 bytes total in size. If you read 100 bytes from the file, then, the position indicator moves 100 bytes forward. If you try to write 50 bytes into this same file, these 50 bytes will be written from the current position indicated by the position indicator. Since the indicator is at a 100 bytes forward from the beginning of the file, these 50 bytes would be written in the middle of the file.</p>
<p>This is why we have used the <code>seekTo()</code> method at the last code example presented in <a href="#sec-creating-files" class="quarto-xref"><span>Section 13.5.1</span></a>. We have used this method to move the position indicator back to the beginning of the file, which would make sure that we would write the text that we wanted to write from the beginning of the file, instead of writing it from the middle of the file. Because before the write operation, we had performed a read operation, which means that the position indicator was moved in this read operation.</p>
<p>The position indicators of a file descriptor object can be changed (or altered) by using the “seek” methods from this file descriptor, which are: <code>seekTo()</code>, <code>seekFromEnd()</code> and <code>seekBy()</code>. These methods have the same effect, or, the same responsibility that the <a href="https://en.cppreference.com/w/c/io/fseek"><code>fseek()</code></a><a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a> C function.</p>
<p>Considering that <code>offset</code> refers to the index that you provide as input to these “seek” methods, the bullet points below summarises what is the effect of each of these methods. As a quick note, in the case of <code>seekFromEnd()</code> and <code>seekBy()</code>, the <code>offset</code> provided can be either a positive or a negative index.</p>
<ul>
<li><code>seekTo()</code> will move the position indicator to the location that is <code>offset</code> bytes from the beginning of the file.</li>
<li><code>seekFromEnd()</code> will move the position indicator to the location that is <code>offset</code> bytes from the end of the file.</li>
<li><code>seekBy()</code> will move the position indicator to the location that is <code>offset</code> bytes from the current position in the file.</li>
</ul>
</section>
<section id="directory-operations" class="level2" data-number="13.7">
<h2 data-number="13.7" class="anchored" data-anchor-id="directory-operations"><span class="header-section-number">13.7</span> Directory operations</h2>
<section id="iterating-through-the-files-in-a-directory" class="level3" data-number="13.7.1">
<h3 data-number="13.7.1" class="anchored" data-anchor-id="iterating-through-the-files-in-a-directory"><span class="header-section-number">13.7.1</span> Iterating through the files in a directory</h3>
<p>One of the most classic tasks related to filesystem is to be able to iterate through the existing files in a directory. To iterate over the files in a directory, we need to create an iterator object.</p>
<p>You can produce such iterator object by using either the <code>iterate()</code> or <code>walk()</code> methods of a <code>Dir</code> object. Both methods return an iterator object as output, which you can advance by using the <code>next()</code> method. The difference between these methods, is that <code>iterate()</code> returns a non-recursive iterator, while <code>walk()</code> does. It means that the iterator returned by <code>walk()</code> will not only iterate through the files available in the current directory, but also, through the files from any subdirectory found inside the current directory.</p>
<p>In the example below, we are displaying the names of the files stored inside the directory <code>ZigExamples/file-io</code>. Notice that we had to open this directory through the <code>openDir()</code> function. Also notice that we provided the flag <code>iterate</code> in the second argument of <code>openDir()</code>. This flag is important, because without this flag, we would not be allowed to iterate through the files in this directory.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> cwd = std.fs.cwd();</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> dir = <span class="kw">try</span> cwd.openDir(</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"ZigExamples/file-io/"</span>,</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    .<span class="op">{</span> .iterate = <span class="cn">true</span> <span class="op">}</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>);</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> it = dir.iterate();</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="kw">while</span> (<span class="kw">try</span> it.next()) |entry| <span class="op">{</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> stdout.print(</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>        <span class="st">"File name: {s}</span><span class="sc">\n</span><span class="st">"</span>,</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>        .<span class="op">{</span>entry.name<span class="op">}</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    );</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>File name: create_file_and_write_toit.zig
File name: create_file.zig
File name: lorem.txt
File name: iterate.zig
File name: delete_file.zig
File name: append_to_file.zig
File name: user_input.zig
File name: foo.txt
File name: create_file_and_read.zig
File name: buff_io.zig
File name: copy_file.zig</code></pre>
</section>
<section id="creating-new-directories" class="level3" data-number="13.7.2">
<h3 data-number="13.7.2" class="anchored" data-anchor-id="creating-new-directories"><span class="header-section-number">13.7.2</span> Creating new directories</h3>
<p>There are two methods that are important when it comes to creating directories, which are <code>makeDir()</code> and <code>makePath()</code>. The difference between these two methods is that <code>makeDir()</code> can only create one single directory in the current directory in each call, while <code>makePath()</code> is capable of recursively create subdirectories in the same call.</p>
<p>This is why the name of this method is “make path”. It will create as many subdirectories as necessary to create the path that you provided as input. So, if you provide the path <code>"sub1/sub2/sub3"</code> as input to this method, it will create three different subdirectories, <code>sub1</code>, <code>sub2</code> and <code>sub3</code>, within the same function call. In contrast, if you provided such path as input to <code>makeDir()</code>, you would likely get an error as result, since this method can only create a single subdirectory.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> cwd = std.fs.cwd();</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">try</span> cwd.makeDir(<span class="st">"src"</span>);</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="kw">try</span> cwd.makePath(<span class="st">"src/decoders/jpg/"</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="deleting-directories" class="level3" data-number="13.7.3">
<h3 data-number="13.7.3" class="anchored" data-anchor-id="deleting-directories"><span class="header-section-number">13.7.3</span> Deleting directories</h3>
<p>To delete a directory, just provide the path to the directory that you want to delete as input to the <code>deleteDir()</code> method from a <code>Dir</code> object. In the example below, we are deleting the <code>src</code> directory that we have just created in the previous example.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> cwd = std.fs.cwd();</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">try</span> cwd.deleteDir(<span class="st">"src"</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="conclusion" class="level2" data-number="13.8">
<h2 data-number="13.8" class="anchored" data-anchor-id="conclusion"><span class="header-section-number">13.8</span> Conclusion</h2>
<p>In this chapter, I have described how to perform in Zig the most common filesystem and IO operations. But you might feel the lack of some other, less common, operation in this chapter, such as: how to rename files, or how to open a directory, or how to create symbolic links, or how to use <code>access()</code> to test if a particular path exists in your computer. But for all of these less common tasks, I recommend you to read the documentation of the <a href="https://ziglang.org/documentation/master/std/#std.fs.Dir"><code>Dir</code> type</a><a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a> , since you can find a good description of these cases there.</p>


<!-- -->

<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-wiki_file_descriptor" class="csl-entry" role="listitem">
Wikipedia. 2024. <span>“File Descriptor.”</span> Wikipedia. <a href="https://en.wikipedia.org/wiki/File_descriptor">https://en.wikipedia.org/wiki/File_descriptor</a>.
</div>
</div>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>Previously, these objects were known as the <code>Reader</code> and <code>Writer</code> objects.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>The socket objects that we have created in <a href="04-http-server.html#sec-create-socket" class="quarto-xref"><span>Section 7.4.1</span></a>, are examples of network sockets.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p><a href="https://ziglang.org/documentation/master/std/#std.io.GenericWriter" class="uri">https://ziglang.org/documentation/master/std/#std.io.GenericWriter</a>.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p><a href="https://ziglang.org/documentation/master/std/#std.io.GenericReader" class="uri">https://ziglang.org/documentation/master/std/#std.io.GenericReader</a>.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p><a href="https://github.com/ziglang/zig/blob/master/lib/std/io/Reader.zig" class="uri">https://github.com/ziglang/zig/blob/master/lib/std/io/Reader.zig</a>.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p><a href="https://github.com/ziglang/zig/blob/master/lib/std/io/Writer.zig" class="uri">https://github.com/ziglang/zig/blob/master/lib/std/io/Writer.zig</a>.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>A pipeline is a mechanism for inter-process communication, or, inter-process IO. You could also interpret a pipeline as a “set of processes that are chained together, through the standard input/output devices of the system”. At Linux for example, a pipeline is created inside a terminal, by connecting two or more terminal commands with the “pipe” character (<code>|</code>).<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p><a href="https://www.lipsum.com/" class="uri">https://www.lipsum.com/</a>.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p><a href="https://ziglang.org/documentation/master/std/#std.fs.File.OpenFlags" class="uri">https://ziglang.org/documentation/master/std/#std.fs.File.OpenFlags</a><a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p><a href="https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files" class="uri">https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files</a><a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11"><p><a href="https://www.tutorialspoint.com/c_standard_library/c_function_fopen.htm" class="uri">https://www.tutorialspoint.com/c_standard_library/c_function_fopen.htm</a><a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12"><p><a href="https://ziglang.org/documentation/master/std/#std.fs.Dir" class="uri">https://ziglang.org/documentation/master/std/#std.fs.Dir</a><a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13"><p><a href="https://en.cppreference.com/w/c/io/fseek" class="uri">https://en.cppreference.com/w/c/io/fseek</a><a href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn14"><p><a href="https://ziglang.org/documentation/master/std/#std.fs.Dir" class="uri">https://ziglang.org/documentation/master/std/#std.fs.Dir</a><a href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
<<<<<<< HEAD
=======
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
>>>>>>> origin
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../Chapters/10-stack-project.html" class="pagination-link" aria-label="Project 3 - Building a stack data structure">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Project 3 - Building a stack data structure</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../Chapters/14-zig-c-interop.html" class="pagination-link" aria-label="Zig interoperability with C">
        <span class="nav-page-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Zig interoperability with C</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb19" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="an">engine:</span><span class="co"> knitr</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="an">knitr:</span><span class="co"> true</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="an">syntax-definition:</span><span class="co"> "../Assets/zig.xml"</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="co">#| include: false</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="fu">source</span>(<span class="st">"../zig_engine.R"</span>)</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>knitr<span class="sc">::</span>opts_chunk<span class="sc">$</span><span class="fu">set</span>(</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>    <span class="at">auto_main =</span> <span class="cn">FALSE</span>,</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>    <span class="at">build_type =</span> <span class="st">"lib"</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a><span class="fu"># Filesystem and Input/Output (IO) {#sec-filesystem}</span></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>In this chapter we are going to discuss how to use the cross-platform structs and functions</span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>from the Zig Standard Library that can execute filesystem operations. Most of these functions and structs</span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>comes from the <span class="in">`std.fs`</span> module.</span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a>We are also going to talk about Input/Output (also known as IO) operations in Zig. Most of</span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a>these operations are made by using the structs and functions from <span class="in">`std.io`</span> module, which defines</span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a>file descriptors for the *standard channels* of your system (<span class="in">`stdout`</span> and <span class="in">`stdin`</span>), and also,</span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a>functions to create and use I/O streams.</span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a><span class="fu">## Input/Output basics {#sec-io-basics}</span></span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a>If you have some experience in a high-level language, you have certainly used</span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a>these input and output functionalities before in this language. In other words, you certainly have</span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true" tabindex="-1"></a>been in a situation where you needed to sent some output to the user, or, to receive an input</span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true" tabindex="-1"></a>from the user.</span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-41"><a href="#cb19-41" aria-hidden="true" tabindex="-1"></a>For example, in Python we can receive some input from the user by using the <span class="in">`input()`</span> built-in</span>
<span id="cb19-42"><a href="#cb19-42" aria-hidden="true" tabindex="-1"></a>function. But we can also print (or "show") some output to the user by using the <span class="in">`print()`</span></span>
<span id="cb19-43"><a href="#cb19-43" aria-hidden="true" tabindex="-1"></a>built-in function. So yes, if you have programmed before in Python, you certainly have</span>
<span id="cb19-44"><a href="#cb19-44" aria-hidden="true" tabindex="-1"></a>used these functions once before.</span>
<span id="cb19-45"><a href="#cb19-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-46"><a href="#cb19-46" aria-hidden="true" tabindex="-1"></a>But do you know how these functions relate back to your operating system (OS)? How exactly</span>
<span id="cb19-47"><a href="#cb19-47" aria-hidden="true" tabindex="-1"></a>they are interacting with the resources of your OS to receive or sent some input/output.</span>
<span id="cb19-48"><a href="#cb19-48" aria-hidden="true" tabindex="-1"></a>In essence, these input/output functions from high-level languages are just abstractions</span>
<span id="cb19-49"><a href="#cb19-49" aria-hidden="true" tabindex="-1"></a>over the *standard output* and *standard input* channels of your operating system.</span>
<span id="cb19-50"><a href="#cb19-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-51"><a href="#cb19-51" aria-hidden="true" tabindex="-1"></a>This means that we receive an input, or send some output, through the operating system.</span>
<span id="cb19-52"><a href="#cb19-52" aria-hidden="true" tabindex="-1"></a>It's the OS that makes the bridge between the user and your program. Your program</span>
<span id="cb19-53"><a href="#cb19-53" aria-hidden="true" tabindex="-1"></a>does not have a direct access to the user. It's the OS that intermediates every</span>
<span id="cb19-54"><a href="#cb19-54" aria-hidden="true" tabindex="-1"></a>message exchanged between your program and the user.</span>
<span id="cb19-55"><a href="#cb19-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-56"><a href="#cb19-56" aria-hidden="true" tabindex="-1"></a>The *standard output* and *standard input* channels of your OS are commonly known as the</span>
<span id="cb19-57"><a href="#cb19-57" aria-hidden="true" tabindex="-1"></a><span class="in">`stdout`</span> and <span class="in">`stdin`</span> channels of your OS, respectively. In some contexts, they are also</span>
<span id="cb19-58"><a href="#cb19-58" aria-hidden="true" tabindex="-1"></a>called the *standard output device* and the *standard input device*. As the name suggests,</span>
<span id="cb19-59"><a href="#cb19-59" aria-hidden="true" tabindex="-1"></a>the *standard output* is the channel through which output flows, while the *standard input*</span>
<span id="cb19-60"><a href="#cb19-60" aria-hidden="true" tabindex="-1"></a>is the channel in which input flows.</span>
<span id="cb19-61"><a href="#cb19-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-62"><a href="#cb19-62" aria-hidden="true" tabindex="-1"></a>Furthermore, OS's also normally create a dedicated channel for exchanging error messages, which is known as the</span>
<span id="cb19-63"><a href="#cb19-63" aria-hidden="true" tabindex="-1"></a>*standard error* channel, or, the <span class="in">`stderr`</span> channel. This is the channel to which error and warning messages</span>
<span id="cb19-64"><a href="#cb19-64" aria-hidden="true" tabindex="-1"></a>are usually sent to. These are the messages that are normally displayed in red-like or orange-like colors</span>
<span id="cb19-65"><a href="#cb19-65" aria-hidden="true" tabindex="-1"></a>into your terminal.</span>
<span id="cb19-66"><a href="#cb19-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-67"><a href="#cb19-67" aria-hidden="true" tabindex="-1"></a>Normally, every OS (e.g. Windows, macOS, Linux, etc.) creates a dedicated and separate set of</span>
<span id="cb19-68"><a href="#cb19-68" aria-hidden="true" tabindex="-1"></a>*standard output*, *standard error* and *standard input* channels for every single program (or process) that runs in your computer.</span>
<span id="cb19-69"><a href="#cb19-69" aria-hidden="true" tabindex="-1"></a>This means that every program you write have a dedicated <span class="in">`stdin`</span>, <span class="in">`stderr`</span> and <span class="in">`stdout`</span> that are separate</span>
<span id="cb19-70"><a href="#cb19-70" aria-hidden="true" tabindex="-1"></a>from the <span class="in">`stdin`</span>, <span class="in">`stderr`</span> and <span class="in">`stdout`</span> of other programs and processes that are currently running.</span>
<span id="cb19-71"><a href="#cb19-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-72"><a href="#cb19-72" aria-hidden="true" tabindex="-1"></a>This is a behaviour from your OS. This does not come from the programming language that you are using.</span>
<span id="cb19-73"><a href="#cb19-73" aria-hidden="true" tabindex="-1"></a>Because as I sad earlier, input and output in programming languages, especially</span>
<span id="cb19-74"><a href="#cb19-74" aria-hidden="true" tabindex="-1"></a>in high-level ones, are just a simple abstraction over the <span class="in">`stdin`</span>, <span class="in">`stderr`</span> and <span class="in">`stdout`</span> from your current OS.</span>
<span id="cb19-75"><a href="#cb19-75" aria-hidden="true" tabindex="-1"></a>That is, your OS is the intermediary between every input/output operation made in your program,</span>
<span id="cb19-76"><a href="#cb19-76" aria-hidden="true" tabindex="-1"></a>regardless of the programming language that you are using.</span>
<span id="cb19-77"><a href="#cb19-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-78"><a href="#cb19-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-79"><a href="#cb19-79" aria-hidden="true" tabindex="-1"></a><span class="fu">### The writer and reader pattern {#sec-writer-reader}</span></span>
<span id="cb19-80"><a href="#cb19-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-81"><a href="#cb19-81" aria-hidden="true" tabindex="-1"></a>In Zig, there is a pattern around input/output (IO). I (the author of this book) don't know if there</span>
<span id="cb19-82"><a href="#cb19-82" aria-hidden="true" tabindex="-1"></a>is an official name for this pattern. But here, in this book, I will call it the "writer and reader pattern".</span>
<span id="cb19-83"><a href="#cb19-83" aria-hidden="true" tabindex="-1"></a>In essence, every IO operation in Zig is made through either a <span class="in">`GenericReader`</span> or a <span class="in">`GenericWriter`</span> object<span class="ot">[^gen-zig]</span>.</span>
<span id="cb19-84"><a href="#cb19-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-85"><a href="#cb19-85" aria-hidden="true" tabindex="-1"></a>These two data types come from the <span class="in">`std.io`</span> module of the Zig Standard Library. As their names suggests, a</span>
<span id="cb19-86"><a href="#cb19-86" aria-hidden="true" tabindex="-1"></a><span class="in">`GenericReader`</span> is an object that offers tools to read data from "something" (or "somewhere"), while a <span class="in">`GenericWriter`</span></span>
<span id="cb19-87"><a href="#cb19-87" aria-hidden="true" tabindex="-1"></a>offers tools to write data into this "something". This "something" might be different things: like a</span>
<span id="cb19-88"><a href="#cb19-88" aria-hidden="true" tabindex="-1"></a>file that exists in your filesystem; or, it might be a network socket in your system<span class="ot">[^sock]</span>; or,</span>
<span id="cb19-89"><a href="#cb19-89" aria-hidden="true" tabindex="-1"></a>a continuous stream of data, like a standard input device from your system, that might be constantly</span>
<span id="cb19-90"><a href="#cb19-90" aria-hidden="true" tabindex="-1"></a>receiving new data from users, or, as another example, a live chat in a game that is constantly</span>
<span id="cb19-91"><a href="#cb19-91" aria-hidden="true" tabindex="-1"></a>receiving and displaying new messages from the players of the game.</span>
<span id="cb19-92"><a href="#cb19-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-93"><a href="#cb19-93" aria-hidden="true" tabindex="-1"></a><span class="ot">[^gen-zig]: </span>Previously, these objects were known as the <span class="in">`Reader`</span> and <span class="in">`Writer`</span> objects.</span>
<span id="cb19-94"><a href="#cb19-94" aria-hidden="true" tabindex="-1"></a><span class="ot">[^sock]: </span>The socket objects that we have created in @sec-create-socket, are examples of network sockets.</span>
<span id="cb19-95"><a href="#cb19-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-96"><a href="#cb19-96" aria-hidden="true" tabindex="-1"></a>So, if you want to **read** data from something, or somewhere, it means that you need to use a <span class="in">`GenericReader`</span> object.</span>
<span id="cb19-97"><a href="#cb19-97" aria-hidden="true" tabindex="-1"></a>But if you need instead, to **write** data into this "something", then, you need to use a <span class="in">`GenericWriter`</span> object instead.</span>
<span id="cb19-98"><a href="#cb19-98" aria-hidden="true" tabindex="-1"></a>Both of these objects are normally created from a file descriptor object. More specifically, through the <span class="in">`writer()`</span> and <span class="in">`reader()`</span></span>
<span id="cb19-99"><a href="#cb19-99" aria-hidden="true" tabindex="-1"></a>methods of this file descriptor object. If you are not familiar with this type of object, go to the next section.</span>
<span id="cb19-100"><a href="#cb19-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-101"><a href="#cb19-101" aria-hidden="true" tabindex="-1"></a>Every <span class="in">`GenericWriter`</span> object have methods like <span class="in">`print()`</span>, which allows you to write/send a formatted string</span>
<span id="cb19-102"><a href="#cb19-102" aria-hidden="true" tabindex="-1"></a>(i.e., this formatted string is like a <span class="in">`f`</span> string in Python, or, similar to the <span class="in">`printf()`</span> C function)</span>
<span id="cb19-103"><a href="#cb19-103" aria-hidden="true" tabindex="-1"></a>into the "something" (file, socket, stream, etc.) that you are using. It also have a <span class="in">`writeAll()`</span> method, which allows you to</span>
<span id="cb19-104"><a href="#cb19-104" aria-hidden="true" tabindex="-1"></a>write a string, or, an array of bytes into the "something".</span>
<span id="cb19-105"><a href="#cb19-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-106"><a href="#cb19-106" aria-hidden="true" tabindex="-1"></a>Likewise, every <span class="in">`GenericReader`</span> object have methods like <span class="in">`readAll()`</span>, which allows you to read the</span>
<span id="cb19-107"><a href="#cb19-107" aria-hidden="true" tabindex="-1"></a>data from the "something" (file, socket, stream, etc.) until it fills a particular array (i.e., a "buffer") object.</span>
<span id="cb19-108"><a href="#cb19-108" aria-hidden="true" tabindex="-1"></a>In other words, if you provide an array object of 300 <span class="in">`u8`</span> values to <span class="in">`readAll()`</span>, then, this method attempts to read 300 bytes</span>
<span id="cb19-109"><a href="#cb19-109" aria-hidden="true" tabindex="-1"></a>of data from the "something", and it stores them into the array object that you have provided.</span>
<span id="cb19-110"><a href="#cb19-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-111"><a href="#cb19-111" aria-hidden="true" tabindex="-1"></a>We also have other methods, like the <span class="in">`readAtLeast()`</span> method, which allows you to specify how</span>
<span id="cb19-112"><a href="#cb19-112" aria-hidden="true" tabindex="-1"></a>many bytes exactly you want to read from the "something". In more details, if you give the</span>
<span id="cb19-113"><a href="#cb19-113" aria-hidden="true" tabindex="-1"></a>number $n$ as input to this method, then, it will attempt to read at least $n$ bytes of data</span>
<span id="cb19-114"><a href="#cb19-114" aria-hidden="true" tabindex="-1"></a>from the "something". The "something" might have less than $n$ bytes of data available for you</span>
<span id="cb19-115"><a href="#cb19-115" aria-hidden="true" tabindex="-1"></a>to read, so, it's not guaranteed that you will get precisely $n$ bytes as result.</span>
<span id="cb19-116"><a href="#cb19-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-117"><a href="#cb19-117" aria-hidden="true" tabindex="-1"></a>Another useful method is <span class="in">`readUntilDelimiterOrEof()`</span>. In this method, you specify a "delimiter character".</span>
<span id="cb19-118"><a href="#cb19-118" aria-hidden="true" tabindex="-1"></a>The idea is that this function will attempt to read as many bytes of data as possible from the "something",</span>
<span id="cb19-119"><a href="#cb19-119" aria-hidden="true" tabindex="-1"></a>until it encounters the end of the stream, or, it encounters the "delimiter character" that you have specified.</span>
<span id="cb19-120"><a href="#cb19-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-121"><a href="#cb19-121" aria-hidden="true" tabindex="-1"></a>If you don't know exactly how many bytes will come from the "something", you may find the <span class="in">`readAllAlloc()`</span> method</span>
<span id="cb19-122"><a href="#cb19-122" aria-hidden="true" tabindex="-1"></a>useful. In essence, you provide an allocator object to this method, so that it can allocate more space if needed.</span>
<span id="cb19-123"><a href="#cb19-123" aria-hidden="true" tabindex="-1"></a>As consequence, this method will try to read all bytes of the "something", and, if it runs out of space at some point</span>
<span id="cb19-124"><a href="#cb19-124" aria-hidden="true" tabindex="-1"></a>during the "reading process", it uses the allocator object to allocate more space to continue reading the bytes.</span>
<span id="cb19-125"><a href="#cb19-125" aria-hidden="true" tabindex="-1"></a>As result, this method returns a slice to the array object containing all the bytes read.</span>
<span id="cb19-126"><a href="#cb19-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-127"><a href="#cb19-127" aria-hidden="true" tabindex="-1"></a>This is just a quick description of the methods present in these types of objects. But I recommend you</span>
<span id="cb19-128"><a href="#cb19-128" aria-hidden="true" tabindex="-1"></a>to read the official docs, both for</span>
<span id="cb19-129"><a href="#cb19-129" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">`GenericWriter`</span><span class="co">](https://ziglang.org/documentation/master/std/#std.io.GenericWriter)</span><span class="ot">[^gen-write]</span> and</span>
<span id="cb19-130"><a href="#cb19-130" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">`GenericReader`</span><span class="co">](https://ziglang.org/documentation/master/std/#std.io.GenericReader)</span><span class="ot">[^gen-read]</span>.</span>
<span id="cb19-131"><a href="#cb19-131" aria-hidden="true" tabindex="-1"></a>I also think it's a good idea to read the source code of the modules in the Zig Standard Library</span>
<span id="cb19-132"><a href="#cb19-132" aria-hidden="true" tabindex="-1"></a>that defines the methods present in these objects, which are the</span>
<span id="cb19-133"><a href="#cb19-133" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">`Reader.zig`</span><span class="co">](https://github.com/ziglang/zig/blob/master/lib/std/io/Reader.zig)</span><span class="ot">[^mod-read]</span></span>
<span id="cb19-134"><a href="#cb19-134" aria-hidden="true" tabindex="-1"></a>and <span class="co">[</span><span class="ot">`Writer.zig`</span><span class="co">]()</span><span class="ot">[^mod-write]</span>.</span>
<span id="cb19-135"><a href="#cb19-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-136"><a href="#cb19-136" aria-hidden="true" tabindex="-1"></a><span class="ot">[^gen-read]: &lt;https://ziglang.org/documentation/master/std/#std.io.GenericReader&gt;</span>.</span>
<span id="cb19-137"><a href="#cb19-137" aria-hidden="true" tabindex="-1"></a><span class="ot">[^gen-write]: &lt;https://ziglang.org/documentation/master/std/#std.io.GenericWriter&gt;</span>.</span>
<span id="cb19-138"><a href="#cb19-138" aria-hidden="true" tabindex="-1"></a><span class="ot">[^mod-read]: &lt;https://github.com/ziglang/zig/blob/master/lib/std/io/Reader.zig&gt;</span>.</span>
<span id="cb19-139"><a href="#cb19-139" aria-hidden="true" tabindex="-1"></a><span class="ot">[^mod-write]: &lt;https://github.com/ziglang/zig/blob/master/lib/std/io/Writer.zig&gt;</span>.</span>
<span id="cb19-140"><a href="#cb19-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-141"><a href="#cb19-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-142"><a href="#cb19-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-143"><a href="#cb19-143" aria-hidden="true" tabindex="-1"></a><span class="fu">### Introducing file descriptors {#sec-file-descriptor}</span></span>
<span id="cb19-144"><a href="#cb19-144" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-145"><a href="#cb19-145" aria-hidden="true" tabindex="-1"></a>A "file descriptor" object is a core component behind every IO operation that is made in any operating system (OS).</span>
<span id="cb19-146"><a href="#cb19-146" aria-hidden="true" tabindex="-1"></a>Such object is an identifier for a particular input/output (IO) resource from your OS <span class="co">[</span><span class="ot">@wiki_file_descriptor</span><span class="co">]</span>.</span>
<span id="cb19-147"><a href="#cb19-147" aria-hidden="true" tabindex="-1"></a>It describes and identifies this particular resource. An IO resource might be:</span>
<span id="cb19-148"><a href="#cb19-148" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-149"><a href="#cb19-149" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>an existing file in your filesystem.</span>
<span id="cb19-150"><a href="#cb19-150" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>an existing network socket.</span>
<span id="cb19-151"><a href="#cb19-151" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>other types of stream channels.</span>
<span id="cb19-152"><a href="#cb19-152" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>a pipeline (or just "pipe") in your terminal<span class="ot">[^pipes]</span>.</span>
<span id="cb19-153"><a href="#cb19-153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-154"><a href="#cb19-154" aria-hidden="true" tabindex="-1"></a><span class="ot">[^pipes]: </span>A pipeline is a mechanism for inter-process communication, or, inter-process IO. You could also interpret a pipeline as a "set of processes that are chained together, through the standard input/output devices of the system". At Linux for example, a pipeline is created inside a terminal, by connecting two or more terminal commands with the "pipe" character (<span class="in">`|`</span>).</span>
<span id="cb19-155"><a href="#cb19-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-156"><a href="#cb19-156" aria-hidden="true" tabindex="-1"></a>From the bullet points listed above, we know that although the term "file" is present,</span>
<span id="cb19-157"><a href="#cb19-157" aria-hidden="true" tabindex="-1"></a>a "file descriptor" might describe something more than just a file.</span>
<span id="cb19-158"><a href="#cb19-158" aria-hidden="true" tabindex="-1"></a>This concept of a "file descriptor" comes from the Portable Operating System Interface (POSIX) API,</span>
<span id="cb19-159"><a href="#cb19-159" aria-hidden="true" tabindex="-1"></a>which is a set of standards that guide how operating systems across the world should be implemented,</span>
<span id="cb19-160"><a href="#cb19-160" aria-hidden="true" tabindex="-1"></a>to maintain compatibility between them.</span>
<span id="cb19-161"><a href="#cb19-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-162"><a href="#cb19-162" aria-hidden="true" tabindex="-1"></a>A file descriptor not only identifies the input/output resource that you are using to receive or send some data,</span>
<span id="cb19-163"><a href="#cb19-163" aria-hidden="true" tabindex="-1"></a>but it also describes where this resource is, and also, which IO mode this resource is currently using.</span>
<span id="cb19-164"><a href="#cb19-164" aria-hidden="true" tabindex="-1"></a>For example, this IO resource might be using only the "read" IO mode, which means that this resource</span>
<span id="cb19-165"><a href="#cb19-165" aria-hidden="true" tabindex="-1"></a>is open to "read operations", while "write operations" are not authorized.</span>
<span id="cb19-166"><a href="#cb19-166" aria-hidden="true" tabindex="-1"></a>These IO modes are essentially the modes that you provide to the argument <span class="in">`mode`</span></span>
<span id="cb19-167"><a href="#cb19-167" aria-hidden="true" tabindex="-1"></a>from the <span class="in">`fopen()`</span> C function, and also, from the <span class="in">`open()`</span> Python built-in function.</span>
<span id="cb19-168"><a href="#cb19-168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-169"><a href="#cb19-169" aria-hidden="true" tabindex="-1"></a>In C, a "file descriptor" is a <span class="in">`FILE`</span> pointer, but, in Zig, a file descriptor is a <span class="in">`File`</span> object.</span>
<span id="cb19-170"><a href="#cb19-170" aria-hidden="true" tabindex="-1"></a>This data type (<span class="in">`File`</span>) is described in the <span class="in">`std.fs`</span> module of the Zig Standard Library.</span>
<span id="cb19-171"><a href="#cb19-171" aria-hidden="true" tabindex="-1"></a>We normally don't create a <span class="in">`File`</span> object directly in our Zig code. Instead, we normally get such object as result when we</span>
<span id="cb19-172"><a href="#cb19-172" aria-hidden="true" tabindex="-1"></a>open an IO resource. In other words, we normally ask our OS to open a particular IO resource for us,</span>
<span id="cb19-173"><a href="#cb19-173" aria-hidden="true" tabindex="-1"></a>and, if the OS do open successfully this IO resource, the OS normally handles back to us</span>
<span id="cb19-174"><a href="#cb19-174" aria-hidden="true" tabindex="-1"></a>a file descriptor to this particular IO resource.</span>
<span id="cb19-175"><a href="#cb19-175" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-176"><a href="#cb19-176" aria-hidden="true" tabindex="-1"></a>So you usually get a <span class="in">`File`</span> object by using functions and methods from the Zig Standard Library</span>
<span id="cb19-177"><a href="#cb19-177" aria-hidden="true" tabindex="-1"></a>that asks the OS to open some IO resource, like the <span class="in">`openFile()`</span> method that opens a file in the</span>
<span id="cb19-178"><a href="#cb19-178" aria-hidden="true" tabindex="-1"></a>filesystem. The <span class="in">`net.Stream`</span> object that we have created in @sec-create-socket is also a type of</span>
<span id="cb19-179"><a href="#cb19-179" aria-hidden="true" tabindex="-1"></a>file descriptor object.</span>
<span id="cb19-180"><a href="#cb19-180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-181"><a href="#cb19-181" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-182"><a href="#cb19-182" aria-hidden="true" tabindex="-1"></a><span class="fu">### The *standard output*</span></span>
<span id="cb19-183"><a href="#cb19-183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-184"><a href="#cb19-184" aria-hidden="true" tabindex="-1"></a>You already saw across this book, how can we access and use specifically the <span class="in">`stdout`</span> in Zig</span>
<span id="cb19-185"><a href="#cb19-185" aria-hidden="true" tabindex="-1"></a>to send some output to the user.</span>
<span id="cb19-186"><a href="#cb19-186" aria-hidden="true" tabindex="-1"></a>For that, we use the <span class="in">`getStdOut()`</span> function from the <span class="in">`std.io`</span> module. This function returns</span>
<span id="cb19-187"><a href="#cb19-187" aria-hidden="true" tabindex="-1"></a>a file descriptor that describes the <span class="in">`stdout`</span> channel of your current OS. Through this file</span>
<span id="cb19-188"><a href="#cb19-188" aria-hidden="true" tabindex="-1"></a>descriptor object, we can read from or write stuff to the <span class="in">`stdout`</span> of our program.</span>
<span id="cb19-189"><a href="#cb19-189" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-190"><a href="#cb19-190" aria-hidden="true" tabindex="-1"></a>Although we can read stuff recorded into the <span class="in">`stdout`</span> channel, we normally only</span>
<span id="cb19-191"><a href="#cb19-191" aria-hidden="true" tabindex="-1"></a>write to (or "print") stuff into this channel. The reason is very similar to what we discussed at</span>
<span id="cb19-192"><a href="#cb19-192" aria-hidden="true" tabindex="-1"></a>@sec-read-http-message, when we were discussing what "reading from" versus "writing to" the connection</span>
<span id="cb19-193"><a href="#cb19-193" aria-hidden="true" tabindex="-1"></a>object from our small HTTP Server project would mean.</span>
<span id="cb19-194"><a href="#cb19-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-195"><a href="#cb19-195" aria-hidden="true" tabindex="-1"></a>When we write stuff into a channel, we are essentially sending data to the other end of this channel.</span>
<span id="cb19-196"><a href="#cb19-196" aria-hidden="true" tabindex="-1"></a>In contrast, when we read stuff from this channel, we are essentially reading the data that was sent</span>
<span id="cb19-197"><a href="#cb19-197" aria-hidden="true" tabindex="-1"></a>through this channel. Since the <span class="in">`stdout`</span> is a channel to send output to the user, the key verb here</span>
<span id="cb19-198"><a href="#cb19-198" aria-hidden="true" tabindex="-1"></a>is **send**. We want to send something to someone, and, as consequence, we want to **write** something</span>
<span id="cb19-199"><a href="#cb19-199" aria-hidden="true" tabindex="-1"></a>into some channel.</span>
<span id="cb19-200"><a href="#cb19-200" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-201"><a href="#cb19-201" aria-hidden="true" tabindex="-1"></a>That is why, when we use <span class="in">`getStdOut()`</span>, most of the times, we also use the <span class="in">`writer()`</span> method from the <span class="in">`stdout`</span> file descriptor,</span>
<span id="cb19-202"><a href="#cb19-202" aria-hidden="true" tabindex="-1"></a>to get access to a writer object that we can use to write stuff into this <span class="in">`stdout`</span> channel.</span>
<span id="cb19-203"><a href="#cb19-203" aria-hidden="true" tabindex="-1"></a>More specifically, this <span class="in">`writer()`</span> method returns a <span class="in">`GenericWriter`</span> object. One of the</span>
<span id="cb19-204"><a href="#cb19-204" aria-hidden="true" tabindex="-1"></a>main methods of this <span class="in">`GenericWriter`</span> object is the <span class="in">`print()`</span> method that we have used</span>
<span id="cb19-205"><a href="#cb19-205" aria-hidden="true" tabindex="-1"></a>before to write (or "print") a formatted string into the <span class="in">`stdout`</span> channel.</span>
<span id="cb19-206"><a href="#cb19-206" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-209"><a href="#cb19-209" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb19-210"><a href="#cb19-210" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: false</span></span>
<span id="cb19-211"><a href="#cb19-211" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb19-212"><a href="#cb19-212" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb19-213"><a href="#cb19-213" aria-hidden="true" tabindex="-1"></a><span class="in">const stdout = std.io.getStdOut().writer();</span></span>
<span id="cb19-214"><a href="#cb19-214" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb19-215"><a href="#cb19-215" aria-hidden="true" tabindex="-1"></a><span class="in">    try stdout.writeAll(</span></span>
<span id="cb19-216"><a href="#cb19-216" aria-hidden="true" tabindex="-1"></a><span class="in">        "This message was written into stdout.\n"</span></span>
<span id="cb19-217"><a href="#cb19-217" aria-hidden="true" tabindex="-1"></a><span class="in">    );</span></span>
<span id="cb19-218"><a href="#cb19-218" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb19-219"><a href="#cb19-219" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-220"><a href="#cb19-220" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-221"><a href="#cb19-221" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-222"><a href="#cb19-222" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-223"><a href="#cb19-223" aria-hidden="true" tabindex="-1"></a>This <span class="in">`GenericWriter`</span> object is like any other generic writer object that you would normally get from a file descriptor object.</span>
<span id="cb19-224"><a href="#cb19-224" aria-hidden="true" tabindex="-1"></a>So, the same methods from a generic writer object that you would use while writing files to the filesystem for example, you could also</span>
<span id="cb19-225"><a href="#cb19-225" aria-hidden="true" tabindex="-1"></a>use them here, from the file descriptor object of <span class="in">`stdout`</span>, and vice-versa.</span>
<span id="cb19-226"><a href="#cb19-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-227"><a href="#cb19-227" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-228"><a href="#cb19-228" aria-hidden="true" tabindex="-1"></a><span class="fu">### The *standard input*</span></span>
<span id="cb19-229"><a href="#cb19-229" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-230"><a href="#cb19-230" aria-hidden="true" tabindex="-1"></a>You can access the *standard input* (i.e., <span class="in">`stdin`</span>) in Zig by using the <span class="in">`getStdIn()`</span> function from the <span class="in">`std.io`</span> module.</span>
<span id="cb19-231"><a href="#cb19-231" aria-hidden="true" tabindex="-1"></a>Like its brother (<span class="in">`getStdOut()`</span>), this function also returns a file descriptor object that describes the <span class="in">`stdin`</span> channel</span>
<span id="cb19-232"><a href="#cb19-232" aria-hidden="true" tabindex="-1"></a>of your OS.</span>
<span id="cb19-233"><a href="#cb19-233" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-234"><a href="#cb19-234" aria-hidden="true" tabindex="-1"></a>Because we want to receive some input from the user, the key verb here becomes **receive**, and, as consequence,</span>
<span id="cb19-235"><a href="#cb19-235" aria-hidden="true" tabindex="-1"></a>we usually want to **read** data from the <span class="in">`stdin`</span> channel, instead of writing data into it. So, we normally use</span>
<span id="cb19-236"><a href="#cb19-236" aria-hidden="true" tabindex="-1"></a>the <span class="in">`reader()`</span> method of the file descriptor object returned by <span class="in">`getStdIn()`</span>, to get access to a <span class="in">`GenericReader`</span></span>
<span id="cb19-237"><a href="#cb19-237" aria-hidden="true" tabindex="-1"></a>object that we can use to read data from <span class="in">`stdin`</span>.</span>
<span id="cb19-238"><a href="#cb19-238" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-239"><a href="#cb19-239" aria-hidden="true" tabindex="-1"></a>In the example below, we are creating a small buffer capable of holding 20 characters. Then, we try to read</span>
<span id="cb19-240"><a href="#cb19-240" aria-hidden="true" tabindex="-1"></a>the data from the <span class="in">`stdin`</span> with the <span class="in">`readUntilDelimiterOrEof()`</span> method, and save this data into the <span class="in">`buffer`</span> object.</span>
<span id="cb19-241"><a href="#cb19-241" aria-hidden="true" tabindex="-1"></a>Also notice that we are reading the data from the <span class="in">`stdin`</span> until we hit a new line character (<span class="in">`'\n'`</span>).</span>
<span id="cb19-242"><a href="#cb19-242" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-243"><a href="#cb19-243" aria-hidden="true" tabindex="-1"></a>If you execute this program, you will notice that it stops the execution, ands start to wait indefinitely</span>
<span id="cb19-244"><a href="#cb19-244" aria-hidden="true" tabindex="-1"></a>for some input from the user. In other words, you need to type your name into the terminal, and then, you press Enter to</span>
<span id="cb19-245"><a href="#cb19-245" aria-hidden="true" tabindex="-1"></a>send your name to <span class="in">`stdin`</span>. After you send your name to <span class="in">`stdin`</span>, the program reads this input, and continues with the execution,</span>
<span id="cb19-246"><a href="#cb19-246" aria-hidden="true" tabindex="-1"></a>by printing the given name to <span class="in">`stdout`</span>. In the example below, I typed my name (Pedro) into the terminal, and then, pressed Enter.</span>
<span id="cb19-247"><a href="#cb19-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-248"><a href="#cb19-248" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-251"><a href="#cb19-251" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb19-252"><a href="#cb19-252" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb19-253"><a href="#cb19-253" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: false</span></span>
<span id="cb19-254"><a href="#cb19-254" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb19-255"><a href="#cb19-255" aria-hidden="true" tabindex="-1"></a><span class="in">const stdout = std.io.getStdOut().writer();</span></span>
<span id="cb19-256"><a href="#cb19-256" aria-hidden="true" tabindex="-1"></a><span class="in">const stdin = std.io.getStdIn().reader();</span></span>
<span id="cb19-257"><a href="#cb19-257" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb19-258"><a href="#cb19-258" aria-hidden="true" tabindex="-1"></a><span class="in">    try stdout.writeAll("Type your name\n");</span></span>
<span id="cb19-259"><a href="#cb19-259" aria-hidden="true" tabindex="-1"></a><span class="in">    var buffer: [20]u8 = undefined;</span></span>
<span id="cb19-260"><a href="#cb19-260" aria-hidden="true" tabindex="-1"></a><span class="in">    @memset(buffer[0..], 0);</span></span>
<span id="cb19-261"><a href="#cb19-261" aria-hidden="true" tabindex="-1"></a><span class="in">    _ = try stdin.readUntilDelimiterOrEof(buffer[0..], '\n');</span></span>
<span id="cb19-262"><a href="#cb19-262" aria-hidden="true" tabindex="-1"></a><span class="in">    try stdout.print("Your name is: {s}\n", .{buffer});</span></span>
<span id="cb19-263"><a href="#cb19-263" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb19-264"><a href="#cb19-264" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-265"><a href="#cb19-265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-266"><a href="#cb19-266" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-267"><a href="#cb19-267" aria-hidden="true" tabindex="-1"></a><span class="in">Type your name</span></span>
<span id="cb19-268"><a href="#cb19-268" aria-hidden="true" tabindex="-1"></a><span class="in">Your name is: Pedro</span></span>
<span id="cb19-269"><a href="#cb19-269" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-270"><a href="#cb19-270" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-271"><a href="#cb19-271" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-272"><a href="#cb19-272" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-273"><a href="#cb19-273" aria-hidden="true" tabindex="-1"></a><span class="fu">### The *standard error*</span></span>
<span id="cb19-274"><a href="#cb19-274" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-275"><a href="#cb19-275" aria-hidden="true" tabindex="-1"></a>The *standard error* (a.k.a. the <span class="in">`stderr`</span>) works exactly the same as <span class="in">`stdout`</span> and <span class="in">`stdin`</span>.</span>
<span id="cb19-276"><a href="#cb19-276" aria-hidden="true" tabindex="-1"></a>You just call the <span class="in">`getStdErr()`</span> function from the <span class="in">`std.io`</span> module, and you get the file descriptor to <span class="in">`stderr`</span>.</span>
<span id="cb19-277"><a href="#cb19-277" aria-hidden="true" tabindex="-1"></a>Ideally, you should write only error or warning messages to <span class="in">`stderr`</span>, because this is</span>
<span id="cb19-278"><a href="#cb19-278" aria-hidden="true" tabindex="-1"></a>the purpose of this channel.</span>
<span id="cb19-279"><a href="#cb19-279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-280"><a href="#cb19-280" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-281"><a href="#cb19-281" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-282"><a href="#cb19-282" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-283"><a href="#cb19-283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-284"><a href="#cb19-284" aria-hidden="true" tabindex="-1"></a><span class="fu">## Buffered IO</span></span>
<span id="cb19-285"><a href="#cb19-285" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-286"><a href="#cb19-286" aria-hidden="true" tabindex="-1"></a>As we described in @sec-io-basics, input/output (IO) operations are made directly by the operating system.</span>
<span id="cb19-287"><a href="#cb19-287" aria-hidden="true" tabindex="-1"></a>It's the OS that manages the IO resource that you want to use for your IO operations.</span>
<span id="cb19-288"><a href="#cb19-288" aria-hidden="true" tabindex="-1"></a>The consequence of this fact is that IO operations are heavily based on system calls (i.e., calling the operating system directly).</span>
<span id="cb19-289"><a href="#cb19-289" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-290"><a href="#cb19-290" aria-hidden="true" tabindex="-1"></a>Just to be clear, there is nothing particularly wrong with system calls. We use them all the time on</span>
<span id="cb19-291"><a href="#cb19-291" aria-hidden="true" tabindex="-1"></a>any serious codebase written in any low-level programming language. However, system calls are</span>
<span id="cb19-292"><a href="#cb19-292" aria-hidden="true" tabindex="-1"></a>always orders of magnitude slower than many different types of operations.</span>
<span id="cb19-293"><a href="#cb19-293" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-294"><a href="#cb19-294" aria-hidden="true" tabindex="-1"></a>So is perfectly fine to use a system call once in a while. But when these system calls are used often,</span>
<span id="cb19-295"><a href="#cb19-295" aria-hidden="true" tabindex="-1"></a>you can clearly notice most of the time the loss of performance in your application. So, the good rule of thumb</span>
<span id="cb19-296"><a href="#cb19-296" aria-hidden="true" tabindex="-1"></a>is to use a system call only when it's needed, and also, only in infrequent situations, to reduce</span>
<span id="cb19-297"><a href="#cb19-297" aria-hidden="true" tabindex="-1"></a>the number of system calls performed to a minimum.</span>
<span id="cb19-298"><a href="#cb19-298" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-299"><a href="#cb19-299" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-300"><a href="#cb19-300" aria-hidden="true" tabindex="-1"></a><span class="fu">### Understanding how buffered IO works</span></span>
<span id="cb19-301"><a href="#cb19-301" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-302"><a href="#cb19-302" aria-hidden="true" tabindex="-1"></a>Buffered IO is a strategy to achieve better performance. It's used to reduce the number of system calls made by IO operations, and, as</span>
<span id="cb19-303"><a href="#cb19-303" aria-hidden="true" tabindex="-1"></a>consequence, achieve a much higher performance. In @fig-unbuffered-io and @fig-buffered-io you can find two different diagrams</span>
<span id="cb19-304"><a href="#cb19-304" aria-hidden="true" tabindex="-1"></a>which presents the difference between read operations performed in an unbuffered IO environment versus a buffered IO environment.</span>
<span id="cb19-305"><a href="#cb19-305" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-306"><a href="#cb19-306" aria-hidden="true" tabindex="-1"></a>To give a better context to these diagrams, let's suppose that we have a text file that contains the famous Lorem ipsum text<span class="ot">[^lorem]</span></span>
<span id="cb19-307"><a href="#cb19-307" aria-hidden="true" tabindex="-1"></a>in our filesystem. Let's also suppose that these diagrams in @fig-unbuffered-io and @fig-buffered-io</span>
<span id="cb19-308"><a href="#cb19-308" aria-hidden="true" tabindex="-1"></a>are showing the read operations that we are performing to read the Lorem ipsum text from this text file.</span>
<span id="cb19-309"><a href="#cb19-309" aria-hidden="true" tabindex="-1"></a>The first thing you will notice when looking at these diagrams, is that in an unbuffered environment</span>
<span id="cb19-310"><a href="#cb19-310" aria-hidden="true" tabindex="-1"></a>the read operations leads to many system calls.</span>
<span id="cb19-311"><a href="#cb19-311" aria-hidden="true" tabindex="-1"></a>More precisely, in the diagram exposed in @fig-unbuffered-io we get one system call per each byte that we read from the text file.</span>
<span id="cb19-312"><a href="#cb19-312" aria-hidden="true" tabindex="-1"></a>On the other hand, in @fig-buffered-io we have only one system call at the very beginning.</span>
<span id="cb19-313"><a href="#cb19-313" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-314"><a href="#cb19-314" aria-hidden="true" tabindex="-1"></a>When we use a buffered IO system, at the first read operation we perform, instead of sending one single byte directly</span>
<span id="cb19-315"><a href="#cb19-315" aria-hidden="true" tabindex="-1"></a>to our program, the OS first sends a chunk of bytes from the file to a buffer object (i.e., an array).</span>
<span id="cb19-316"><a href="#cb19-316" aria-hidden="true" tabindex="-1"></a>This chunk of bytes are cached/stored inside this buffer object.</span>
<span id="cb19-317"><a href="#cb19-317" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-318"><a href="#cb19-318" aria-hidden="true" tabindex="-1"></a>Therefore, from now on, for every new read operation that you perform, instead of making a new system call to ask</span>
<span id="cb19-319"><a href="#cb19-319" aria-hidden="true" tabindex="-1"></a>for the next byte in the file to the OS, this read operation is redirected to the buffer object, that have</span>
<span id="cb19-320"><a href="#cb19-320" aria-hidden="true" tabindex="-1"></a>this next byte already cached and ready to go.</span>
<span id="cb19-321"><a href="#cb19-321" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-322"><a href="#cb19-322" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-323"><a href="#cb19-323" aria-hidden="true" tabindex="-1"></a><span class="ot">[^lorem]: &lt;https://www.lipsum.com/&gt;</span>.</span>
<span id="cb19-324"><a href="#cb19-324" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-325"><a href="#cb19-325" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-326"><a href="#cb19-326" aria-hidden="true" tabindex="-1"></a><span class="al">![Unbuffered IO](./../Figures/unbuffered-io.png)</span>{#fig-unbuffered-io width=60%}</span>
<span id="cb19-327"><a href="#cb19-327" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-328"><a href="#cb19-328" aria-hidden="true" tabindex="-1"></a><span class="al">![Buffered IO](./../Figures/buffered-io.png)</span>{#fig-buffered-io}</span>
<span id="cb19-329"><a href="#cb19-329" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-330"><a href="#cb19-330" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-331"><a href="#cb19-331" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-332"><a href="#cb19-332" aria-hidden="true" tabindex="-1"></a>This is the basic logic behind buffered IO systems. The size of the buffer object depends on multiple factors. But it's usually</span>
<span id="cb19-333"><a href="#cb19-333" aria-hidden="true" tabindex="-1"></a>equal to the size of a full page of memory (4096 bytes). If we follow this logic, then, the OS reads the first 4096 bytes</span>
<span id="cb19-334"><a href="#cb19-334" aria-hidden="true" tabindex="-1"></a>of the file and caches it into the buffer object. As long as your program does not consume all of these 4096 bytes from the buffer,</span>
<span id="cb19-335"><a href="#cb19-335" aria-hidden="true" tabindex="-1"></a>you will not create new system calls.</span>
<span id="cb19-336"><a href="#cb19-336" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-337"><a href="#cb19-337" aria-hidden="true" tabindex="-1"></a>However, as soon as you consume all of these 4096 bytes from the buffer, it means that there is no bytes left in the buffer.</span>
<span id="cb19-338"><a href="#cb19-338" aria-hidden="true" tabindex="-1"></a>In this situation, a new system call is made to ask the OS to send the next 4096 bytes in the file, and once again,</span>
<span id="cb19-339"><a href="#cb19-339" aria-hidden="true" tabindex="-1"></a>these bytes are cached into the buffer object, and the cycle starts once again.</span>
<span id="cb19-340"><a href="#cb19-340" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-341"><a href="#cb19-341" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-342"><a href="#cb19-342" aria-hidden="true" tabindex="-1"></a><span class="fu">### Buffered IO across different languages</span></span>
<span id="cb19-343"><a href="#cb19-343" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-344"><a href="#cb19-344" aria-hidden="true" tabindex="-1"></a>IO operations made through a <span class="in">`FILE`</span> pointer in C are buffered</span>
<span id="cb19-345"><a href="#cb19-345" aria-hidden="true" tabindex="-1"></a>by default, so, at least in C, you don't need to worry about this subject. But in contrast, IO operations in both Rust and Zig are not</span>
<span id="cb19-346"><a href="#cb19-346" aria-hidden="true" tabindex="-1"></a>buffered depending on which functions from the standard libraries that you are using.</span>
<span id="cb19-347"><a href="#cb19-347" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-348"><a href="#cb19-348" aria-hidden="true" tabindex="-1"></a>For example, in Rust, buffered IO is implemented through the <span class="in">`BufReader`</span> and <span class="in">`BufWriter`</span> structs, while in Zig, it's implemented</span>
<span id="cb19-349"><a href="#cb19-349" aria-hidden="true" tabindex="-1"></a>through the <span class="in">`BufferedReader`</span> and <span class="in">`BufferedWriter`</span> structs.</span>
<span id="cb19-350"><a href="#cb19-350" aria-hidden="true" tabindex="-1"></a>So any IO operation that you perform through the <span class="in">`GenericWriter`</span> and <span class="in">`GenericReader`</span> objects</span>
<span id="cb19-351"><a href="#cb19-351" aria-hidden="true" tabindex="-1"></a>that I presented in @sec-writer-reader are not buffered, which means that these objects</span>
<span id="cb19-352"><a href="#cb19-352" aria-hidden="true" tabindex="-1"></a>might create a lot of system calls depending on the situation.</span>
<span id="cb19-353"><a href="#cb19-353" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-354"><a href="#cb19-354" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-355"><a href="#cb19-355" aria-hidden="true" tabindex="-1"></a><span class="fu">### Using buffered IO in Zig</span></span>
<span id="cb19-356"><a href="#cb19-356" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-357"><a href="#cb19-357" aria-hidden="true" tabindex="-1"></a>Using buffered IO in Zig is actually very easy. All you have to do is to just</span>
<span id="cb19-358"><a href="#cb19-358" aria-hidden="true" tabindex="-1"></a>give the <span class="in">`GenericWriter`</span> object to the <span class="in">`bufferedWriter()`</span> function, or, to give the <span class="in">`GenericReader`</span></span>
<span id="cb19-359"><a href="#cb19-359" aria-hidden="true" tabindex="-1"></a>object to the <span class="in">`bufferedReader()`</span> function. These functions come from the <span class="in">`std.io`</span> module,</span>
<span id="cb19-360"><a href="#cb19-360" aria-hidden="true" tabindex="-1"></a>and they will construct the <span class="in">`BufferedWriter`</span> or <span class="in">`BufferedReader`</span> object for you.</span>
<span id="cb19-361"><a href="#cb19-361" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-362"><a href="#cb19-362" aria-hidden="true" tabindex="-1"></a>After you create this new <span class="in">`BufferedWriter`</span> or <span class="in">`BufferedReader`</span> object, you can call the <span class="in">`writer()`</span></span>
<span id="cb19-363"><a href="#cb19-363" aria-hidden="true" tabindex="-1"></a>or <span class="in">`reader()`</span> method of this new object, to get access to a new (and buffered) generic reader or</span>
<span id="cb19-364"><a href="#cb19-364" aria-hidden="true" tabindex="-1"></a>generic writer.</span>
<span id="cb19-365"><a href="#cb19-365" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-366"><a href="#cb19-366" aria-hidden="true" tabindex="-1"></a>Let's describe the process once again. Every time that you have a file descriptor object, you first get the generic writer or generic reader</span>
<span id="cb19-367"><a href="#cb19-367" aria-hidden="true" tabindex="-1"></a>object from it, by calling the <span class="in">`writer()`</span> or <span class="in">`reader()`</span> methods of this file descriptor object.</span>
<span id="cb19-368"><a href="#cb19-368" aria-hidden="true" tabindex="-1"></a>Then, you provide this generic writer or generic reader to the <span class="in">`bufferedWriter()`</span> or <span class="in">`bufferedReader()`</span></span>
<span id="cb19-369"><a href="#cb19-369" aria-hidden="true" tabindex="-1"></a>function, which creates a new <span class="in">`BufferedWriter`</span> or <span class="in">`BufferedReader`</span> object. Then, you call</span>
<span id="cb19-370"><a href="#cb19-370" aria-hidden="true" tabindex="-1"></a>the <span class="in">`writer()`</span> or <span class="in">`reader()`</span> methods of this buffered writer or buffered reader object,</span>
<span id="cb19-371"><a href="#cb19-371" aria-hidden="true" tabindex="-1"></a>which gives you access to a generic writer or a generic reader object that is buffered.</span>
<span id="cb19-372"><a href="#cb19-372" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-373"><a href="#cb19-373" aria-hidden="true" tabindex="-1"></a>Take this program as an example. This program is demonstrating the process exposed in @fig-buffered-io.</span>
<span id="cb19-374"><a href="#cb19-374" aria-hidden="true" tabindex="-1"></a>We are simply opening a text file that contains the Lorem ipsum text, and then, we create a buffered IO reader object</span>
<span id="cb19-375"><a href="#cb19-375" aria-hidden="true" tabindex="-1"></a>at <span class="in">`bufreader`</span>, and we use this <span class="in">`bufreader`</span> object to read the contents of this file into a buffer object, then,</span>
<span id="cb19-376"><a href="#cb19-376" aria-hidden="true" tabindex="-1"></a>we end the program by printing this buffer to <span class="in">`stdout`</span>.</span>
<span id="cb19-377"><a href="#cb19-377" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-378"><a href="#cb19-378" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-381"><a href="#cb19-381" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb19-382"><a href="#cb19-382" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb19-383"><a href="#cb19-383" aria-hidden="true" tabindex="-1"></a><span class="in">var file = try std.fs.cwd().openFile(</span></span>
<span id="cb19-384"><a href="#cb19-384" aria-hidden="true" tabindex="-1"></a><span class="in">    "ZigExamples/file-io/lorem.txt", .{}</span></span>
<span id="cb19-385"><a href="#cb19-385" aria-hidden="true" tabindex="-1"></a><span class="in">);</span></span>
<span id="cb19-386"><a href="#cb19-386" aria-hidden="true" tabindex="-1"></a><span class="in">defer file.close();</span></span>
<span id="cb19-387"><a href="#cb19-387" aria-hidden="true" tabindex="-1"></a><span class="in">var buffered = std.io.bufferedReader(file.reader());</span></span>
<span id="cb19-388"><a href="#cb19-388" aria-hidden="true" tabindex="-1"></a><span class="in">var bufreader = buffered.reader();</span></span>
<span id="cb19-389"><a href="#cb19-389" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-390"><a href="#cb19-390" aria-hidden="true" tabindex="-1"></a><span class="in">var buffer: [1000]u8 = undefined;</span></span>
<span id="cb19-391"><a href="#cb19-391" aria-hidden="true" tabindex="-1"></a><span class="in">@memset(buffer[0..], 0);</span></span>
<span id="cb19-392"><a href="#cb19-392" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-393"><a href="#cb19-393" aria-hidden="true" tabindex="-1"></a><span class="in">_ = try bufreader.readUntilDelimiterOrEof(</span></span>
<span id="cb19-394"><a href="#cb19-394" aria-hidden="true" tabindex="-1"></a><span class="in">    buffer[0..], '\n'</span></span>
<span id="cb19-395"><a href="#cb19-395" aria-hidden="true" tabindex="-1"></a><span class="in">);</span></span>
<span id="cb19-396"><a href="#cb19-396" aria-hidden="true" tabindex="-1"></a><span class="in">try stdout.print("{s}\n", .{buffer});</span></span>
<span id="cb19-397"><a href="#cb19-397" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-398"><a href="#cb19-398" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-399"><a href="#cb19-399" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-400"><a href="#cb19-400" aria-hidden="true" tabindex="-1"></a><span class="in">Lorem ipsum dolor sit amet, consectetur</span></span>
<span id="cb19-401"><a href="#cb19-401" aria-hidden="true" tabindex="-1"></a><span class="in">adipiscing elit. Sed tincidunt erat sed nulla ornare, nec</span></span>
<span id="cb19-402"><a href="#cb19-402" aria-hidden="true" tabindex="-1"></a><span class="in">aliquet ex laoreet. Ut nec rhoncus nunc. Integer magna metus,</span></span>
<span id="cb19-403"><a href="#cb19-403" aria-hidden="true" tabindex="-1"></a><span class="in">ultrices eleifend porttitor ut, finibus ut tortor. Maecenas</span></span>
<span id="cb19-404"><a href="#cb19-404" aria-hidden="true" tabindex="-1"></a><span class="in">sapien justo, finibus tincidunt dictum ac, semper et lectus.</span></span>
<span id="cb19-405"><a href="#cb19-405" aria-hidden="true" tabindex="-1"></a><span class="in">Vivamus molestie egestas orci ac viverra. Pellentesque nec</span></span>
<span id="cb19-406"><a href="#cb19-406" aria-hidden="true" tabindex="-1"></a><span class="in">arcu facilisis, euismod eros eu, sodales nisl. Ut egestas</span></span>
<span id="cb19-407"><a href="#cb19-407" aria-hidden="true" tabindex="-1"></a><span class="in">sagittis arcu, in accumsan sapien rhoncus sit amet. Aenean</span></span>
<span id="cb19-408"><a href="#cb19-408" aria-hidden="true" tabindex="-1"></a><span class="in">neque lectus, imperdiet ac lobortis a, ullamcorper sed massa.</span></span>
<span id="cb19-409"><a href="#cb19-409" aria-hidden="true" tabindex="-1"></a><span class="in">Nullam porttitor porttitor erat nec dapibus. Ut vel dui nec</span></span>
<span id="cb19-410"><a href="#cb19-410" aria-hidden="true" tabindex="-1"></a><span class="in">nulla vulputate molestie eget non nunc. Ut commodo luctus ipsum,</span></span>
<span id="cb19-411"><a href="#cb19-411" aria-hidden="true" tabindex="-1"></a><span class="in">in finibus libero feugiat eget. Etiam vel ante at urna tincidunt</span></span>
<span id="cb19-412"><a href="#cb19-412" aria-hidden="true" tabindex="-1"></a><span class="in">posuere sit amet ut felis. Maecenas finibus suscipit tristique.</span></span>
<span id="cb19-413"><a href="#cb19-413" aria-hidden="true" tabindex="-1"></a><span class="in">Donec viverra non sapien id suscipit.</span></span>
<span id="cb19-414"><a href="#cb19-414" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-415"><a href="#cb19-415" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-416"><a href="#cb19-416" aria-hidden="true" tabindex="-1"></a>Despite being a buffered IO reader, this <span class="in">`bufreader`</span> object is similar to any other <span class="in">`GenericReader`</span> object,</span>
<span id="cb19-417"><a href="#cb19-417" aria-hidden="true" tabindex="-1"></a>and have the exact same methods. So, although these two types of objects perform very different IO operations,</span>
<span id="cb19-418"><a href="#cb19-418" aria-hidden="true" tabindex="-1"></a>they have the same interface, so you, the programmer, can interchangeably use them</span>
<span id="cb19-419"><a href="#cb19-419" aria-hidden="true" tabindex="-1"></a>without the need to change anything in your source code.</span>
<span id="cb19-420"><a href="#cb19-420" aria-hidden="true" tabindex="-1"></a>So a buffered IO reader or a buffered IO writer objects have the same methods than its generic and unbuffered brothers,</span>
<span id="cb19-421"><a href="#cb19-421" aria-hidden="true" tabindex="-1"></a>i.e., the generic reader and generic writer objects that I presented in @sec-writer-reader.</span>
<span id="cb19-422"><a href="#cb19-422" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-423"><a href="#cb19-423" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb19-424"><a href="#cb19-424" aria-hidden="true" tabindex="-1"></a>In general, you should always use a buffered IO reader or a buffered IO writer object to perform</span>
<span id="cb19-425"><a href="#cb19-425" aria-hidden="true" tabindex="-1"></a>IO operations in Zig. Because they deliver better performance to your IO operations.</span>
<span id="cb19-426"><a href="#cb19-426" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb19-427"><a href="#cb19-427" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-428"><a href="#cb19-428" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-429"><a href="#cb19-429" aria-hidden="true" tabindex="-1"></a><span class="fu">## Filesystem basics</span></span>
<span id="cb19-430"><a href="#cb19-430" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-431"><a href="#cb19-431" aria-hidden="true" tabindex="-1"></a>Now that we have discussed the basics around Input/Output operations in Zig, we need to</span>
<span id="cb19-432"><a href="#cb19-432" aria-hidden="true" tabindex="-1"></a>talk about the basics around filesystems, which is another core part of any operating system.</span>
<span id="cb19-433"><a href="#cb19-433" aria-hidden="true" tabindex="-1"></a>Also, filesystems are related to input/output, because the files that we store and create in our</span>
<span id="cb19-434"><a href="#cb19-434" aria-hidden="true" tabindex="-1"></a>computer are considered an IO resource, as we described in @sec-file-descriptor.</span>
<span id="cb19-435"><a href="#cb19-435" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-436"><a href="#cb19-436" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-437"><a href="#cb19-437" aria-hidden="true" tabindex="-1"></a><span class="fu">### The concept of current working directory (CWD)</span></span>
<span id="cb19-438"><a href="#cb19-438" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-439"><a href="#cb19-439" aria-hidden="true" tabindex="-1"></a>The working directory is the folder on your computer where you are currently rooted at.</span>
<span id="cb19-440"><a href="#cb19-440" aria-hidden="true" tabindex="-1"></a>In other words, it's the folder that your program is currently looking at.</span>
<span id="cb19-441"><a href="#cb19-441" aria-hidden="true" tabindex="-1"></a>Therefore, whenever you are executing a program, this program is always working with</span>
<span id="cb19-442"><a href="#cb19-442" aria-hidden="true" tabindex="-1"></a>a specific folder on your computer. It's always in this folder that the program will initially</span>
<span id="cb19-443"><a href="#cb19-443" aria-hidden="true" tabindex="-1"></a>look for the files you require, and it's also in this folder that the program</span>
<span id="cb19-444"><a href="#cb19-444" aria-hidden="true" tabindex="-1"></a>will initially save all the files you ask it to save.</span>
<span id="cb19-445"><a href="#cb19-445" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-446"><a href="#cb19-446" aria-hidden="true" tabindex="-1"></a>The working directory is determined by the folder from which you invoke your program</span>
<span id="cb19-447"><a href="#cb19-447" aria-hidden="true" tabindex="-1"></a>in the terminal. In other words, if you are in the terminal of your OS, and you</span>
<span id="cb19-448"><a href="#cb19-448" aria-hidden="true" tabindex="-1"></a>execute a binary file (i.e., a program) from this terminal, the folder to which your terminal</span>
<span id="cb19-449"><a href="#cb19-449" aria-hidden="true" tabindex="-1"></a>is pointing at is the current working directory of your program that is being executed.</span>
<span id="cb19-450"><a href="#cb19-450" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-451"><a href="#cb19-451" aria-hidden="true" tabindex="-1"></a>In @fig-cwd we have an example of me executing a program from the terminal. We are executing</span>
<span id="cb19-452"><a href="#cb19-452" aria-hidden="true" tabindex="-1"></a>the program outputted by the <span class="in">`zig`</span> compiler by compiling the Zig module named <span class="in">`hello.zig`</span>.</span>
<span id="cb19-453"><a href="#cb19-453" aria-hidden="true" tabindex="-1"></a>The CWD in this case is the <span class="in">`zig-book`</span> folder. In other words, while the <span class="in">`hello.zig`</span> program</span>
<span id="cb19-454"><a href="#cb19-454" aria-hidden="true" tabindex="-1"></a>is executing, it will be looking at the <span class="in">`zig-book`</span> folder, and any file operation that we perform</span>
<span id="cb19-455"><a href="#cb19-455" aria-hidden="true" tabindex="-1"></a>inside this program, will be using this <span class="in">`zig-book`</span> folder as the "starting point", or, as the "central focus".</span>
<span id="cb19-456"><a href="#cb19-456" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-457"><a href="#cb19-457" aria-hidden="true" tabindex="-1"></a><span class="al">![Executing a program from the terminal](./../Figures/cwd.png)</span>{#fig-cwd}</span>
<span id="cb19-458"><a href="#cb19-458" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-459"><a href="#cb19-459" aria-hidden="true" tabindex="-1"></a>Just because we are rooted inside a particular folder (in the case of @fig-cwd, the <span class="in">`zig-book`</span> folder) of our computer,</span>
<span id="cb19-460"><a href="#cb19-460" aria-hidden="true" tabindex="-1"></a>it doesn't mean that we cannot access or write resources in other locations of our computer.</span>
<span id="cb19-461"><a href="#cb19-461" aria-hidden="true" tabindex="-1"></a>The current working directory (CWD) mechanism just defines where your program will look first</span>
<span id="cb19-462"><a href="#cb19-462" aria-hidden="true" tabindex="-1"></a>for the files you ask for. This does not prevent you from accessing files that are located</span>
<span id="cb19-463"><a href="#cb19-463" aria-hidden="true" tabindex="-1"></a>elsewhere on your computer. However, to access any file that is in a folder other than your</span>
<span id="cb19-464"><a href="#cb19-464" aria-hidden="true" tabindex="-1"></a>current working directory, you must provide a path to that file or folder.</span>
<span id="cb19-465"><a href="#cb19-465" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-466"><a href="#cb19-466" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-467"><a href="#cb19-467" aria-hidden="true" tabindex="-1"></a><span class="fu">### The concept of paths</span></span>
<span id="cb19-468"><a href="#cb19-468" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-469"><a href="#cb19-469" aria-hidden="true" tabindex="-1"></a>A path is essentially a location. It points to a location in your filesystem. We use</span>
<span id="cb19-470"><a href="#cb19-470" aria-hidden="true" tabindex="-1"></a>paths to describe the location of files and folders in our computer.</span>
<span id="cb19-471"><a href="#cb19-471" aria-hidden="true" tabindex="-1"></a>One important aspect about paths is that they are always written inside strings,</span>
<span id="cb19-472"><a href="#cb19-472" aria-hidden="true" tabindex="-1"></a>i.e., they are always provided as text values.</span>
<span id="cb19-473"><a href="#cb19-473" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-474"><a href="#cb19-474" aria-hidden="true" tabindex="-1"></a>There are two types of paths that you can provide to any program in any OS: a relative path, or an absolute path.</span>
<span id="cb19-475"><a href="#cb19-475" aria-hidden="true" tabindex="-1"></a>Absolute paths are paths that start at the root of your filesystem, and go all the way to the file name or the specific folder</span>
<span id="cb19-476"><a href="#cb19-476" aria-hidden="true" tabindex="-1"></a>that you are referring to. This type of path is called absolute, because it points to an unique and absolute location on your computer.</span>
<span id="cb19-477"><a href="#cb19-477" aria-hidden="true" tabindex="-1"></a>That is, there is no other existing location on your computer that corresponds to this path. It's an unique identifier.</span>
<span id="cb19-478"><a href="#cb19-478" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-479"><a href="#cb19-479" aria-hidden="true" tabindex="-1"></a>In Windows, an absolute path is a path that starts with a hard disk identifier (e.g. <span class="in">`C:/Users/pedro`</span>).</span>
<span id="cb19-480"><a href="#cb19-480" aria-hidden="true" tabindex="-1"></a>On the other hand, absolute paths in Linux and macOS, are paths that start with a forward slash character (e.g. <span class="in">`/usr/local/bin`</span>).</span>
<span id="cb19-481"><a href="#cb19-481" aria-hidden="true" tabindex="-1"></a>Notice that a path is composed by "segments". Each segment is connected to each other by a slash character (<span class="in">`\`</span> or <span class="in">`/`</span>).</span>
<span id="cb19-482"><a href="#cb19-482" aria-hidden="true" tabindex="-1"></a>On Windows, the backward slash (<span class="in">`\`</span>) is normally used to connect the path segments. While on Linux and macOS, the forward</span>
<span id="cb19-483"><a href="#cb19-483" aria-hidden="true" tabindex="-1"></a>slash (<span class="in">`/`</span>) is the character used to connect path segments.</span>
<span id="cb19-484"><a href="#cb19-484" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-485"><a href="#cb19-485" aria-hidden="true" tabindex="-1"></a>A relative path is a path that start at the CWD. In other words, a relative path is</span>
<span id="cb19-486"><a href="#cb19-486" aria-hidden="true" tabindex="-1"></a>"relative to the CWD". The path used to access the <span class="in">`hello.zig`</span> file in @fig-cwd is an example of a relative path. This path</span>
<span id="cb19-487"><a href="#cb19-487" aria-hidden="true" tabindex="-1"></a>is reproduced below. This path begins at the CWD, which in the context of @fig-cwd, is the <span class="in">`zig-book`</span> folder,</span>
<span id="cb19-488"><a href="#cb19-488" aria-hidden="true" tabindex="-1"></a>then, it goes to the <span class="in">`ZigExamples`</span> folder, then, into <span class="in">`zig-basics`</span>, then, to the <span class="in">`hello.zig`</span> file.</span>
<span id="cb19-489"><a href="#cb19-489" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-490"><a href="#cb19-490" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-491"><a href="#cb19-491" aria-hidden="true" tabindex="-1"></a><span class="in">ZigExamples/zig-basics/hello_world.zig</span></span>
<span id="cb19-492"><a href="#cb19-492" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-493"><a href="#cb19-493" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-494"><a href="#cb19-494" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-495"><a href="#cb19-495" aria-hidden="true" tabindex="-1"></a><span class="fu">### Path wildcards</span></span>
<span id="cb19-496"><a href="#cb19-496" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-497"><a href="#cb19-497" aria-hidden="true" tabindex="-1"></a>When providing paths, especially relative paths, you have the option of using a *wildcard*.</span>
<span id="cb19-498"><a href="#cb19-498" aria-hidden="true" tabindex="-1"></a>There are two commonly used *wildcards* in paths, which are "one period" (.) and "two periods" (..).</span>
<span id="cb19-499"><a href="#cb19-499" aria-hidden="true" tabindex="-1"></a>In other words, these two specific characters have special meanings when used in paths,</span>
<span id="cb19-500"><a href="#cb19-500" aria-hidden="true" tabindex="-1"></a>and can be used on any operating system (Mac, Windows, Linux, etc.). That is, they</span>
<span id="cb19-501"><a href="#cb19-501" aria-hidden="true" tabindex="-1"></a>are "cross platform".</span>
<span id="cb19-502"><a href="#cb19-502" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-503"><a href="#cb19-503" aria-hidden="true" tabindex="-1"></a>The "one period" represents an alias for the current directory.</span>
<span id="cb19-504"><a href="#cb19-504" aria-hidden="true" tabindex="-1"></a>This means that the relative paths <span class="in">`"./Course/Data/covid.csv"`</span> and <span class="in">`"Course/Data/covid.csv"`</span> are equivalent.</span>
<span id="cb19-505"><a href="#cb19-505" aria-hidden="true" tabindex="-1"></a>On the other hand, the "two periods" refers to the previous directory.</span>
<span id="cb19-506"><a href="#cb19-506" aria-hidden="true" tabindex="-1"></a>For example, the path <span class="in">`"Course/.."`</span> is equivalent to the path <span class="in">`"."`</span>, that is, the current working directory.</span>
<span id="cb19-507"><a href="#cb19-507" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-508"><a href="#cb19-508" aria-hidden="true" tabindex="-1"></a>Therefore, the path <span class="in">`"Course/.."`</span> refers to the folder before the <span class="in">`Course`</span> folder.</span>
<span id="cb19-509"><a href="#cb19-509" aria-hidden="true" tabindex="-1"></a>As another example, the path <span class="in">`"src/writexml/../xml.cpp"`</span> refers to the file <span class="in">`xml.cpp`</span></span>
<span id="cb19-510"><a href="#cb19-510" aria-hidden="true" tabindex="-1"></a>that is inside the folder before the <span class="in">`writexml`</span> folder, which in this example is the <span class="in">`src`</span> folder.</span>
<span id="cb19-511"><a href="#cb19-511" aria-hidden="true" tabindex="-1"></a>Therefore, this path is equivalent to <span class="in">`"src/xml.cpp"`</span>.</span>
<span id="cb19-512"><a href="#cb19-512" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-513"><a href="#cb19-513" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-514"><a href="#cb19-514" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-515"><a href="#cb19-515" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-516"><a href="#cb19-516" aria-hidden="true" tabindex="-1"></a><span class="fu">## The CWD handler</span></span>
<span id="cb19-517"><a href="#cb19-517" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-518"><a href="#cb19-518" aria-hidden="true" tabindex="-1"></a>In Zig, filesystem operations are usually made through a directory handler object.</span>
<span id="cb19-519"><a href="#cb19-519" aria-hidden="true" tabindex="-1"></a>A directory handler in Zig is an object of type <span class="in">`Dir`</span>, which is an object that describes</span>
<span id="cb19-520"><a href="#cb19-520" aria-hidden="true" tabindex="-1"></a>a particular folder in the filesystem of our computer.</span>
<span id="cb19-521"><a href="#cb19-521" aria-hidden="true" tabindex="-1"></a>You normally create a <span class="in">`Dir`</span> object, by calling the <span class="in">`std.fs.cwd()`</span> function.</span>
<span id="cb19-522"><a href="#cb19-522" aria-hidden="true" tabindex="-1"></a>This function returns a <span class="in">`Dir`</span> object that points to (or, that describes) the</span>
<span id="cb19-523"><a href="#cb19-523" aria-hidden="true" tabindex="-1"></a>current working directory (CWD).</span>
<span id="cb19-524"><a href="#cb19-524" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-525"><a href="#cb19-525" aria-hidden="true" tabindex="-1"></a>Through this <span class="in">`Dir`</span> object, you can create new files, or modify, or read existing ones that are</span>
<span id="cb19-526"><a href="#cb19-526" aria-hidden="true" tabindex="-1"></a>inside your CWD. In other words, a <span class="in">`Dir`</span> object is the main entrypoint in Zig to perform</span>
<span id="cb19-527"><a href="#cb19-527" aria-hidden="true" tabindex="-1"></a>multiple types of filesystem operations.</span>
<span id="cb19-528"><a href="#cb19-528" aria-hidden="true" tabindex="-1"></a>In the example below, we are creating this <span class="in">`Dir`</span> object, and storing it</span>
<span id="cb19-529"><a href="#cb19-529" aria-hidden="true" tabindex="-1"></a>inside the <span class="in">`cwd`</span> object. Although we are not using this object at this code example,</span>
<span id="cb19-530"><a href="#cb19-530" aria-hidden="true" tabindex="-1"></a>we are going to use it a lot over the next examples.</span>
<span id="cb19-531"><a href="#cb19-531" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-534"><a href="#cb19-534" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb19-535"><a href="#cb19-535" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb19-536"><a href="#cb19-536" aria-hidden="true" tabindex="-1"></a><span class="in">const cwd = std.fs.cwd();</span></span>
<span id="cb19-537"><a href="#cb19-537" aria-hidden="true" tabindex="-1"></a><span class="in">_ = cwd;</span></span>
<span id="cb19-538"><a href="#cb19-538" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-539"><a href="#cb19-539" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-540"><a href="#cb19-540" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-541"><a href="#cb19-541" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-542"><a href="#cb19-542" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-543"><a href="#cb19-543" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-544"><a href="#cb19-544" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-545"><a href="#cb19-545" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-546"><a href="#cb19-546" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-547"><a href="#cb19-547" aria-hidden="true" tabindex="-1"></a><span class="fu">## File operations</span></span>
<span id="cb19-548"><a href="#cb19-548" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-549"><a href="#cb19-549" aria-hidden="true" tabindex="-1"></a><span class="fu">### Creating files {#sec-creating-files}</span></span>
<span id="cb19-550"><a href="#cb19-550" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-551"><a href="#cb19-551" aria-hidden="true" tabindex="-1"></a>We create new files by using the <span class="in">`createFile()`</span> method from the <span class="in">`Dir`</span> object.</span>
<span id="cb19-552"><a href="#cb19-552" aria-hidden="true" tabindex="-1"></a>Just provide the name of the file that you want to create, and this function will</span>
<span id="cb19-553"><a href="#cb19-553" aria-hidden="true" tabindex="-1"></a>do the necessary steps to create such file. You can also provide a relative path to this function,</span>
<span id="cb19-554"><a href="#cb19-554" aria-hidden="true" tabindex="-1"></a>and it will create the file by following this path, which is relative to the CWD.</span>
<span id="cb19-555"><a href="#cb19-555" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-556"><a href="#cb19-556" aria-hidden="true" tabindex="-1"></a>This function might return an error, so, you should use <span class="in">`try`</span>, <span class="in">`catch`</span>, or any of the other methods presented</span>
<span id="cb19-557"><a href="#cb19-557" aria-hidden="true" tabindex="-1"></a>in @sec-error-handling to handle the possible error. But if everything goes well,</span>
<span id="cb19-558"><a href="#cb19-558" aria-hidden="true" tabindex="-1"></a>this <span class="in">`createFile()`</span> method returns a file descriptor object (i.e., a <span class="in">`File`</span> object) as result,</span>
<span id="cb19-559"><a href="#cb19-559" aria-hidden="true" tabindex="-1"></a>through which you can add content to the file with the IO operations that I presented before.</span>
<span id="cb19-560"><a href="#cb19-560" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-561"><a href="#cb19-561" aria-hidden="true" tabindex="-1"></a>Take this code example below. In this example, we are creating a new text file</span>
<span id="cb19-562"><a href="#cb19-562" aria-hidden="true" tabindex="-1"></a>named <span class="in">`foo.txt`</span>. If the function <span class="in">`createFile()`</span> succeeds, the object named <span class="in">`file`</span> will contain a file descriptor</span>
<span id="cb19-563"><a href="#cb19-563" aria-hidden="true" tabindex="-1"></a>object, which we can use to write (or add) new content to the file, like we do in this example, by using</span>
<span id="cb19-564"><a href="#cb19-564" aria-hidden="true" tabindex="-1"></a>a buffered writer object to write a new line of text to the file.</span>
<span id="cb19-565"><a href="#cb19-565" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-566"><a href="#cb19-566" aria-hidden="true" tabindex="-1"></a>Now, a quick note, when we create a file descriptor object in C, by using a C function like <span class="in">`fopen()`</span>, we must always close the file</span>
<span id="cb19-567"><a href="#cb19-567" aria-hidden="true" tabindex="-1"></a>at the end of our program, or, as soon as we complete all operations that we wanted to perform</span>
<span id="cb19-568"><a href="#cb19-568" aria-hidden="true" tabindex="-1"></a>on the file. In Zig, this is no different. So everytime we create a new file, this file remains</span>
<span id="cb19-569"><a href="#cb19-569" aria-hidden="true" tabindex="-1"></a>"open", waiting for some operation to be performed. As soon as we are done with it, we always have</span>
<span id="cb19-570"><a href="#cb19-570" aria-hidden="true" tabindex="-1"></a>to close this file, to free the resources associated with it.</span>
<span id="cb19-571"><a href="#cb19-571" aria-hidden="true" tabindex="-1"></a>In Zig, we do this by calling the method <span class="in">`close()`</span> from the file descriptor object.</span>
<span id="cb19-572"><a href="#cb19-572" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-573"><a href="#cb19-573" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-576"><a href="#cb19-576" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb19-577"><a href="#cb19-577" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb19-578"><a href="#cb19-578" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb19-579"><a href="#cb19-579" aria-hidden="true" tabindex="-1"></a><span class="in">const cwd = std.fs.cwd();</span></span>
<span id="cb19-580"><a href="#cb19-580" aria-hidden="true" tabindex="-1"></a><span class="in">const file = try cwd.createFile("foo.txt", .{});</span></span>
<span id="cb19-581"><a href="#cb19-581" aria-hidden="true" tabindex="-1"></a><span class="in">// Don't forget to close the file at the end.</span></span>
<span id="cb19-582"><a href="#cb19-582" aria-hidden="true" tabindex="-1"></a><span class="in">defer file.close();</span></span>
<span id="cb19-583"><a href="#cb19-583" aria-hidden="true" tabindex="-1"></a><span class="in">// Do things with the file ...</span></span>
<span id="cb19-584"><a href="#cb19-584" aria-hidden="true" tabindex="-1"></a><span class="in">var fw = file.writer();</span></span>
<span id="cb19-585"><a href="#cb19-585" aria-hidden="true" tabindex="-1"></a><span class="in">_ = try fw.writeAll(</span></span>
<span id="cb19-586"><a href="#cb19-586" aria-hidden="true" tabindex="-1"></a><span class="in">    "Writing this line to the file\n"</span></span>
<span id="cb19-587"><a href="#cb19-587" aria-hidden="true" tabindex="-1"></a><span class="in">);</span></span>
<span id="cb19-588"><a href="#cb19-588" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-589"><a href="#cb19-589" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-590"><a href="#cb19-590" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-591"><a href="#cb19-591" aria-hidden="true" tabindex="-1"></a>So, in this example we not only have created a file into the filesystem,</span>
<span id="cb19-592"><a href="#cb19-592" aria-hidden="true" tabindex="-1"></a>but we also wrote some data into this file, using the file descriptor object</span>
<span id="cb19-593"><a href="#cb19-593" aria-hidden="true" tabindex="-1"></a>returned by <span class="in">`createFile()`</span>. If the file that you are trying to create</span>
<span id="cb19-594"><a href="#cb19-594" aria-hidden="true" tabindex="-1"></a>already exists in your filesystem, this <span class="in">`createFile()`</span> call will</span>
<span id="cb19-595"><a href="#cb19-595" aria-hidden="true" tabindex="-1"></a>overwrite the contents of the file, or, in other words, it will</span>
<span id="cb19-596"><a href="#cb19-596" aria-hidden="true" tabindex="-1"></a>in erase all the contents of the existing file.</span>
<span id="cb19-597"><a href="#cb19-597" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-598"><a href="#cb19-598" aria-hidden="true" tabindex="-1"></a>If you don't want this to happen, meaning, that you don't want to overwrite</span>
<span id="cb19-599"><a href="#cb19-599" aria-hidden="true" tabindex="-1"></a>the contents of the existing file, but you want to write data to this file anyway</span>
<span id="cb19-600"><a href="#cb19-600" aria-hidden="true" tabindex="-1"></a>(i.e., you want to append data to the file), you should use the <span class="in">`openFile()`</span></span>
<span id="cb19-601"><a href="#cb19-601" aria-hidden="true" tabindex="-1"></a>method from the <span class="in">`Dir`</span> object.</span>
<span id="cb19-602"><a href="#cb19-602" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-603"><a href="#cb19-603" aria-hidden="true" tabindex="-1"></a>Another important aspect about <span class="in">`createFile()`</span> is that this method creates a file</span>
<span id="cb19-604"><a href="#cb19-604" aria-hidden="true" tabindex="-1"></a>that is not open to read operations by default. It means that you cannot read this file.</span>
<span id="cb19-605"><a href="#cb19-605" aria-hidden="true" tabindex="-1"></a>You are not allowed to.</span>
<span id="cb19-606"><a href="#cb19-606" aria-hidden="true" tabindex="-1"></a>So for example, you might want to write some stuff into this file at the beginning of the execution</span>
<span id="cb19-607"><a href="#cb19-607" aria-hidden="true" tabindex="-1"></a>of your program. Then, at a future point in your program you might need to read what you</span>
<span id="cb19-608"><a href="#cb19-608" aria-hidden="true" tabindex="-1"></a>wrote in this file. If you try to read data from this file, you will likely</span>
<span id="cb19-609"><a href="#cb19-609" aria-hidden="true" tabindex="-1"></a>get a <span class="in">`NotOpenForReading`</span> error as result.</span>
<span id="cb19-610"><a href="#cb19-610" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-611"><a href="#cb19-611" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-612"><a href="#cb19-612" aria-hidden="true" tabindex="-1"></a>But how can you overcome this barrier? How can you create a file that is open</span>
<span id="cb19-613"><a href="#cb19-613" aria-hidden="true" tabindex="-1"></a>to read operations? All you have to do, is to set the <span class="in">`read`</span> flag to true</span>
<span id="cb19-614"><a href="#cb19-614" aria-hidden="true" tabindex="-1"></a>in the second argument of <span class="in">`createFile()`</span>. When you set this flag to true,</span>
<span id="cb19-615"><a href="#cb19-615" aria-hidden="true" tabindex="-1"></a>then the file gets create with "read permissions", and, as consequence,</span>
<span id="cb19-616"><a href="#cb19-616" aria-hidden="true" tabindex="-1"></a>a program like this one below becomes valid:</span>
<span id="cb19-617"><a href="#cb19-617" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-618"><a href="#cb19-618" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-621"><a href="#cb19-621" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb19-622"><a href="#cb19-622" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb19-623"><a href="#cb19-623" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb19-624"><a href="#cb19-624" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb19-625"><a href="#cb19-625" aria-hidden="true" tabindex="-1"></a><span class="in">const cwd = std.fs.cwd();</span></span>
<span id="cb19-626"><a href="#cb19-626" aria-hidden="true" tabindex="-1"></a><span class="in">const file = try cwd.createFile(</span></span>
<span id="cb19-627"><a href="#cb19-627" aria-hidden="true" tabindex="-1"></a><span class="in">    "foo.txt",</span></span>
<span id="cb19-628"><a href="#cb19-628" aria-hidden="true" tabindex="-1"></a><span class="in">    .{ .read = true }</span></span>
<span id="cb19-629"><a href="#cb19-629" aria-hidden="true" tabindex="-1"></a><span class="in">);</span></span>
<span id="cb19-630"><a href="#cb19-630" aria-hidden="true" tabindex="-1"></a><span class="in">defer file.close();</span></span>
<span id="cb19-631"><a href="#cb19-631" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-632"><a href="#cb19-632" aria-hidden="true" tabindex="-1"></a><span class="in">var fw = file.writer();</span></span>
<span id="cb19-633"><a href="#cb19-633" aria-hidden="true" tabindex="-1"></a><span class="in">_ = try fw.writeAll("We are going to read this line\n");</span></span>
<span id="cb19-634"><a href="#cb19-634" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-635"><a href="#cb19-635" aria-hidden="true" tabindex="-1"></a><span class="in">var buffer: [300]u8 = undefined;</span></span>
<span id="cb19-636"><a href="#cb19-636" aria-hidden="true" tabindex="-1"></a><span class="in">@memset(buffer[0..], 0);</span></span>
<span id="cb19-637"><a href="#cb19-637" aria-hidden="true" tabindex="-1"></a><span class="in">try file.seekTo(0);</span></span>
<span id="cb19-638"><a href="#cb19-638" aria-hidden="true" tabindex="-1"></a><span class="in">var fr = file.reader();</span></span>
<span id="cb19-639"><a href="#cb19-639" aria-hidden="true" tabindex="-1"></a><span class="in">_ = try fr.readAll(buffer[0..]);</span></span>
<span id="cb19-640"><a href="#cb19-640" aria-hidden="true" tabindex="-1"></a><span class="in">try stdout.print("{s}\n", .{buffer});</span></span>
<span id="cb19-641"><a href="#cb19-641" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-642"><a href="#cb19-642" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-643"><a href="#cb19-643" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-644"><a href="#cb19-644" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-645"><a href="#cb19-645" aria-hidden="true" tabindex="-1"></a><span class="in">We are going to read this line</span></span>
<span id="cb19-646"><a href="#cb19-646" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-647"><a href="#cb19-647" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-648"><a href="#cb19-648" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-649"><a href="#cb19-649" aria-hidden="true" tabindex="-1"></a>If you are not familiar with position indicators, you might not recognize the method</span>
<span id="cb19-650"><a href="#cb19-650" aria-hidden="true" tabindex="-1"></a><span class="in">`seekTo()`</span>. If that is your case, do not worry,</span>
<span id="cb19-651"><a href="#cb19-651" aria-hidden="true" tabindex="-1"></a>we are going to talk more about this method in @sec-indicators. But essentially</span>
<span id="cb19-652"><a href="#cb19-652" aria-hidden="true" tabindex="-1"></a>this method is moving the position indicator back to the beginning of the file,</span>
<span id="cb19-653"><a href="#cb19-653" aria-hidden="true" tabindex="-1"></a>so that we can read the contents of the file from the beginning.</span>
<span id="cb19-654"><a href="#cb19-654" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-655"><a href="#cb19-655" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-656"><a href="#cb19-656" aria-hidden="true" tabindex="-1"></a><span class="fu">### Opening files and appending data to it</span></span>
<span id="cb19-657"><a href="#cb19-657" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-658"><a href="#cb19-658" aria-hidden="true" tabindex="-1"></a>Opening files is easy. Just use the <span class="in">`openFile()`</span> method instead of <span class="in">`createFile()`</span>.</span>
<span id="cb19-659"><a href="#cb19-659" aria-hidden="true" tabindex="-1"></a>In the first argument of <span class="in">`openFile()`</span> you provide the path to the file that</span>
<span id="cb19-660"><a href="#cb19-660" aria-hidden="true" tabindex="-1"></a>you want to open. Then, on the second argument you provide the flags (or, the options)</span>
<span id="cb19-661"><a href="#cb19-661" aria-hidden="true" tabindex="-1"></a>that dictates how the file is opened.</span>
<span id="cb19-662"><a href="#cb19-662" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-663"><a href="#cb19-663" aria-hidden="true" tabindex="-1"></a>You can see the full list of options for <span class="in">`openFile()`</span> by visiting the documentation for</span>
<span id="cb19-664"><a href="#cb19-664" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">`OpenFlags`</span><span class="co">](https://ziglang.org/documentation/master/std/#std.fs.File.OpenFlags)</span><span class="ot">[^oflags]</span>.</span>
<span id="cb19-665"><a href="#cb19-665" aria-hidden="true" tabindex="-1"></a>But the main flag that you will most certainly use is the <span class="in">`mode`</span> flag.</span>
<span id="cb19-666"><a href="#cb19-666" aria-hidden="true" tabindex="-1"></a>This flag specifies the IO mode that the file will be using when it gets opened.</span>
<span id="cb19-667"><a href="#cb19-667" aria-hidden="true" tabindex="-1"></a>There are three IO modes, or, three values that you can provide to this flag, which are:</span>
<span id="cb19-668"><a href="#cb19-668" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-669"><a href="#cb19-669" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`read_only`</span>, allows only read operations on the file. All write operations are blocked.</span>
<span id="cb19-670"><a href="#cb19-670" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`write_only`</span>, allows only write operations on the file. All read operations are blocked.</span>
<span id="cb19-671"><a href="#cb19-671" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`read_write`</span>, allows both write and read operations on the file.</span>
<span id="cb19-672"><a href="#cb19-672" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-673"><a href="#cb19-673" aria-hidden="true" tabindex="-1"></a><span class="ot">[^oflags]: &lt;https://ziglang.org/documentation/master/std/#std.fs.File.OpenFlags&gt;</span></span>
<span id="cb19-674"><a href="#cb19-674" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-675"><a href="#cb19-675" aria-hidden="true" tabindex="-1"></a>These modes are similar to the modes that you provide to the <span class="in">`mode`</span> argument of the</span>
<span id="cb19-676"><a href="#cb19-676" aria-hidden="true" tabindex="-1"></a><span class="in">`open()`</span> Python built-in function<span class="ot">[^py-open]</span>, or, the <span class="in">`mode`</span> argument of the</span>
<span id="cb19-677"><a href="#cb19-677" aria-hidden="true" tabindex="-1"></a><span class="in">`fopen()`</span> C function<span class="ot">[^c-open]</span>.</span>
<span id="cb19-678"><a href="#cb19-678" aria-hidden="true" tabindex="-1"></a>In the code example below, we are opening the <span class="in">`foo.txt`</span> text file with a <span class="in">`write_only`</span> mode,</span>
<span id="cb19-679"><a href="#cb19-679" aria-hidden="true" tabindex="-1"></a>and appending a new line of text to the end of the file. We use <span class="in">`seekFromEnd()`</span> this time</span>
<span id="cb19-680"><a href="#cb19-680" aria-hidden="true" tabindex="-1"></a>to guarantee that we are going to append the text to the end of the file. Once again, methods</span>
<span id="cb19-681"><a href="#cb19-681" aria-hidden="true" tabindex="-1"></a>such as <span class="in">`seekFromEnd()`</span> are described in more depth in @sec-indicators.</span>
<span id="cb19-682"><a href="#cb19-682" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-683"><a href="#cb19-683" aria-hidden="true" tabindex="-1"></a><span class="ot">[^py-open]: &lt;https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files&gt;</span></span>
<span id="cb19-684"><a href="#cb19-684" aria-hidden="true" tabindex="-1"></a><span class="ot">[^c-open]: &lt;https://www.tutorialspoint.com/c_standard_library/c_function_fopen.htm&gt;</span></span>
<span id="cb19-685"><a href="#cb19-685" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-686"><a href="#cb19-686" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-687"><a href="#cb19-687" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-690"><a href="#cb19-690" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb19-691"><a href="#cb19-691" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb19-692"><a href="#cb19-692" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb19-693"><a href="#cb19-693" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb19-694"><a href="#cb19-694" aria-hidden="true" tabindex="-1"></a><span class="in">const cwd = std.fs.cwd();</span></span>
<span id="cb19-695"><a href="#cb19-695" aria-hidden="true" tabindex="-1"></a><span class="in">const file = try cwd.openFile(</span></span>
<span id="cb19-696"><a href="#cb19-696" aria-hidden="true" tabindex="-1"></a><span class="in">    "foo.txt", .{ .mode = .write_only }</span></span>
<span id="cb19-697"><a href="#cb19-697" aria-hidden="true" tabindex="-1"></a><span class="in">);</span></span>
<span id="cb19-698"><a href="#cb19-698" aria-hidden="true" tabindex="-1"></a><span class="in">defer file.close();</span></span>
<span id="cb19-699"><a href="#cb19-699" aria-hidden="true" tabindex="-1"></a><span class="in">try file.seekFromEnd(0);</span></span>
<span id="cb19-700"><a href="#cb19-700" aria-hidden="true" tabindex="-1"></a><span class="in">var fw = file.writer();</span></span>
<span id="cb19-701"><a href="#cb19-701" aria-hidden="true" tabindex="-1"></a><span class="in">_ = try fw.writeAll("Some random text to write\n");</span></span>
<span id="cb19-702"><a href="#cb19-702" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-703"><a href="#cb19-703" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-704"><a href="#cb19-704" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-705"><a href="#cb19-705" aria-hidden="true" tabindex="-1"></a><span class="fu">### Deleting files</span></span>
<span id="cb19-706"><a href="#cb19-706" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-707"><a href="#cb19-707" aria-hidden="true" tabindex="-1"></a>Sometimes, we just need to delete/remove the files that we have.</span>
<span id="cb19-708"><a href="#cb19-708" aria-hidden="true" tabindex="-1"></a>To do that, we use the <span class="in">`deleteFile()`</span> method. You just provide the path of the</span>
<span id="cb19-709"><a href="#cb19-709" aria-hidden="true" tabindex="-1"></a>file that you want to delete, and this method will try to delete the file located</span>
<span id="cb19-710"><a href="#cb19-710" aria-hidden="true" tabindex="-1"></a>at this path.</span>
<span id="cb19-711"><a href="#cb19-711" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-714"><a href="#cb19-714" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb19-715"><a href="#cb19-715" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb19-716"><a href="#cb19-716" aria-hidden="true" tabindex="-1"></a><span class="in">const cwd = std.fs.cwd();</span></span>
<span id="cb19-717"><a href="#cb19-717" aria-hidden="true" tabindex="-1"></a><span class="in">try cwd.deleteFile("foo.txt");</span></span>
<span id="cb19-718"><a href="#cb19-718" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-719"><a href="#cb19-719" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-720"><a href="#cb19-720" aria-hidden="true" tabindex="-1"></a><span class="fu">### Copying files</span></span>
<span id="cb19-721"><a href="#cb19-721" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-722"><a href="#cb19-722" aria-hidden="true" tabindex="-1"></a>To copy existing files, we use the <span class="in">`copyFile()`</span> method. The first argument in this method</span>
<span id="cb19-723"><a href="#cb19-723" aria-hidden="true" tabindex="-1"></a>is the path to the file that you want to copy. The second argument is a <span class="in">`Dir`</span> object, i.e., a directory handler,</span>
<span id="cb19-724"><a href="#cb19-724" aria-hidden="true" tabindex="-1"></a>more specifically, a <span class="in">`Dir`</span> object that points to the folder in your computer where you want to</span>
<span id="cb19-725"><a href="#cb19-725" aria-hidden="true" tabindex="-1"></a>copy the file to. The third argument is the new path of the file, or, in other words, the new location</span>
<span id="cb19-726"><a href="#cb19-726" aria-hidden="true" tabindex="-1"></a>of the file. The fourth argument is the options (or flags) to be used in the copy operation.</span>
<span id="cb19-727"><a href="#cb19-727" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-728"><a href="#cb19-728" aria-hidden="true" tabindex="-1"></a>The <span class="in">`Dir`</span> object that you provide as input to this method will be used to copy the file to</span>
<span id="cb19-729"><a href="#cb19-729" aria-hidden="true" tabindex="-1"></a>the new location. You may create this <span class="in">`Dir`</span> object before calling the <span class="in">`copyFile()`</span> method.</span>
<span id="cb19-730"><a href="#cb19-730" aria-hidden="true" tabindex="-1"></a>Maybe you are planning to copy the file to a completely different location in your computer,</span>
<span id="cb19-731"><a href="#cb19-731" aria-hidden="true" tabindex="-1"></a>so it might be worth to create a directory handler to that location. But if you are copying the</span>
<span id="cb19-732"><a href="#cb19-732" aria-hidden="true" tabindex="-1"></a>file to a subfolder of your CWD, then, you can just simply pass the CWD handler to this argument.</span>
<span id="cb19-733"><a href="#cb19-733" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-736"><a href="#cb19-736" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb19-737"><a href="#cb19-737" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb19-738"><a href="#cb19-738" aria-hidden="true" tabindex="-1"></a><span class="in">const cwd = std.fs.cwd();</span></span>
<span id="cb19-739"><a href="#cb19-739" aria-hidden="true" tabindex="-1"></a><span class="in">try cwd.copyFile(</span></span>
<span id="cb19-740"><a href="#cb19-740" aria-hidden="true" tabindex="-1"></a><span class="in">    "foo.txt",</span></span>
<span id="cb19-741"><a href="#cb19-741" aria-hidden="true" tabindex="-1"></a><span class="in">    cwd,</span></span>
<span id="cb19-742"><a href="#cb19-742" aria-hidden="true" tabindex="-1"></a><span class="in">    "ZigExamples/file-io/foo.txt",</span></span>
<span id="cb19-743"><a href="#cb19-743" aria-hidden="true" tabindex="-1"></a><span class="in">    .{}</span></span>
<span id="cb19-744"><a href="#cb19-744" aria-hidden="true" tabindex="-1"></a><span class="in">);</span></span>
<span id="cb19-745"><a href="#cb19-745" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-746"><a href="#cb19-746" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-747"><a href="#cb19-747" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-748"><a href="#cb19-748" aria-hidden="true" tabindex="-1"></a><span class="fu">### Read the docs!</span></span>
<span id="cb19-749"><a href="#cb19-749" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-750"><a href="#cb19-750" aria-hidden="true" tabindex="-1"></a>There are some other useful methods for file operations available at <span class="in">`Dir`</span> objects,</span>
<span id="cb19-751"><a href="#cb19-751" aria-hidden="true" tabindex="-1"></a>such as the <span class="in">`writeFile()`</span> method, but I recommend you to read the docs for the</span>
<span id="cb19-752"><a href="#cb19-752" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">`Dir` type</span><span class="co">](https://ziglang.org/documentation/master/std/#std.fs.Dir)</span><span class="ot">[^zig-dir]</span></span>
<span id="cb19-753"><a href="#cb19-753" aria-hidden="true" tabindex="-1"></a>to explore the other available methods, since I already talked too much about them.</span>
<span id="cb19-754"><a href="#cb19-754" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-755"><a href="#cb19-755" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-756"><a href="#cb19-756" aria-hidden="true" tabindex="-1"></a><span class="ot">[^zig-dir]: &lt;https://ziglang.org/documentation/master/std/#std.fs.Dir&gt;</span></span>
<span id="cb19-757"><a href="#cb19-757" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-758"><a href="#cb19-758" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-759"><a href="#cb19-759" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-760"><a href="#cb19-760" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-761"><a href="#cb19-761" aria-hidden="true" tabindex="-1"></a><span class="fu">## Position indicators {#sec-indicators}</span></span>
<span id="cb19-762"><a href="#cb19-762" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-763"><a href="#cb19-763" aria-hidden="true" tabindex="-1"></a>A position indicator is like a type of cursor, or, an index. This "index" identifies the current</span>
<span id="cb19-764"><a href="#cb19-764" aria-hidden="true" tabindex="-1"></a>location in the file (or, in the data stream) that the file descriptor object that you have</span>
<span id="cb19-765"><a href="#cb19-765" aria-hidden="true" tabindex="-1"></a>is currently looking at.</span>
<span id="cb19-766"><a href="#cb19-766" aria-hidden="true" tabindex="-1"></a>When you create a file descriptor, the position indicator starts at the beginning of the file,</span>
<span id="cb19-767"><a href="#cb19-767" aria-hidden="true" tabindex="-1"></a>or, at the beginning of the stream. When you read from or write into the file (or socket, or data stream, etc.)</span>
<span id="cb19-768"><a href="#cb19-768" aria-hidden="true" tabindex="-1"></a>described by this file descriptor object, you end up moving the position indicator.</span>
<span id="cb19-769"><a href="#cb19-769" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-770"><a href="#cb19-770" aria-hidden="true" tabindex="-1"></a>In other words, any IO operation have a common side effect, which is to move the position indicator.</span>
<span id="cb19-771"><a href="#cb19-771" aria-hidden="true" tabindex="-1"></a>For example, suppose that we have a file of 300 bytes total in size. If you</span>
<span id="cb19-772"><a href="#cb19-772" aria-hidden="true" tabindex="-1"></a>read 100 bytes from the file, then, the position indicator moves 100 bytes forward. If you try</span>
<span id="cb19-773"><a href="#cb19-773" aria-hidden="true" tabindex="-1"></a>to write 50 bytes into this same file, these 50 bytes will be written from the current</span>
<span id="cb19-774"><a href="#cb19-774" aria-hidden="true" tabindex="-1"></a>position indicated by the position indicator. Since the indicator is at a 100 bytes forward from</span>
<span id="cb19-775"><a href="#cb19-775" aria-hidden="true" tabindex="-1"></a>the beginning of the file, these 50 bytes would be written in the middle of the file.</span>
<span id="cb19-776"><a href="#cb19-776" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-777"><a href="#cb19-777" aria-hidden="true" tabindex="-1"></a>This is why we have used the <span class="in">`seekTo()`</span> method at the last code example presented in @sec-creating-files.</span>
<span id="cb19-778"><a href="#cb19-778" aria-hidden="true" tabindex="-1"></a>We have used this method to move the position indicator back to the beginning of the file, which</span>
<span id="cb19-779"><a href="#cb19-779" aria-hidden="true" tabindex="-1"></a>would make sure that we would write the text that we wanted to write from the beginning of the file,</span>
<span id="cb19-780"><a href="#cb19-780" aria-hidden="true" tabindex="-1"></a>instead of writing it from the middle of the file. Because before the write operation, we had</span>
<span id="cb19-781"><a href="#cb19-781" aria-hidden="true" tabindex="-1"></a>performed a read operation, which means that the position indicator was moved in this read operation.</span>
<span id="cb19-782"><a href="#cb19-782" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-783"><a href="#cb19-783" aria-hidden="true" tabindex="-1"></a>The position indicators of a file descriptor object can be changed (or altered) by using the</span>
<span id="cb19-784"><a href="#cb19-784" aria-hidden="true" tabindex="-1"></a>"seek" methods from this file descriptor, which are: <span class="in">`seekTo()`</span>, <span class="in">`seekFromEnd()`</span> and <span class="in">`seekBy()`</span>.</span>
<span id="cb19-785"><a href="#cb19-785" aria-hidden="true" tabindex="-1"></a>These methods have the same effect, or, the same responsibility that the</span>
<span id="cb19-786"><a href="#cb19-786" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">`fseek()`</span><span class="co">](https://en.cppreference.com/w/c/io/fseek)</span><span class="ot">[^c-fseek]</span> C function.</span>
<span id="cb19-787"><a href="#cb19-787" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-788"><a href="#cb19-788" aria-hidden="true" tabindex="-1"></a><span class="ot">[^c-fseek]: &lt;https://en.cppreference.com/w/c/io/fseek&gt;</span></span>
<span id="cb19-789"><a href="#cb19-789" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-790"><a href="#cb19-790" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-791"><a href="#cb19-791" aria-hidden="true" tabindex="-1"></a>Considering that <span class="in">`offset`</span> refers to the index that you provide as input to these "seek" methods,</span>
<span id="cb19-792"><a href="#cb19-792" aria-hidden="true" tabindex="-1"></a>the bullet points below summarises what is the effect of each of these methods.</span>
<span id="cb19-793"><a href="#cb19-793" aria-hidden="true" tabindex="-1"></a>As a quick note, in the case of <span class="in">`seekFromEnd()`</span> and <span class="in">`seekBy()`</span>, the <span class="in">`offset`</span> provided can be either a</span>
<span id="cb19-794"><a href="#cb19-794" aria-hidden="true" tabindex="-1"></a>positive or a negative index.</span>
<span id="cb19-795"><a href="#cb19-795" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-796"><a href="#cb19-796" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`seekTo()`</span> will move the position indicator to the location that is <span class="in">`offset`</span> bytes from the beginning of the file.</span>
<span id="cb19-797"><a href="#cb19-797" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`seekFromEnd()`</span> will move the position indicator to the location that is <span class="in">`offset`</span> bytes from the end of the file.</span>
<span id="cb19-798"><a href="#cb19-798" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`seekBy()`</span> will move the position indicator to the location that is <span class="in">`offset`</span> bytes from the current position in the file.</span>
<span id="cb19-799"><a href="#cb19-799" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-800"><a href="#cb19-800" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-801"><a href="#cb19-801" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-802"><a href="#cb19-802" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-803"><a href="#cb19-803" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-804"><a href="#cb19-804" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-805"><a href="#cb19-805" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-806"><a href="#cb19-806" aria-hidden="true" tabindex="-1"></a><span class="fu">## Directory operations</span></span>
<span id="cb19-807"><a href="#cb19-807" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-808"><a href="#cb19-808" aria-hidden="true" tabindex="-1"></a><span class="fu">### Iterating through the files in a directory</span></span>
<span id="cb19-809"><a href="#cb19-809" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-810"><a href="#cb19-810" aria-hidden="true" tabindex="-1"></a>One of the most classic tasks related to filesystem is to be able</span>
<span id="cb19-811"><a href="#cb19-811" aria-hidden="true" tabindex="-1"></a>to iterate through the existing files in a directory. To iterate over the</span>
<span id="cb19-812"><a href="#cb19-812" aria-hidden="true" tabindex="-1"></a>files in a directory, we need to create an iterator object.</span>
<span id="cb19-813"><a href="#cb19-813" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-814"><a href="#cb19-814" aria-hidden="true" tabindex="-1"></a>You can produce such iterator object by using either the <span class="in">`iterate()`</span> or <span class="in">`walk()`</span> methods</span>
<span id="cb19-815"><a href="#cb19-815" aria-hidden="true" tabindex="-1"></a>of a <span class="in">`Dir`</span> object. Both methods return an iterator object as output, which you can advance by using the</span>
<span id="cb19-816"><a href="#cb19-816" aria-hidden="true" tabindex="-1"></a><span class="in">`next()`</span> method. The difference between these methods, is that <span class="in">`iterate()`</span> returns a non-recursive iterator,</span>
<span id="cb19-817"><a href="#cb19-817" aria-hidden="true" tabindex="-1"></a>while <span class="in">`walk()`</span> does. It means that the iterator returned by <span class="in">`walk()`</span> will not only iterate through</span>
<span id="cb19-818"><a href="#cb19-818" aria-hidden="true" tabindex="-1"></a>the files available in the current directory, but also, through the files from any subdirectory found</span>
<span id="cb19-819"><a href="#cb19-819" aria-hidden="true" tabindex="-1"></a>inside the current directory.</span>
<span id="cb19-820"><a href="#cb19-820" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-821"><a href="#cb19-821" aria-hidden="true" tabindex="-1"></a>In the example below, we are displaying the names of the files stored inside the</span>
<span id="cb19-822"><a href="#cb19-822" aria-hidden="true" tabindex="-1"></a>directory <span class="in">`ZigExamples/file-io`</span>. Notice that we had to open this directory through</span>
<span id="cb19-823"><a href="#cb19-823" aria-hidden="true" tabindex="-1"></a>the <span class="in">`openDir()`</span> function. Also notice that we provided the flag <span class="in">`iterate`</span> in the</span>
<span id="cb19-824"><a href="#cb19-824" aria-hidden="true" tabindex="-1"></a>second argument of <span class="in">`openDir()`</span>. This flag is important, because without this flag,</span>
<span id="cb19-825"><a href="#cb19-825" aria-hidden="true" tabindex="-1"></a>we would not be allowed to iterate through the files in this directory.</span>
<span id="cb19-826"><a href="#cb19-826" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-829"><a href="#cb19-829" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb19-830"><a href="#cb19-830" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb19-831"><a href="#cb19-831" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb19-832"><a href="#cb19-832" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb19-833"><a href="#cb19-833" aria-hidden="true" tabindex="-1"></a><span class="in">const cwd = std.fs.cwd();</span></span>
<span id="cb19-834"><a href="#cb19-834" aria-hidden="true" tabindex="-1"></a><span class="in">const dir = try cwd.openDir(</span></span>
<span id="cb19-835"><a href="#cb19-835" aria-hidden="true" tabindex="-1"></a><span class="in">    "ZigExamples/file-io/",</span></span>
<span id="cb19-836"><a href="#cb19-836" aria-hidden="true" tabindex="-1"></a><span class="in">    .{ .iterate = true }</span></span>
<span id="cb19-837"><a href="#cb19-837" aria-hidden="true" tabindex="-1"></a><span class="in">);</span></span>
<span id="cb19-838"><a href="#cb19-838" aria-hidden="true" tabindex="-1"></a><span class="in">var it = dir.iterate();</span></span>
<span id="cb19-839"><a href="#cb19-839" aria-hidden="true" tabindex="-1"></a><span class="in">while (try it.next()) |entry| {</span></span>
<span id="cb19-840"><a href="#cb19-840" aria-hidden="true" tabindex="-1"></a><span class="in">    try stdout.print(</span></span>
<span id="cb19-841"><a href="#cb19-841" aria-hidden="true" tabindex="-1"></a><span class="in">        "File name: {s}\n",</span></span>
<span id="cb19-842"><a href="#cb19-842" aria-hidden="true" tabindex="-1"></a><span class="in">        .{entry.name}</span></span>
<span id="cb19-843"><a href="#cb19-843" aria-hidden="true" tabindex="-1"></a><span class="in">    );</span></span>
<span id="cb19-844"><a href="#cb19-844" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb19-845"><a href="#cb19-845" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-846"><a href="#cb19-846" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-847"><a href="#cb19-847" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-848"><a href="#cb19-848" aria-hidden="true" tabindex="-1"></a><span class="in">File name: create_file_and_write_toit.zig</span></span>
<span id="cb19-849"><a href="#cb19-849" aria-hidden="true" tabindex="-1"></a><span class="in">File name: create_file.zig</span></span>
<span id="cb19-850"><a href="#cb19-850" aria-hidden="true" tabindex="-1"></a><span class="in">File name: lorem.txt</span></span>
<span id="cb19-851"><a href="#cb19-851" aria-hidden="true" tabindex="-1"></a><span class="in">File name: iterate.zig</span></span>
<span id="cb19-852"><a href="#cb19-852" aria-hidden="true" tabindex="-1"></a><span class="in">File name: delete_file.zig</span></span>
<span id="cb19-853"><a href="#cb19-853" aria-hidden="true" tabindex="-1"></a><span class="in">File name: append_to_file.zig</span></span>
<span id="cb19-854"><a href="#cb19-854" aria-hidden="true" tabindex="-1"></a><span class="in">File name: user_input.zig</span></span>
<span id="cb19-855"><a href="#cb19-855" aria-hidden="true" tabindex="-1"></a><span class="in">File name: foo.txt</span></span>
<span id="cb19-856"><a href="#cb19-856" aria-hidden="true" tabindex="-1"></a><span class="in">File name: create_file_and_read.zig</span></span>
<span id="cb19-857"><a href="#cb19-857" aria-hidden="true" tabindex="-1"></a><span class="in">File name: buff_io.zig</span></span>
<span id="cb19-858"><a href="#cb19-858" aria-hidden="true" tabindex="-1"></a><span class="in">File name: copy_file.zig</span></span>
<span id="cb19-859"><a href="#cb19-859" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-860"><a href="#cb19-860" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-861"><a href="#cb19-861" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-862"><a href="#cb19-862" aria-hidden="true" tabindex="-1"></a><span class="fu">### Creating new directories</span></span>
<span id="cb19-863"><a href="#cb19-863" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-864"><a href="#cb19-864" aria-hidden="true" tabindex="-1"></a>There are two methods that are important when it comes to</span>
<span id="cb19-865"><a href="#cb19-865" aria-hidden="true" tabindex="-1"></a>creating directories, which are <span class="in">`makeDir()`</span> and <span class="in">`makePath()`</span>.</span>
<span id="cb19-866"><a href="#cb19-866" aria-hidden="true" tabindex="-1"></a>The difference between these two methods is that <span class="in">`makeDir()`</span> can</span>
<span id="cb19-867"><a href="#cb19-867" aria-hidden="true" tabindex="-1"></a>only create one single directory in the current directory in each call,</span>
<span id="cb19-868"><a href="#cb19-868" aria-hidden="true" tabindex="-1"></a>while <span class="in">`makePath()`</span> is capable of recursively create subdirectories in the same call.</span>
<span id="cb19-869"><a href="#cb19-869" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-870"><a href="#cb19-870" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-871"><a href="#cb19-871" aria-hidden="true" tabindex="-1"></a>This is why the name of this method is "make path". It will create as many</span>
<span id="cb19-872"><a href="#cb19-872" aria-hidden="true" tabindex="-1"></a>subdirectories as necessary to create the path that you provided as input.</span>
<span id="cb19-873"><a href="#cb19-873" aria-hidden="true" tabindex="-1"></a>So, if you provide the path <span class="in">`"sub1/sub2/sub3"`</span> as input to this method,</span>
<span id="cb19-874"><a href="#cb19-874" aria-hidden="true" tabindex="-1"></a>it will create three different subdirectories, <span class="in">`sub1`</span>, <span class="in">`sub2`</span> and <span class="in">`sub3`</span>,</span>
<span id="cb19-875"><a href="#cb19-875" aria-hidden="true" tabindex="-1"></a>within the same function call. In contrast, if you provided such path</span>
<span id="cb19-876"><a href="#cb19-876" aria-hidden="true" tabindex="-1"></a>as input to <span class="in">`makeDir()`</span>, you would likely get an error as result, since</span>
<span id="cb19-877"><a href="#cb19-877" aria-hidden="true" tabindex="-1"></a>this method can only create a single subdirectory.</span>
<span id="cb19-878"><a href="#cb19-878" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-881"><a href="#cb19-881" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb19-882"><a href="#cb19-882" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb19-883"><a href="#cb19-883" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb19-884"><a href="#cb19-884" aria-hidden="true" tabindex="-1"></a><span class="in">const cwd = std.fs.cwd();</span></span>
<span id="cb19-885"><a href="#cb19-885" aria-hidden="true" tabindex="-1"></a><span class="in">try cwd.makeDir("src");</span></span>
<span id="cb19-886"><a href="#cb19-886" aria-hidden="true" tabindex="-1"></a><span class="in">try cwd.makePath("src/decoders/jpg/");</span></span>
<span id="cb19-887"><a href="#cb19-887" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-888"><a href="#cb19-888" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-889"><a href="#cb19-889" aria-hidden="true" tabindex="-1"></a><span class="fu">### Deleting directories</span></span>
<span id="cb19-890"><a href="#cb19-890" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-891"><a href="#cb19-891" aria-hidden="true" tabindex="-1"></a>To delete a directory, just provide the path to the directory that you want to delete</span>
<span id="cb19-892"><a href="#cb19-892" aria-hidden="true" tabindex="-1"></a>as input to the <span class="in">`deleteDir()`</span> method from a <span class="in">`Dir`</span> object. In the example below,</span>
<span id="cb19-893"><a href="#cb19-893" aria-hidden="true" tabindex="-1"></a>we are deleting the <span class="in">`src`</span> directory that we have just created in the previous example.</span>
<span id="cb19-894"><a href="#cb19-894" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-897"><a href="#cb19-897" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb19-898"><a href="#cb19-898" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb19-899"><a href="#cb19-899" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb19-900"><a href="#cb19-900" aria-hidden="true" tabindex="-1"></a><span class="in">const cwd = std.fs.cwd();</span></span>
<span id="cb19-901"><a href="#cb19-901" aria-hidden="true" tabindex="-1"></a><span class="in">try cwd.deleteDir("src");</span></span>
<span id="cb19-902"><a href="#cb19-902" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-903"><a href="#cb19-903" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-904"><a href="#cb19-904" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-905"><a href="#cb19-905" aria-hidden="true" tabindex="-1"></a><span class="fu">## Conclusion</span></span>
<span id="cb19-906"><a href="#cb19-906" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-907"><a href="#cb19-907" aria-hidden="true" tabindex="-1"></a>In this chapter, I have described how to perform in Zig the most common filesystem and IO operations.</span>
<span id="cb19-908"><a href="#cb19-908" aria-hidden="true" tabindex="-1"></a>But you might feel the lack of some other, less common, operation in this chapter, such as: how to rename files,</span>
<span id="cb19-909"><a href="#cb19-909" aria-hidden="true" tabindex="-1"></a>or how to open a directory, or how to create symbolic links, or how to use <span class="in">`access()`</span> to test if a particular</span>
<span id="cb19-910"><a href="#cb19-910" aria-hidden="true" tabindex="-1"></a>path exists in your computer. But for all of these less common tasks, I recommend you to read</span>
<span id="cb19-911"><a href="#cb19-911" aria-hidden="true" tabindex="-1"></a>the documentation of the <span class="co">[</span><span class="ot">`Dir` type</span><span class="co">](https://ziglang.org/documentation/master/std/#std.fs.Dir)</span><span class="ot">[^zig-dir]</span></span>
<span id="cb19-912"><a href="#cb19-912" aria-hidden="true" tabindex="-1"></a>, since you can find a good description of these cases there.</span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>