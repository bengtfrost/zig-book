<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Introduction to Zig - 2&nbsp; Control flow, structs, modules and types</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../Chapters/01-memory.html" rel="next">
<link href="../Chapters/01-zig-weird.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-6CHJXK4CEV"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-6CHJXK4CEV', { 'anonymize_ip': true});
</script>


</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../Chapters/03-structs.html"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Control flow, structs, modules and types</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Introduction to Zig</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Welcome</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/01-zig-weird.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introducing Zig</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/03-structs.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Control flow, structs, modules and types</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/01-memory.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Memory and Allocators</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/01-base64.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Project 1 - Building a base64 encoder/decoder</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/02-debugging.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Debugging Zig applications</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/05-pointers.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Pointers and Optionals</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/04-http-server.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Project 2 - Building a HTTP Server from scratch</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/03-unittests.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Unit tests</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/07-build-system.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Build System</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/09-error-handling.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Error handling and unions</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/09-data-structures.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Data Structures</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/10-stack-project.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Project 3 - Building a stack data structure</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/12-file-op.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Filesystem and Input/Output (IO)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/14-zig-c-interop.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Zig interoperability with C</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/13-image-filter.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Project 4 - Developing an image filter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/14-threads.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Introducing threads and parallelism in Zig</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/15-vectors.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Introducing Vectors and SIMD</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#sec-zig-control-flow" id="toc-sec-zig-control-flow" class="nav-link active" data-scroll-target="#sec-zig-control-flow"><span class="header-section-number">2.1</span> Control flow</a>
  <ul class="collapse">
  <li><a href="#ifelse-statements" id="toc-ifelse-statements" class="nav-link" data-scroll-target="#ifelse-statements"><span class="header-section-number">2.1.1</span> If/else statements</a></li>
  <li><a href="#sec-switch" id="toc-sec-switch" class="nav-link" data-scroll-target="#sec-switch"><span class="header-section-number">2.1.2</span> Switch statements</a></li>
  <li><a href="#sec-defer" id="toc-sec-defer" class="nav-link" data-scroll-target="#sec-defer"><span class="header-section-number">2.1.3</span> The <code>defer</code> keyword</a></li>
  <li><a href="#sec-errdefer1" id="toc-sec-errdefer1" class="nav-link" data-scroll-target="#sec-errdefer1"><span class="header-section-number">2.1.4</span> The <code>errdefer</code> keyword</a></li>
  <li><a href="#for-loops" id="toc-for-loops" class="nav-link" data-scroll-target="#for-loops"><span class="header-section-number">2.1.5</span> For loops</a></li>
  <li><a href="#while-loops" id="toc-while-loops" class="nav-link" data-scroll-target="#while-loops"><span class="header-section-number">2.1.6</span> While loops</a></li>
  <li><a href="#using-break-and-continue" id="toc-using-break-and-continue" class="nav-link" data-scroll-target="#using-break-and-continue"><span class="header-section-number">2.1.7</span> Using <code>break</code> and <code>continue</code></a></li>
  </ul></li>
  <li><a href="#sec-fun-pars" id="toc-sec-fun-pars" class="nav-link" data-scroll-target="#sec-fun-pars"><span class="header-section-number">2.2</span> Function parameters are immutable</a>
  <ul class="collapse">
  <li><a href="#a-free-optimization" id="toc-a-free-optimization" class="nav-link" data-scroll-target="#a-free-optimization"><span class="header-section-number">2.2.1</span> A free optimization</a></li>
  <li><a href="#how-to-overcome-this-barrier" id="toc-how-to-overcome-this-barrier" class="nav-link" data-scroll-target="#how-to-overcome-this-barrier"><span class="header-section-number">2.2.2</span> How to overcome this barrier</a></li>
  </ul></li>
  <li><a href="#sec-structs-and-oop" id="toc-sec-structs-and-oop" class="nav-link" data-scroll-target="#sec-structs-and-oop"><span class="header-section-number">2.3</span> Structs and OOP</a>
  <ul class="collapse">
  <li><a href="#the-pub-keyword" id="toc-the-pub-keyword" class="nav-link" data-scroll-target="#the-pub-keyword"><span class="header-section-number">2.3.1</span> The <code>pub</code> keyword</a></li>
  <li><a href="#sec-anonymous-struct-literals" id="toc-sec-anonymous-struct-literals" class="nav-link" data-scroll-target="#sec-anonymous-struct-literals"><span class="header-section-number">2.3.2</span> Anonymous struct literals</a></li>
  <li><a href="#struct-declarations-must-be-constant" id="toc-struct-declarations-must-be-constant" class="nav-link" data-scroll-target="#struct-declarations-must-be-constant"><span class="header-section-number">2.3.3</span> Struct declarations must be constant</a></li>
  <li><a href="#sec-self-arg" id="toc-sec-self-arg" class="nav-link" data-scroll-target="#sec-self-arg"><span class="header-section-number">2.3.4</span> The <code>self</code> method argument</a></li>
  <li><a href="#about-the-struct-state" id="toc-about-the-struct-state" class="nav-link" data-scroll-target="#about-the-struct-state"><span class="header-section-number">2.3.5</span> About the struct state</a></li>
  </ul></li>
  <li><a href="#sec-type-inference" id="toc-sec-type-inference" class="nav-link" data-scroll-target="#sec-type-inference"><span class="header-section-number">2.4</span> Type inference</a></li>
  <li><a href="#sec-type-cast" id="toc-sec-type-cast" class="nav-link" data-scroll-target="#sec-type-cast"><span class="header-section-number">2.5</span> Type casting</a></li>
  <li><a href="#modules" id="toc-modules" class="nav-link" data-scroll-target="#modules"><span class="header-section-number">2.6</span> Modules</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Control flow, structs, modules and types</span></h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">View Source</a></li></ul></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>We have discussed a lot of Zig’s syntax in the last chapter, especially in <a href="01-zig-weird.html#sec-root-file" class="quarto-xref"><span>Section 1.2.2</span></a> and <a href="01-zig-weird.html#sec-main-file" class="quarto-xref"><span>Section 1.2.3</span></a>. But we still need to discuss some other very important elements of the language. Elements that you will use constantly on your day-to-day routine.</p>
<p>We begin this chapter by discussing the different keywords and structures in Zig related to control flow (e.g.&nbsp;loops and if statements). Then, we talk about structs and how they can be used to do some basic Object-Oriented (OOP) patterns in Zig. We also talk about type inference and type casting. Finally, we end this chapter by discussing modules, and how they relate to structs.</p>
<section id="sec-zig-control-flow" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="sec-zig-control-flow"><span class="header-section-number">2.1</span> Control flow</h2>
<p>Sometimes, you need to make decisions in your program. Maybe you need to decide whether or not to execute a specific piece of code. Or maybe, you need to apply the same operation over a sequence of values. These kinds of tasks, involve using structures that are capable of changing the “control flow” of our program.</p>
<p>In computer science, the term “control flow” usually refers to the order in which expressions (or commands) are evaluated in a given language or program. But this term is also used to refer to structures that are capable of changing this “evaluation order” of the commands executed by a given language/program.</p>
<p>These structures are better known by a set of terms, such as: loops, if/else statements, switch statements, among others. So, loops and if/else statements are examples of structures that can change the “control flow” of our program. The keywords <code>continue</code> and <code>break</code> are also examples of symbols that can change the order of evaluation, since they can move our program to the next iteration of a loop, or make the loop stop completely.</p>
<section id="ifelse-statements" class="level3" data-number="2.1.1">
<h3 data-number="2.1.1" class="anchored" data-anchor-id="ifelse-statements"><span class="header-section-number">2.1.1</span> If/else statements</h3>
<p>An if/else statement performs a “conditional flow operation”. A conditional flow control (or choice control) allows you to execute or ignore a certain block of commands based on a logical condition. Many programmers and computer science professionals also use the term “branching” in this case. In essence, an if/else statement allow us to use the result of a logical test to decide whether or not to execute a given block of commands.</p>
<p>In Zig, we write if/else statements by using the keywords <code>if</code> and <code>else</code>. We start with the <code>if</code> keyword followed by a logical test inside a pair of parentheses, followed by a pair of curly braces which contains the lines of code to be executed in case the logical test returns the value <code>true</code>.</p>
<p>After that, you can optionally add an <code>else</code> statement. To do that, just add the <code>else</code> keyword followed by a pair of curly braces, with the lines of code to executed in case the logical test defined at <code>if</code> returns <code>false</code>.</p>
<p>In the example below, we are testing if the object <code>x</code> contains a number that is greater than 10. Judging by the output printed to the console, we know that this logical test returned <code>false</code>. Because the output in the console is compatible with the line of code present in the <code>else</code> branch of the if/else statement.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> x = <span class="dv">5</span>;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> (x &gt; <span class="dv">10</span>) <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> stdout.print(</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">"x &gt; 10!</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{}</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    );</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> stdout.print(</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span class="st">"x &lt;= 10!</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{}</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    );</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>x &lt;= 10!</code></pre>
</div>
</div>
</section>
<section id="sec-switch" class="level3" data-number="2.1.2">
<h3 data-number="2.1.2" class="anchored" data-anchor-id="sec-switch"><span class="header-section-number">2.1.2</span> Switch statements</h3>
<p>Switch statements are also available in Zig, and they have a very similar syntax to a switch statement in Rust. As you would expect, to write a switch statement in Zig we use the <code>switch</code> keyword. We provide the value that we want to “switch over” inside a pair of parentheses. Then, we list the possible combinations (or “branches”) inside a pair of curly braces.</p>
<p>Let’s take a look at the code example below. You can see that I’m creating an enum type called <code>Role</code>. We talk more about enums in <a href="04-http-server.html#sec-enum" class="quarto-xref"><span>Section 7.6</span></a>. But in summary, this <code>Role</code> type is listing different types of roles in a fictitious company, like <code>SE</code> for Software Engineer, <code>DE</code> for Data Engineer, <code>PM</code> for Product Manager, etc.</p>
<p>Notice that we are using the value from the <code>role</code> object in the switch statement, to discover which exact area we need to store in the <code>area</code> variable object. Also notice that we are using type inference inside the switch statement, with the dot character, as we are going to describe in <a href="#sec-type-inference" class="quarto-xref"><span>Section 2.4</span></a>. This makes the <code>zig</code> compiler infer the correct data type of the values (<code>PM</code>, <code>SE</code>, etc.) for us.</p>
<p>Also notice that, we are grouping multiple values in the same branch of the switch statement. We just separate each possible value with a comma. For example, if <code>role</code> contains either <code>DE</code> or <code>DA</code>, the <code>area</code> variable would contain the value <code>"Data &amp; Analytics"</code>, instead of <code>"Platform"</code> or <code>"Sales"</code>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> stdout = std.io.getStdOut().writer();</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> Role = <span class="kw">enum</span> <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    SE, DPE, DE, DA, PM, PO, KS</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> area: []<span class="kw">const</span> <span class="dt">u8</span> = <span class="cn">undefined</span>;</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> role = Role.SE;</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">switch</span> (role) <span class="op">{</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        .PM, .SE, .DPE, .PO =&gt; <span class="op">{</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>            area = <span class="st">"Platform"</span>;</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>,</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        .DE, .DA =&gt; <span class="op">{</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>            area = <span class="st">"Data &amp; Analytics"</span>;</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>,</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>        .KS =&gt; <span class="op">{</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>            area = <span class="st">"Sales"</span>;</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>,</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> stdout.print(<span class="st">"{s}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span>area<span class="op">}</span>);</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Platform</code></pre>
</div>
</div>
<section id="switch-statements-must-exhaust-all-possibilities" class="level4" data-number="2.1.2.1">
<h4 data-number="2.1.2.1" class="anchored" data-anchor-id="switch-statements-must-exhaust-all-possibilities"><span class="header-section-number">2.1.2.1</span> Switch statements must exhaust all possibilities</h4>
<p>One very important aspect about switch statements in Zig is that they must exhaust all existing possibilities. In other words, all possible values that could be found inside the <code>role</code> object must be explicitly handled in this switch statement.</p>
<p>Since the <code>role</code> object has type <code>Role</code>, the only possible values to be found inside this object are <code>PM</code>, <code>SE</code>, <code>DPE</code>, <code>PO</code>, <code>DE</code>, <code>DA</code> and <code>KS</code>. There are no other possible values to be stored in this <code>role</code> object. Thus, the switch statements must have a combination (branch) for each one of these values. This is what “exhaust all existing possibilities” means. The switch statement covers every possible case.</p>
<p>Therefore, you cannot write a switch statement in Zig, and leave an edge case with no explicit action to be taken. This is a similar behaviour to switch statements in Rust, which also have to handle all possible cases.</p>
</section>
<section id="the-else-branch" class="level4" data-number="2.1.2.2">
<h4 data-number="2.1.2.2" class="anchored" data-anchor-id="the-else-branch"><span class="header-section-number">2.1.2.2</span> The else branch</h4>
<p>Take a look at the <code>dump_hex_fallible()</code> function below as an example. This function comes from the Zig Standard Library. More precisely, from the <a href="https://github.com/ziglang/zig/blob/master/lib/std/debug.zig"><code>debug.zig</code> module</a><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. There are multiple lines in this function, but I omitted them to focus solely on the switch statement found in this function. Notice that this switch statement has four possible cases (i.e., four explicit branches). Also, notice that we used an <code>else</code> branch in this case.</p>
<p>An <code>else</code> branch in a switch statement works as the “default branch”. Whenever you have multiple cases in your switch statement where you want to apply the exact same action, you can use an <code>else</code> branch to do that.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> dump_hex_fallible(bytes: []<span class="kw">const</span> <span class="dt">u8</span>) !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Many lines ...</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">switch</span> (byte) <span class="op">{</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="ch">'\n'</span> =&gt; <span class="kw">try</span> writer.writeAll(<span class="st">"␊"</span>),</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        <span class="ch">'\r'</span> =&gt; <span class="kw">try</span> writer.writeAll(<span class="st">"␍"</span>),</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="ch">'\t'</span> =&gt; <span class="kw">try</span> writer.writeAll(<span class="st">"␉"</span>),</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> =&gt; <span class="kw">try</span> writer.writeByte(<span class="ch">'.'</span>),</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Many programmers would also use an <code>else</code> branch to handle a “not supported” case. That is, a case that cannot be properly handled by your code, or, just a case that should not be “fixed”. Therefore, you can use an <code>else</code> branch to panic (or raise an error) in your program to stop the current execution.</p>
<p>Take the code example below. We can see that, we are handling the cases for the <code>level</code> object being either 1, 2, or 3. All other possible cases are not supported by default, and, as consequence, we raise a runtime error in such cases through the <code>@panic()</code> built-in function.</p>
<p>Also notice that, we are assigning the result of the switch statement to a new object called <code>category</code>. This is another thing that you can do with switch statements in Zig. If a branch outputs a value as result, you can store the result value of the switch statement into a new object.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> level: <span class="dt">u8</span> = <span class="dv">4</span>;</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> category = <span class="kw">switch</span> (level) <span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>, <span class="dv">2</span> =&gt; <span class="st">"beginner"</span>,</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="dv">3</span> =&gt; <span class="st">"professional"</span>,</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> =&gt; <span class="op">{</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">@panic</span>(<span class="st">"Not supported level!"</span>);</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>,</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="kw">try</span> stdout.print(<span class="st">"{s}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span>category<span class="op">}</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>thread 13103 panic: Not supported level!
t.zig:9:13: 0x1033c58 in main (switch2)
            @panic("Not supported level!");
            ^</code></pre>
</section>
<section id="using-ranges-in-switch" class="level4" data-number="2.1.2.3">
<h4 data-number="2.1.2.3" class="anchored" data-anchor-id="using-ranges-in-switch"><span class="header-section-number">2.1.2.3</span> Using ranges in switch</h4>
<p>Furthermore, you can also use ranges of values in switch statements. That is, you can create a branch in your switch statement that is used whenever the input value is within the specified range. These “range expressions” are created with the operator <code>...</code>. It’s important to emphasize that the ranges created by this operator are inclusive on both ends.</p>
<p>For example, I could easily change the previous code example to support all levels between 0 and 100. Like this:</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> level: <span class="dt">u8</span> = <span class="dv">4</span>;</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> category = <span class="kw">switch</span> (level) <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>...<span class="dv">25</span> =&gt; <span class="st">"beginner"</span>,</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="dv">26</span>...<span class="dv">75</span> =&gt; <span class="st">"intermediary"</span>,</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="dv">76</span>...<span class="dv">100</span> =&gt; <span class="st">"professional"</span>,</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> =&gt; <span class="op">{</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">@panic</span>(<span class="st">"Not supported level!"</span>);</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>,</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="kw">try</span> stdout.print(<span class="st">"{s}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span>category<span class="op">}</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>beginner</code></pre>
</div>
</div>
<p>This is neat, and it works with character ranges too. That is, I could simply write <code>'a'...'z'</code>, to match any character value that is a lowercase letter, and it would work fine.</p>
</section>
<section id="labeled-switch-statements" class="level4" data-number="2.1.2.4">
<h4 data-number="2.1.2.4" class="anchored" data-anchor-id="labeled-switch-statements"><span class="header-section-number">2.1.2.4</span> Labeled switch statements</h4>
<p>In <a href="01-zig-weird.html#sec-blocks" class="quarto-xref"><span>Section 1.7</span></a> we have talked about labeling blocks, and also, about using these labels to return a value from the block. Well, from version 0.14.0 and onwards of the <code>zig</code> compiler, you can also apply labels over switch statements, which makes it possible to almost implement a “C <code>goto</code>” like pattern.</p>
<p>For example, if you give the label <code>xsw</code> to a switch statement, you can use this label in conjunction with the <code>continue</code> keyword to go back to the beginning of the switch statement. In the example below, the execution goes back to the beginning of the switch statement two times, before ending at the <code>3</code> branch.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>xsw: <span class="kw">switch</span> (<span class="bu">@as</span>(<span class="dt">u8</span>, <span class="dv">1</span>)) <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span> =&gt; <span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">try</span> stdout.print(<span class="st">"First branch</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{}</span>);</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">continue</span> :xsw <span class="dv">2</span>;</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>,</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span> =&gt; <span class="kw">continue</span> :xsw <span class="dv">3</span>,</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="dv">3</span> =&gt; <span class="kw">return</span>,</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="dv">4</span> =&gt; <span class="op">{}</span>,</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> =&gt; <span class="op">{</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">try</span> stdout.print(</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>            <span class="st">"Unmatched case, value: {d}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span><span class="bu">@as</span>(<span class="dt">u8</span>, <span class="dv">1</span>)<span class="op">}</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        );</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>,</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="sec-defer" class="level3" data-number="2.1.3">
<h3 data-number="2.1.3" class="anchored" data-anchor-id="sec-defer"><span class="header-section-number">2.1.3</span> The <code>defer</code> keyword</h3>
<p>With the <code>defer</code> keyword you can register an expression to be executed when you exit the current scope. Therefore, this keyword has a similar functionality as the <code>on.exit()</code> function from R. Take the <code>foo()</code> function below as an example. When we execute this <code>foo()</code> function, the expression that prints the message “Exiting function …” is getting executed only when the function exits its scope.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> stdout = std.io.getStdOut().writer();</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> foo() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">defer</span> std.debug.print(</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Exiting function ...</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{}</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    );</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> stdout.print(<span class="st">"Adding some numbers ...</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{}</span>);</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> x = <span class="dv">2</span> + <span class="dv">2</span>; _ = x;</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> stdout.print(<span class="st">"Multiplying ...</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{}</span>);</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> y = <span class="dv">2</span> * <span class="dv">8</span>; _ = y;</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> foo();</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>Adding some numbers ...
Multiplying ...
Exiting function ...</code></pre>
<p>Therefore, we can use <code>defer</code> to declare an expression that is going to be executed when your code exits the current scope. Some programmers like to interpret the phrase “exit of the current scope” as “the end of the current scope”. But this interpretation might not be entirely correct, depending on what you consider as “the end of the current scope”.</p>
<p>I mean, what do you consider as <strong>the end</strong> of the current scope? Is it the closing curly bracket (<code>}</code>) of the scope? Is it when the last expression in the function gets executed? Is it when the function returns to the previous scope? Etc. For example, it would not be correct to interpret the “exit of the current scope” as the closing curly bracket of the scope. Because the function might exit from an earlier position than this closing curly bracket (e.g.&nbsp;an error value was generated at a previous line inside the function; the function reached an earlier return statement; etc.). Anyway, just be careful with this interpretation.</p>
<p>Now, if you remember of what we have discussed in <a href="01-zig-weird.html#sec-blocks" class="quarto-xref"><span>Section 1.7</span></a>, there are multiple structures in the language that create their own separate scopes. For/while loops, if/else statements, functions, normal blocks, etc. This also affects the interpretation of <code>defer</code>. For example, if you use <code>defer</code> inside a for loop, then, the given expression will be executed everytime this specific for loop exits its own scope.</p>
<p>Before we continue, it’s worth emphasizing that the <code>defer</code> keyword is an “unconditional defer”. Which means that the given expression will be executed no matter how the code exits the current scope. For example, your code might exit the current scope because of an error value being generated, or, because of a return statement, or, a break statement, etc.</p>
</section>
<section id="sec-errdefer1" class="level3" data-number="2.1.4">
<h3 data-number="2.1.4" class="anchored" data-anchor-id="sec-errdefer1"><span class="header-section-number">2.1.4</span> The <code>errdefer</code> keyword</h3>
<p>On the previous section, we have discussed the <code>defer</code> keyword, which you can use to register an expression to be executed at the exit of the current scope. But this keyword has a brother, which is the <code>errdefer</code> keyword. While <code>defer</code> is an “unconditional defer”, the <code>errdefer</code> keyword is a “conditional defer”. Which means that the given expression is executed only when you exit the current scope on a very specific circumstance.</p>
<p>In more details, the expression given to <code>errdefer</code> is executed only when an error occurs in the current scope. Therefore, if the function (or for/while loop, if/else statement, etc.) exits the current scope in a normal situation, without errors, the expression given to <code>errdefer</code> is not executed.</p>
<p>This makes the <code>errdefer</code> keyword one of the many tools available in Zig for error handling. In this section, we are more concerned with the control flow aspects around <code>errdefer</code>. But we are going to discuss <code>errdefer</code> later as a error handling tool in <a href="09-error-handling.html#sec-errdefer2" class="quarto-xref"><span>Section 10.2.4</span></a>.</p>
<p>The code example below demonstrates three things:</p>
<ul>
<li>that <code>defer</code> is an “unconditional defer”, because the given expression gets executed regardless of how the function <code>foo()</code> exits its own scope.</li>
<li>that <code>errdefer</code> is executed because the function <code>foo()</code> returned an error value.</li>
<li>that <code>defer</code> and <code>errdefer</code> expressions are executed in a LIFO (<em>last in, first out</em>) order.</li>
</ul>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> foo() !<span class="dt">void</span> <span class="op">{</span> <span class="kw">return</span> <span class="kw">error</span>.FooError; <span class="op">}</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> i: <span class="dt">usize</span> = <span class="dv">1</span>;</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">errdefer</span> std.debug.print(<span class="st">"Value of i: {d}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span>i<span class="op">}</span>);</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">defer</span> i = <span class="dv">2</span>;</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> foo();</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>Value of i: 2
error: FooError
/t.zig:6:5: 0x1037e48 in foo (defer)
    return error.FooError;
    ^</code></pre>
<p>When I say that “defer expressions” are executed in a LIFO order, what I want to say is that the last <code>defer</code> or <code>errdefer</code> expressions in the code are the first ones to be executed. You could also interpret this as: “defer expressions” are executed from bottom to top, or, from last to first.</p>
<p>Therefore, if I change the order of the <code>defer</code> and <code>errdefer</code> expressions, you will notice that the value of <code>i</code> that gets printed to the console changes to 1. This doesn’t mean that the <code>defer</code> expression was not executed in this case. This actually means that the <code>defer</code> expression was executed only after the <code>errdefer</code> expression. The code example below demonstrates this:</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> foo() !<span class="dt">void</span> <span class="op">{</span> <span class="kw">return</span> <span class="kw">error</span>.FooError; <span class="op">}</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> i: <span class="dt">usize</span> = <span class="dv">1</span>;</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">defer</span> i = <span class="dv">2</span>;</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">errdefer</span> std.debug.print(<span class="st">"Value of i: {d}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span>i<span class="op">}</span>);</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> foo();</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>Value of i: 1
error: FooError
/t.zig:6:5: 0x1037e48 in foo (defer)
    return error.FooError;
    ^</code></pre>
</section>
<section id="for-loops" class="level3" data-number="2.1.5">
<h3 data-number="2.1.5" class="anchored" data-anchor-id="for-loops"><span class="header-section-number">2.1.5</span> For loops</h3>
<p>A loop allows you to execute the same lines of code multiple times, thus, creating a “repetition space” in the execution flow of your program. Loops are particularly useful when we want to replicate the same function (or the same set of commands) over different inputs.</p>
<p>There are different types of loops available in Zig. But the most essential of them all is probably the <em>for loop</em>. A for loop is used to apply the same piece of code over the elements of a slice, or, an array.</p>
<p>For loops in Zig use a syntax that may be unfamiliar to programmers coming from other languages. You start with the <code>for</code> keyword, then, you list the items that you want to iterate over inside a pair of parentheses. Then, inside of a pair of pipes (<code>|</code>) you should declare an identifier that will serve as your iterator, or, the “repetition index of the loop”.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">for</span> (items) |value| <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// code to execute</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Therefore, instead of using a <code>(value in items)</code> syntax, in Zig, for loops use the syntax <code>(items) |value|</code>. In the example below, you can see that we are looping through the items of the array stored at the object <code>name</code>, and printing to the console the decimal representation of each character in this array.</p>
<p>If we wanted, we could also iterate through a slice (or a portion) of the array, instead of iterating through the entire array stored in the <code>name</code> object. Just use a range selector to select the section you want. For example, I could provide the expression <code>name[0..3]</code> to the for loop, to iterate just through the first 3 elements in the array.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> name = [_]<span class="dt">u8</span><span class="op">{</span><span class="ch">'P'</span>,<span class="ch">'e'</span>,<span class="ch">'d'</span>,<span class="ch">'r'</span>,<span class="ch">'o'</span><span class="op">}</span>;</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">for</span> (name) |char| <span class="op">{</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> stdout.print(<span class="st">"{d} | "</span>, .<span class="op">{</span>char<span class="op">}</span>);</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>80 | 101 | 100 | 114 | 111 | </code></pre>
</div>
</div>
<p>In the above example we are using the value itself of each element in the array as our iterator. But there are many situations where we need to use an index instead of the actual values of the items.</p>
<p>You can do that by providing a second set of items to iterate over. More precisely, you provide the range selector <code>0..</code> to the for loop. So, yes, you can use two different iterators at the same time in a for loop in Zig.</p>
<p>But remember from <a href="01-zig-weird.html#sec-assignments" class="quarto-xref"><span>Section 1.4</span></a> that, every object you create in Zig must be used in some way. So if you declare two iterators in your for loop, you must use both iterators inside the for loop body. But if you want to use just the index iterator, and not use the “value iterator”, then, you can discard the value iterator by maching the value items to the underscore character, like in the example below:</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> name = <span class="st">"Pedro"</span>;</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="kw">for</span> (name, <span class="dv">0</span>..) |_, i| <span class="op">{</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> stdout.print(<span class="st">"{d} | "</span>, .<span class="op">{</span>i<span class="op">}</span>);</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>0 | 1 | 2 | 3 | 4 |</code></pre>
</section>
<section id="while-loops" class="level3" data-number="2.1.6">
<h3 data-number="2.1.6" class="anchored" data-anchor-id="while-loops"><span class="header-section-number">2.1.6</span> While loops</h3>
<p>A while loop is created from the <code>while</code> keyword. A <code>for</code> loop iterates through the items of an array, but a <code>while</code> loop will loop continuously, and infinitely, until a logical test (specified by you) becomes false.</p>
<p>You start with the <code>while</code> keyword, then, you define a logical expression inside a pair of parentheses, and the body of the loop is provided inside a pair of curly braces, like in the example below:</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> i: <span class="dt">u8</span> = <span class="dv">1</span>;</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="kw">while</span> (i &lt; <span class="dv">5</span>) <span class="op">{</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> stdout.print(<span class="st">"{d} | "</span>, .<span class="op">{</span>i<span class="op">}</span>);</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    i += <span class="dv">1</span>;</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>1 | 2 | 3 | 4 | </code></pre>
</div>
</div>
<p>You can also specify the increment expression to be used at the beginning of a while loop. To do that, we write the increment expression inside a pair of parentheses after a colon character (<code>:</code>). The code example below demonstrates this other pattern.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> i: <span class="dt">u8</span> = <span class="dv">1</span>;</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="kw">while</span> (i &lt; <span class="dv">5</span>) : (i += <span class="dv">1</span>) <span class="op">{</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> stdout.print(<span class="st">"{d} | "</span>, .<span class="op">{</span>i<span class="op">}</span>);</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>1 | 2 | 3 | 4 | </code></pre>
</div>
</div>
</section>
<section id="using-break-and-continue" class="level3" data-number="2.1.7">
<h3 data-number="2.1.7" class="anchored" data-anchor-id="using-break-and-continue"><span class="header-section-number">2.1.7</span> Using <code>break</code> and <code>continue</code></h3>
<p>In Zig, you can explicitly stop the execution of a loop, or, jump to the next iteration of the loop, by using the keywords <code>break</code> and <code>continue</code>, respectively. The <code>while</code> loop presented in the next code example is, at first sight, an infinite loop. Because the logical value inside the parenthese will always be equal to <code>true</code>. But what makes this <code>while</code> loop stop when the <code>i</code> object reaches the count 10? It’s the <code>break</code> keyword!</p>
<p>Inside the while loop, we have an if statement that is constantly checking if the <code>i</code> variable is equal to 10. Since we are incrementing the value of <code>i</code> at each iteration of the while loop, this <code>i</code> object will eventually be equal to 10, and when it is, the if statement will execute the <code>break</code> expression, and, as a result, the execution of the while loop is stopped.</p>
<p>Notice the use of the <code>expect()</code> function from the Zig Standard Library after the while loop. This <code>expect()</code> function is an “assert” type of function. This function checks if the logical test provided is equal to true. If so, the function do nothing. Otherwise (i.e., the logical test is equal to false), the function raises an assertion error.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> i: <span class="dt">usize</span> = <span class="dv">0</span>;</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="kw">while</span> (<span class="cn">true</span>) <span class="op">{</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> (i == <span class="dv">10</span>) <span class="op">{</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">break</span>;</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    i += <span class="dv">1</span>;</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a><span class="kw">try</span> std.testing.expect(i == <span class="dv">10</span>);</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a><span class="kw">try</span> stdout.print(<span class="st">"Everything worked!"</span>, .<span class="op">{}</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Everything worked!</code></pre>
</div>
</div>
<p>Since this code example was executed successfully by the <code>zig</code> compiler, without raising any errors, we known that, after the execution of the while loop, the <code>i</code> object is equal to 10. Because if it wasn’t equal to 10, an error would have been raised by <code>expect()</code>.</p>
<p>Now, in the next example, we have a use case for the <code>continue</code> keyword. The if statement is constantly checking if the current index is a multiple of 2. If it is, we jump to the next iteration of the loop. Otherwise, the loop just prints the current index to the console.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> ns = [_]<span class="dt">u8</span><span class="op">{</span><span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span><span class="op">}</span>;</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="kw">for</span> (ns) |i| <span class="op">{</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> ((i % <span class="dv">2</span>) == <span class="dv">0</span>) <span class="op">{</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">continue</span>;</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> stdout.print(<span class="st">"{d} | "</span>, .<span class="op">{</span>i<span class="op">}</span>);</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>1 | 3 | 5 | </code></pre>
</div>
</div>
</section>
</section>
<section id="sec-fun-pars" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="sec-fun-pars"><span class="header-section-number">2.2</span> Function parameters are immutable</h2>
<p>We have already discussed a lot of the syntax behind function declarations in <a href="01-zig-weird.html#sec-root-file" class="quarto-xref"><span>Section 1.2.2</span></a> and <a href="01-zig-weird.html#sec-main-file" class="quarto-xref"><span>Section 1.2.3</span></a>. But I want to emphasize a curious fact about function parameters (a.k.a. function arguments) in Zig. In summary, function parameters are immutable in Zig.</p>
<p>Take the code example below, where we declare a simple function that just tries to add some amount to the input integer, and returns the result back. If you look closely at the body of this <code>add2()</code> function, you will notice that we try to save the result back into the <code>x</code> function argument.</p>
<p>In other words, this function not only uses the value that it received through the function argument <code>x</code>, but it also tries to change the value of this function argument, by assigning the addition result into <code>x</code>. However, function arguments in Zig are immutable. You cannot change their values, or, you cannot assign values to them inside the body’s function.</p>
<p>This is the reason why, the code example below does not compile successfully. If you try to compile this code example, you will get a compile error message about “trying to change the value of a immutable (i.e., constant) object”.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> add2(x: <span class="dt">u32</span>) <span class="dt">u32</span> <span class="op">{</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    x = x + <span class="dv">2</span>;</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> x;</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> y = add2(<span class="dv">4</span>);</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>    std.debug.print(<span class="st">"{d}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span>y<span class="op">}</span>);</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>t.zig:3:5: error: cannot assign to constant
    x = x + 2;
    ^</code></pre>
<section id="a-free-optimization" class="level3" data-number="2.2.1">
<h3 data-number="2.2.1" class="anchored" data-anchor-id="a-free-optimization"><span class="header-section-number">2.2.1</span> A free optimization</h3>
<p>If a function argument receives as input an object whose data type is any of the primitive types that we have listed in <a href="01-zig-weird.html#sec-primitive-data-types" class="quarto-xref"><span>Section 1.5</span></a>, this object is always passed by value to the function. In other words, this object is copied into the function stack frame.</p>
<p>However, if the input object have a more complex data type, for example, it might be a struct instance, or an array, or an union value, etc., in cases like that, the <code>zig</code> compiler will take the liberty of deciding for you which strategy is best. Thus, the <code>zig</code> compiler will pass your object to the function either by value, or by reference. The compiler will always choose the strategy that is faster for you. This optimization that you get for free is possible only because function arguments are immutable in Zig.</p>
</section>
<section id="how-to-overcome-this-barrier" class="level3" data-number="2.2.2">
<h3 data-number="2.2.2" class="anchored" data-anchor-id="how-to-overcome-this-barrier"><span class="header-section-number">2.2.2</span> How to overcome this barrier</h3>
<p>There are some situations where you might need to change the value of your function argument directly inside the function’s body. This happens more often when we are passing C structs as inputs to Zig functions.</p>
<p>In a situation like this, you can overcome this barrier by using a pointer. In other words, instead of passing a value as input to the argument, you can pass a “pointer to value” instead. You can change the value that the pointer points to, by dereferencing it.</p>
<p>Therefore, if we take our previous <code>add2()</code> example, we can change the value of the function argument <code>x</code> inside the function’s body by marking the <code>x</code> argument as a “pointer to a <code>u32</code> value” (i.e., <code>*u32</code> data type), instead of a <code>u32</code> value. By making it a pointer, we can finally alter the value of this function argument directly inside the body of the <code>add2()</code> function. You can see that the code example below compiles successfully.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> add2(x: *<span class="dt">u32</span>) <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> d: <span class="dt">u32</span> = <span class="dv">2</span>;</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    x.* = x.* + d;</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> x: <span class="dt">u32</span> = <span class="dv">4</span>;</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>    add2(&amp;x);</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>    std.debug.print(<span class="st">"Result: {d}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span>x<span class="op">}</span>);</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>Result: 6</code></pre>
<p>Even in this code example above, the <code>x</code> argument is still immutable. Which means that the pointer itself is immutable. Therefore, you cannot change the memory address that it points to. However, you can dereference the pointer to access the value that it points to, and also, to change this value, if you need to.</p>
</section>
</section>
<section id="sec-structs-and-oop" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="sec-structs-and-oop"><span class="header-section-number">2.3</span> Structs and OOP</h2>
<p>Zig is a language more closely related to C (which is a procedural language), than it is to C++ or Java (which are object-oriented languages). Because of that, you do not have advanced OOP (Object-Oriented Programming) patterns available in Zig, such as classes, interfaces or class inheritance. Nonetheless, OOP in Zig is still possible by using struct definitions.</p>
<p>With struct definitions, you can create (or define) a new data type in Zig. These struct definitions work the same way as they work in C. You give a name to this new struct (or, to this new data type you are creating), then, you list the data members of this new struct. You can also register functions inside this struct, and they become the methods of this particular struct (or data type), so that, every object that you create with this new type, will always have these methods available and associated with them.</p>
<p>In C++, when we create a new class, we normally have a constructor method (or, a constructor function) which is used to construct (or, to instantiate) every object of this particular class, and we also have a destructor method (or a destructor function), which is the function responsible for destroying every object of this class.</p>
<p>In Zig, we normally declare the constructor and the destructor methods of our structs, by declaring an <code>init()</code> and a <code>deinit()</code> methods inside the struct. This is just a naming convention that you will find across the entire Zig Standard Library. So, in Zig, the <code>init()</code> method of a struct is normally the constructor method of the class represented by this struct. While the <code>deinit()</code> method is the method used for destroying an existing instance of that struct.</p>
<p>The <code>init()</code> and <code>deinit()</code> methods are both used extensively in Zig code, and you will see both of them being used when we talk about allocators in <a href="01-memory.html#sec-allocators" class="quarto-xref"><span>Section 3.3</span></a>. But, as another example, let’s build a simple <code>User</code> struct to represent a user of some sort of system.</p>
<p>If you look at the <code>User</code> struct below, you can see the <code>struct</code> keyword. Notice the data members of this struct: <code>id</code>, <code>name</code> and <code>email</code>. Every data member has its type explicitly annotated, with the colon character (<code>:</code>) syntax that we described earlier in <a href="01-zig-weird.html#sec-root-file" class="quarto-xref"><span>Section 1.2.2</span></a>. But also notice that every line in the struct body that describes a data member, ends with a comma character (<code>,</code>). So every time you declare a data member in your Zig code, always end the line with a comma character, instead of ending it with the traditional semicolon character (<code>;</code>).</p>
<p>Next, we have registered an <code>init()</code> function as a method of this <code>User</code> struct. This <code>init()</code> method is the constructor method that we will use to instantiate every new <code>User</code> object. That is why this <code>init()</code> function returns a new <code>User</code> object as result.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> stdout = std.io.getStdOut().writer();</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> User = <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    id: <span class="dt">u64</span>,</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    name: []<span class="kw">const</span> <span class="dt">u8</span>,</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>    email: []<span class="kw">const</span> <span class="dt">u8</span>,</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> init(id: <span class="dt">u64</span>,</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>            name: []<span class="kw">const</span> <span class="dt">u8</span>,</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>            email: []<span class="kw">const</span> <span class="dt">u8</span>) User <span class="op">{</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> User <span class="op">{</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>            .id = id,</span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>            .name = name,</span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>            .email = email</span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>;</span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> print_name(self: User) !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">try</span> stdout.print(<span class="st">"{s}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span>self.name<span class="op">}</span>);</span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> u = User.init(<span class="dv">1</span>, <span class="st">"pedro"</span>, <span class="st">"email@gmail.com"</span>);</span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> u.print_name();</span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>pedro</code></pre>
</div>
</div>
<section id="the-pub-keyword" class="level3" data-number="2.3.1">
<h3 data-number="2.3.1" class="anchored" data-anchor-id="the-pub-keyword"><span class="header-section-number">2.3.1</span> The <code>pub</code> keyword</h3>
<p>The <code>pub</code> keyword plays an important role in struct declarations, and OOP in Zig. In essence, this keyword is short for “public”, and it makes an item/component available outside of the module where this item/component is declared. In other words, if I don’t apply the <code>pub</code> keyword on something, it means that this “something” is available to be called/used only from within the module where this “something” is declared.</p>
<p>To demonstrate the effect of this keyword let’s focus again on the <code>User</code> struct that we have declared on the previous section. For our example here, let’s suppose that this <code>User</code> struct is declared inside a Zig module named <code>user.zig</code>. If I don’t use the <code>pub</code> keyword on the <code>User</code> struct, it means that I can create an <code>User</code> object, and call it’s methods (<code>print_name()</code> and <code>init()</code>) only from within the module where the <code>User</code> struct is declared, which in this case is the <code>user.zig</code> module.</p>
<p>This is why the previous code example works fine. Because we declare and also use the <code>User</code> struct inside the same module. But problems start to arise when we try to import and call/use this struct from another module. For example, if I create a new module called <code>register.zig</code>, and import the <code>user.zig</code> module into it, and try to annotate any variable with the <code>User</code> type, I get an error from the compiler.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co">// register.zig</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> user = <span class="bu">@import</span>(<span class="st">"user.zig"</span>);</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> u: user.User = <span class="cn">undefined</span>;</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>    _ = u;</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>register.zig:3:18: error: 'User' is not marked 'pub'
    const u: user.User = undefined;
             ~~~~^~~~~
user.zig:3:1: note: declared here
const User = struct {
^~~~~</code></pre>
<p>Therefore, if you want to use something outside of the module where this “something” is declared, you have to mark it with the <code>pub</code> keyword. This “something” can be a module, a struct, a function, an object, etc.</p>
<p>For our example here, if we go back to the <code>user.zig</code> module, and add the <code>pub</code> keyword to the <code>User</code> struct declaration, then, I can successfully compile the <code>register.zig</code> module.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="co">// user.zig</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Added the `pub` keyword to `User`</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">const</span> User = <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb39"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co">// register.zig</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="co">// This works fine now!</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> user = <span class="bu">@import</span>(<span class="st">"user.zig"</span>);</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> u: user.User = <span class="cn">undefined</span>;</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>    _ = u;</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now, what do you think it will happen if I try to actually call from <code>register.zig</code> any of the methods of the <code>User</code> struct? For example, if I try to call the <code>init()</code> method? The answer is: I get a similar error message, warning me that the <code>init()</code> method is not marked as <code>pub</code>, as you can see below:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> user = <span class="bu">@import</span>(<span class="st">"user.zig"</span>);</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> u: user.User = user.User.init(</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>        <span class="dv">1</span>, <span class="st">"pedro"</span>, <span class="st">"email@gmail.com"</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>    );</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>    _ = u;</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>register.zig:3:35: error: 'init' is not marked 'pub'
    const u: user.User = user.User.init(
                         ~~~~~~~~~^~~~~
user.zig:8:5: note: declared here
    fn init(id: u64,
    ^~~~~~~</code></pre>
<p>Thus, just because we have applied the <code>pub</code> keyword on the struct declaration, this does not make the methods of that struct public as well. If we want to use any method from a struct (such as the <code>init()</code> method) outside of the module where this struct is declared, we have to mark this method with the <code>pub</code> keyword as well.</p>
<p>Going back to the <code>user.zig</code> module, and marking both the <code>init()</code> and <code>print_name()</code> methods with the <code>pub</code> keyword, makes them both available to the outside world, and, as consequence, makes the previous code example work.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co">// user.zig</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Added the `pub` keyword to `User.init`</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> init(</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Added the `pub` keyword to `User.print_name`</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> print_name(self: User) !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb43"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="co">// register.zig</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="co">// This works fine now!</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> user = <span class="bu">@import</span>(<span class="st">"user.zig"</span>);</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> u: user.User = user.User.init(</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>        <span class="dv">1</span>, <span class="st">"pedro"</span>, <span class="st">"email@gmail.com"</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>    );</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>    _ = u;</span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="sec-anonymous-struct-literals" class="level3" data-number="2.3.2">
<h3 data-number="2.3.2" class="anchored" data-anchor-id="sec-anonymous-struct-literals"><span class="header-section-number">2.3.2</span> Anonymous struct literals</h3>
<p>You can declare a struct object as a literal value. When we do that, we normally specify the data type of this struct literal by writing its data type just before the opening curly brace. For example, I could write a struct literal value of the type <code>User</code> that we have defined in the previous section like this:</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> eu = User <span class="op">{</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>    .id = <span class="dv">1</span>,</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>    .name = <span class="st">"Pedro"</span>,</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>    .email = <span class="st">"someemail@gmail.com"</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>_ = eu;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>However, in Zig, we can also write an anonymous struct literal. That is, you can write a struct literal, but not specify explicitly the type of this particular struct. An anonymous struct is written by using the syntax <code>.{}</code>. So, we essentially replaced the explicit type of the struct literal with a dot character (<code>.</code>).</p>
<p>As we described in <a href="#sec-type-inference" class="quarto-xref"><span>Section 2.4</span></a>, when you put a dot before a struct literal, the type of this struct literal is automatically inferred by the <code>zig</code> compiler. In essence, the <code>zig</code> compiler will look for some hint of what is the type of that struct. This hint can be the type annotation of a function argument, or the return type annotation of the function that you are using, or the type annotation of an existing object. If the compiler does find such type annotation, it will use this type in your literal struct.</p>
<p>Anonymous structs are very commonly used as inputs to function arguments in Zig. One example that you have seen already constantly, is the <code>print()</code> function from the <code>stdout</code> object. This function takes two arguments. The first argument, is a template string, which should contain string format specifiers in it, which tells how the values provided in the second argument should be printed into the message.</p>
<p>While the second argument is a struct literal that lists the values to be printed into the template message specified in the first argument. You normally want to use an anonymous struct literal here, so that the <code>zig</code> compiler do the job of specifying the type of this particular anonymous struct for you.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> stdout = std.io.getStdOut().writer();</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> stdout.print(<span class="st">"Hello, {s}!</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span><span class="st">"world"</span><span class="op">}</span>);</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Hello, world!</code></pre>
</div>
</div>
</section>
<section id="struct-declarations-must-be-constant" class="level3" data-number="2.3.3">
<h3 data-number="2.3.3" class="anchored" data-anchor-id="struct-declarations-must-be-constant"><span class="header-section-number">2.3.3</span> Struct declarations must be constant</h3>
<p>Types in Zig must be <code>const</code> or <code>comptime</code> (we are going to talk more about comptime in <a href="10-stack-project.html#sec-comptime" class="quarto-xref"><span>Section 12.1</span></a>). What this means is that you cannot create a new data type, and mark it as variable with the <code>var</code> keyword. So struct declarations are always constant. You cannot declare a new struct type using the <code>var</code> keyword. It must be <code>const</code>.</p>
<p>In the <code>Vec3</code> example below, this declaration is allowed because I’m using the <code>const</code> keyword to declare this new data type.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> Vec3 = <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    x: <span class="dt">f64</span>,</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    y: <span class="dt">f64</span>,</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>    z: <span class="dt">f64</span>,</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="sec-self-arg" class="level3" data-number="2.3.4">
<h3 data-number="2.3.4" class="anchored" data-anchor-id="sec-self-arg"><span class="header-section-number">2.3.4</span> The <code>self</code> method argument</h3>
<p>In every language that have OOP, when we declare a method of some class or struct, we usually declare this method as a function that has a <code>self</code> argument. This <code>self</code> argument is the reference to the object itself from which the method is being called from.</p>
<p>It’s not mandatory to use this <code>self</code> argument. But why would you not use this <code>self</code> argument? There is no reason to not use it. Because the only way to get access to the data stored in the data members of your struct is to access them through this <code>self</code> argument. If you don’t need to use the data in the data members of your struct inside your method, you very likely don’t need a method. You can just declare this logic as a simple function, outside of your struct declaration.</p>
<p>Take the <code>Vec3</code> struct below. Inside this <code>Vec3</code> struct we declared a method named <code>distance()</code>. This method calculates the distance between two <code>Vec3</code> objects, by following the distance formula in euclidean space. Notice that this <code>distance()</code> method takes two <code>Vec3</code> objects as input, <code>self</code> and <code>other</code>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> m = std.math;</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> Vec3 = <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>    x: <span class="dt">f64</span>,</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>    y: <span class="dt">f64</span>,</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>    z: <span class="dt">f64</span>,</span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> distance(self: Vec3, other: Vec3) <span class="dt">f64</span> <span class="op">{</span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">const</span> xd = m.pow(<span class="dt">f64</span>, self.x - other.x, <span class="fl">2.0</span>);</span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">const</span> yd = m.pow(<span class="dt">f64</span>, self.y - other.y, <span class="fl">2.0</span>);</span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">const</span> zd = m.pow(<span class="dt">f64</span>, self.z - other.z, <span class="fl">2.0</span>);</span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> m.sqrt(xd + yd + zd);</span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The <code>self</code> argument corresponds to the <code>Vec3</code> object from which this <code>distance()</code> method is being called from. While the <code>other</code> is a separate <code>Vec3</code> object that is given as input to this method. In the example below, the <code>self</code> argument corresponds to the object <code>v1</code>, because the <code>distance()</code> method is being called from the <code>v1</code> object, while the <code>other</code> argument corresponds to the object <code>v2</code>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> v1 = Vec3 <span class="op">{</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>    .x = <span class="fl">4.2</span>, .y = <span class="fl">2.4</span>, .z = <span class="fl">0.9</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> v2 = Vec3 <span class="op">{</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>    .x = <span class="fl">5.1</span>, .y = <span class="fl">5.6</span>, .z = <span class="fl">1.6</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>std.debug.print(</span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Distance: {d}</span><span class="sc">\n</span><span class="st">"</span>,</span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>    .<span class="op">{</span>v1.distance(v2)<span class="op">}</span></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>Distance: 3.3970575502926055</code></pre>
</section>
<section id="about-the-struct-state" class="level3" data-number="2.3.5">
<h3 data-number="2.3.5" class="anchored" data-anchor-id="about-the-struct-state"><span class="header-section-number">2.3.5</span> About the struct state</h3>
<p>Sometimes you don’t need to care about the state of your struct object. Sometimes, you just need to instantiate and use the objects, without altering their state. You can notice that when you have methods inside your struct declaration that might use the values that are present in the data members, but they do not alter the values in these data members of the struct in anyway.</p>
<p>The <code>Vec3</code> struct that was presented in <a href="#sec-self-arg" class="quarto-xref"><span>Section 2.3.4</span></a> is an example of that. This struct have a single method named <code>distance()</code>, and this method does use the values present in all three data members of the struct (<code>x</code>, <code>y</code> and <code>z</code>). But at the same time, this method does not change the values of these data members at any point.</p>
<p>As a result of that, when we create <code>Vec3</code> objects we usually create them as constant objects, like the <code>v1</code> and <code>v2</code> objects presented in <a href="#sec-self-arg" class="quarto-xref"><span>Section 2.3.4</span></a>. We can create them as variable objects with the <code>var</code> keyword, if we want to. But because the methods of this <code>Vec3</code> struct do not change the state of the objects in any point, it’s unnecessary to mark them as variable objects.</p>
<p>But why? Why am I talking about this here? It’s because the <code>self</code> argument in the methods are affected depending on whether the methods present in a struct change or don’t change the state of the object itself. More specifically, when you have a method in a struct that changes the state of the object (i.e., changes the value of a data member), the <code>self</code> argument in this method must be annotated in a different manner.</p>
<p>As I described in <a href="#sec-self-arg" class="quarto-xref"><span>Section 2.3.4</span></a>, the <code>self</code> argument in methods of a struct is the argument that receives as input the object from which the method was called from. We usually annotate this argument in the methods by writing <code>self</code>, followed by the colon character (<code>:</code>), and the data type of the struct to which the method belongs to (e.g.&nbsp;<code>User</code>, <code>Vec3</code>, etc.).</p>
<p>If we take the <code>Vec3</code> struct that we defined in the previous section as an example, we can see in the <code>distance()</code> method that this <code>self</code> argument is annotated as <code>self: Vec3</code>. Because the state of the <code>Vec3</code> object is never altered by this method.</p>
<p>But what if we do have a method that alters the state of the object, by altering the values of its data members, how should we annotate <code>self</code> in this instance? The answer is: “we should annotate <code>self</code> as a pointer of <code>x</code>, instead of just <code>x</code>”. In other words, you should annotate <code>self</code> as <code>self: *x</code>, instead of annotating it as <code>self: x</code>.</p>
<p>If we create a new method inside the <code>Vec3</code> object that, for example, expands the vector by multiplying its coordinates by a factor of two, then, we need to follow this rule specified in the previous paragraph. The code example below demonstrates this idea:</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> m = std.math;</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> Vec3 = <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>    x: <span class="dt">f64</span>,</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>    y: <span class="dt">f64</span>,</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>    z: <span class="dt">f64</span>,</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> distance(self: Vec3, other: Vec3) <span class="dt">f64</span> <span class="op">{</span></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">const</span> xd = m.pow(<span class="dt">f64</span>, self.x - other.x, <span class="fl">2.0</span>);</span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">const</span> yd = m.pow(<span class="dt">f64</span>, self.y - other.y, <span class="fl">2.0</span>);</span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">const</span> zd = m.pow(<span class="dt">f64</span>, self.z - other.z, <span class="fl">2.0</span>);</span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> m.sqrt(xd + yd + zd);</span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> twice(self: *Vec3) <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>        self.x = self.x * <span class="fl">2.0</span>;</span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a>        self.y = self.y * <span class="fl">2.0</span>;</span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a>        self.z = self.z * <span class="fl">2.0</span>;</span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Notice in the code example above that we have added a new method to our <code>Vec3</code> struct named <code>twice()</code>. This method doubles the coordinate values of our vector object. In the case of the <code>twice()</code> method, we annotated the <code>self</code> argument as <code>*Vec3</code>, indicating that this argument receives a pointer (or a reference, if you prefer to call it this way) to a <code>Vec3</code> object as input.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> v3 = Vec3 <span class="op">{</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>    .x = <span class="fl">4.2</span>, .y = <span class="fl">2.4</span>, .z = <span class="fl">0.9</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>v3.twice();</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>std.debug.print(<span class="st">"Doubled: {d}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span>v3.x<span class="op">}</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>Doubled: 8.4</code></pre>
<p>Now, if you change the <code>self</code> argument in this <code>twice()</code> method to <code>self: Vec3</code>, like in the <code>distance()</code> method, you will get the compiler error exposed below as result. Notice that this error message is showing a line from the <code>twice()</code> method body, indicating that you cannot alter the value of the <code>x</code> data member.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="co">// If we change the function signature of double to:</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> twice(self: Vec3) <span class="dt">void</span> <span class="op">{</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>t.zig:16:13: error: cannot assign to constant
        self.x = self.x * 2.0;
        ~~~~^~</code></pre>
<p>This error message indicates that the <code>x</code> data member belongs to a constant object, and, because of that, it cannot be changed. Ultimately, this error message is telling us that the <code>self</code> argument is constant.</p>
<p>If you take some time, and think hard about this error message, you will understand it. You already have the tools to understand why we are getting this error message. We have talked about it already in <a href="#sec-fun-pars" class="quarto-xref"><span>Section 2.2</span></a>. So remember, every function argument is immutable in Zig, and <code>self</code> is no exception to this rule.</p>
<p>In this example, we marked the <code>v3</code> object as a variable object. But this does not matter. Because it’s not about the input object, it’s about the function argument.</p>
<p>The problem begins when we try to alter the value of <code>self</code> directly, which is a function argument, and, every function argument is immutable by default. You may ask yourself how can we overcome this barrier, and once again, the solution was also discussed in <a href="#sec-fun-pars" class="quarto-xref"><span>Section 2.2</span></a>. We overcome this barrier, by explicitly marking the <code>self</code> argument as a pointer.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>If a method of your <code>x</code> struct alters the state of the object, by changing the value of any data member, then, remember to use <code>self: *x</code>, instead of <code>self: x</code> in the function signature of this method.</p>
</div>
</div>
<p>You could also interpret the content discussed in this section as: “if you need to alter the state of your <code>x</code> struct object in one of its methods, you must explicitly pass the <code>x</code> struct object by reference to the <code>self</code> argument of this method”.</p>
</section>
</section>
<section id="sec-type-inference" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="sec-type-inference"><span class="header-section-number">2.4</span> Type inference</h2>
<p>Zig is a strongly typed language. But, there are some situations where you don’t have to explicitly write the type of every single object in your source code, as you would expect from a traditional strongly typed language, such as C and C++.</p>
<p>In some situations, the <code>zig</code> compiler can use type inference to solve the data types for you, easing some of the burden that you carry as a developer. The most common way this happens is through function arguments that receive struct objects as input.</p>
<p>In general, type inference in Zig is done by using the dot character (<code>.</code>). Everytime you see a dot character written before a struct literal, or before an enum value, or something like that, you know that this dot character is playing a special part in this place. More specifically, it’s telling the <code>zig</code> compiler something along the lines of: “Hey! Can you infer the type of this value for me? Please!”. In other words, this dot character is playing a similar role as the <code>auto</code> keyword in C++.</p>
<p>I gave you some examples of this in <a href="#sec-anonymous-struct-literals" class="quarto-xref"><span>Section 2.3.2</span></a>, where we used anonymous struct literals. Anonymous struct literals are, struct literals that use type inference to infer the exact type of this particular struct literal. This type inference is done by looking for some minimal hint of the correct data type to be used. You could say that the <code>zig</code> compiler looks for any neighbouring type annotation that might tell it what the correct type would be.</p>
<p>Another common place where we use type inference in Zig is at switch statements (which we talked about in <a href="#sec-switch" class="quarto-xref"><span>Section 2.1.2</span></a>). I also gave some other examples of type inference in <a href="#sec-switch" class="quarto-xref"><span>Section 2.1.2</span></a>, where we were inferring the data types of enum values listed inside of switch statements (e.g.&nbsp;<code>.DE</code>). But as another example, take a look at this <code>fence()</code> function reproduced below, which comes from the <a href="https://github.com/ziglang/zig/blob/master/lib/std/atomic.zig"><code>atomic.zig</code> module</a><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> of the Zig Standard Library.</p>
<p>There are a lot of things in this function that we haven’t talked about yet, such as: what <code>comptime</code> means? <code>inline</code>? <code>extern</code>? Let’s just ignore all of these things, and focus solely on the switch statement that is inside this function.</p>
<p>We can see that this switch statement uses the <code>order</code> object as input. This <code>order</code> object is one of the inputs of this <code>fence()</code> function, and we can see in the type annotation, that this object is of type <code>AtomicOrder</code>. We can also see a bunch of values inside the switch statements that begin with a dot character, such as <code>.release</code> and <code>.acquire</code>.</p>
<p>Because these weird values contain a dot character before them, we are asking the <code>zig</code> compiler to infer the types of these values inside the switch statement. Then, the <code>zig</code> compiler is looking into the current context where these values are being used, and trying to infer the types of these values.</p>
<p>Since they are being used inside a switch statement, the <code>zig</code> compiler looks into the type of the input object given to the switch statement, which is the <code>order</code> object in this case. Because this object have type <code>AtomicOrder</code>, the <code>zig</code> compiler infers that these values are data members from this type <code>AtomicOrder</code>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">inline</span> <span class="kw">fn</span> fence(self: *Self, <span class="kw">comptime</span> order: AtomicOrder) <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// many lines of code ...</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> (builtin.sanitize_thread) <span class="op">{</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">const</span> tsan = <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>            <span class="kw">extern</span> <span class="st">"c"</span> <span class="kw">fn</span> __tsan_acquire(addr: *anyopaque) <span class="dt">void</span>;</span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">extern</span> <span class="st">"c"</span> <span class="kw">fn</span> __tsan_release(addr: *anyopaque) <span class="dt">void</span>;</span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>;</span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">const</span> addr: *anyopaque = self;</span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> <span class="kw">switch</span> (order) <span class="op">{</span></span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a>            .unordered, .monotonic =&gt; <span class="bu">@compileError</span>(</span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a>                <span class="bu">@tagName</span>(order)</span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true" tabindex="-1"></a>                ++ <span class="st">" only applies to atomic loads and stores"</span></span>
<span id="cb56-14"><a href="#cb56-14" aria-hidden="true" tabindex="-1"></a>            ),</span>
<span id="cb56-15"><a href="#cb56-15" aria-hidden="true" tabindex="-1"></a>            .acquire =&gt; tsan.__tsan_acquire(addr),</span>
<span id="cb56-16"><a href="#cb56-16" aria-hidden="true" tabindex="-1"></a>            .release =&gt; tsan.__tsan_release(addr),</span>
<span id="cb56-17"><a href="#cb56-17" aria-hidden="true" tabindex="-1"></a>            .acq_rel, .seq_cst =&gt; <span class="op">{</span></span>
<span id="cb56-18"><a href="#cb56-18" aria-hidden="true" tabindex="-1"></a>                tsan.__tsan_acquire(addr);</span>
<span id="cb56-19"><a href="#cb56-19" aria-hidden="true" tabindex="-1"></a>                tsan.__tsan_release(addr);</span>
<span id="cb56-20"><a href="#cb56-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span>,</span>
<span id="cb56-21"><a href="#cb56-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>;</span>
<span id="cb56-22"><a href="#cb56-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb56-23"><a href="#cb56-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-24"><a href="#cb56-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">@fence</span>(order);</span>
<span id="cb56-25"><a href="#cb56-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>This is how basic type inference is done in Zig. If we didn’t use the dot character before the values inside this switch statement, then, we would be forced to explicitly write the data types of these values. For example, instead of writing <code>.release</code> we would have to write <code>AtomicOrder.release</code>. We would have to do this for every single value in this switch statement, and this is a lot of work. That is why type inference is commonly used on switch statements in Zig.</p>
</section>
<section id="sec-type-cast" class="level2" data-number="2.5">
<h2 data-number="2.5" class="anchored" data-anchor-id="sec-type-cast"><span class="header-section-number">2.5</span> Type casting</h2>
<p>In this section, I want to discuss type casting (or, type conversion) with you. We use type casting when we have an object of type “x”, and we want to convert it into an object of type “y”, i.e., we want to change the data type of the object.</p>
<p>Most languages have a formal way to perform type casting. In Rust for example, we normally use the keyword <code>as</code>, and in C, we normally use the type casting syntax, e.g.&nbsp;<code>(int) x</code>. In Zig, we use the <code>@as()</code> built-in function to cast an object of type “x”, into an object of type “y”.</p>
<p>This <code>@as()</code> function is the preferred way to perform type conversion (or type casting) in Zig. Because it’s explicit, and, it also performs the casting only if it is unambiguous and safe. To use this function, you just provide the target data type in the first argument, and, the object that you want cast as the second argument.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> expect = std.testing.expect;</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a><span class="kw">test</span> <span class="op">{</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> x: <span class="dt">usize</span> = <span class="dv">500</span>;</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> y = <span class="bu">@as</span>(<span class="dt">u32</span>, x);</span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> expect(<span class="bu">@TypeOf</span>(y) == <span class="dt">u32</span>);</span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>1/1 file3fc93b4ea641.test_0...OKAll 1 tests passed
  d.</code></pre>
</div>
</div>
<p>This is the general way to perform type casting in Zig. But remember, <code>@as()</code> works only when casting is unambiguous and safe. There are many situations where these assumptions do not hold. For example,</p>
<p>when casting an integer value into a float value, or vice-versa, it’s not clear to the compiler how to perform this conversion safely.</p>
<p>Therefore, we need to use specialized “casting functions” in such situations. For example, if you want to cast an integer value into a float value, then, you should use the <code>@floatFromInt()</code> function. In the inverse scenario, you should use the <code>@intFromFloat()</code> function.</p>
<p>In these functions, you just provide the object that you want to cast as input. Then, the target data type of the “type casting operation” is determined by the type annotation of the object where you are saving the results. In the example below, we are casting the object <code>x</code> into a value of type <code>f32</code>, because the object <code>y</code>, which is where we are saving the results, is annotated as an object of type <code>f32</code>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> expect = std.testing.expect;</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="kw">test</span> <span class="op">{</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> x: <span class="dt">usize</span> = <span class="dv">565</span>;</span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> y: <span class="dt">f32</span> = <span class="bu">@floatFromInt</span>(x);</span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> expect(<span class="bu">@TypeOf</span>(y) == <span class="dt">f32</span>);</span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>1/1 file3fc91795a712.test_0...OKAll 1 tests passed
  d.</code></pre>
</div>
</div>
<p>Another built-in function that is very useful when performing type casting operations is <code>@ptrCast()</code>. In essence, we use the <code>@as()</code> built-in function when we want to explicit convert (or cast) a Zig value/object from a type “x” to a type “y”, etc. However, pointers (we are going to discuss pointers in more depth in <a href="05-pointers.html" class="quarto-xref"><span>Chapter 6</span></a>) are a special type of object in Zig, i.e., they are treated differently from “normal objects”.</p>
<p>Everytime a pointer is involved in some “type casting operation” in Zig, the <code>@ptrCast()</code> function is used. This function works similarly to <code>@floatFromInt()</code>. You just provide the pointer object that you want to cast as input to this function, and the target data type is, once again, determined by the type annotation of the object where the results are being stored.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> expect = std.testing.expect;</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a><span class="kw">test</span> <span class="op">{</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> bytes <span class="kw">align</span>(<span class="bu">@alignOf</span>(<span class="dt">u32</span>)) = [_]<span class="dt">u8</span><span class="op">{</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>        <span class="bn">0x12</span>, <span class="bn">0x12</span>, <span class="bn">0x12</span>, <span class="bn">0x12</span></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>;</span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> u32_ptr: *<span class="kw">const</span> <span class="dt">u32</span> = <span class="bu">@ptrCast</span>(&amp;bytes);</span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> expect(<span class="bu">@TypeOf</span>(u32_ptr) == *<span class="kw">const</span> <span class="dt">u32</span>);</span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>1/1 file3fc945f8b4b0.test_0...OKAll 1 tests passed
  d.</code></pre>
</div>
</div>
</section>
<section id="modules" class="level2" data-number="2.6">
<h2 data-number="2.6" class="anchored" data-anchor-id="modules"><span class="header-section-number">2.6</span> Modules</h2>
<p>We already talked about what modules are, and also, how to import other modules into your current module via <em>import statements</em>. Every Zig module (i.e., a <code>.zig</code> file) that you write in your project is internally stored as a struct object. Take the line exposed below as an example. In this line we are importing the Zig Standard Library into our current module.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>When we want to access the functions and objects from the standard library, we are basically accessing the data members of the struct stored in the <code>std</code> object. That is why we use the same syntax that we use in normal structs, with the dot operator (<code>.</code>) to access the data members and methods of the struct.</p>
<p>When this “import statement” gets executed, the result of this expression is a struct object that contains the Zig Standard Library modules, global variables, functions, etc. And this struct object gets saved (or stored) inside the constant object named <code>std</code>.</p>
<p>Take the <a href="https://github.com/kprotty/zap/blob/blog/src/thread_pool.zig"><code>thread_pool.zig</code> module from the project <code>zap</code></a><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> as an example. This module is written as if it was a big struct. That is why we have a top-level and public <code>init()</code> method written in this module. The idea is that all top-level functions written in this module are methods from the struct, and all top-level objects and struct declarations are data members of this struct. The module is the struct itself.</p>
<p>So you would import and use this module by doing something like this:</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> ThreadPool = <span class="bu">@import</span>(<span class="st">"thread_pool.zig"</span>);</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> num_cpus = std.Thread.getCpuCount()</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">catch</span> <span class="bu">@panic</span>(<span class="st">"failed to get cpu core count"</span>);</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> num_threads = std.math.cast(<span class="dt">u16</span>, num_cpus)</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">catch</span> std.math.maxInt(<span class="dt">u16</span>);</span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> pool = ThreadPool.init(</span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>    .<span class="op">{</span> .max_threads = num_threads <span class="op">}</span></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>


<!-- -->

</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p><a href="https://github.com/ziglang/zig/blob/master/lib/std/debug.zig" class="uri">https://github.com/ziglang/zig/blob/master/lib/std/debug.zig</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><a href="https://github.com/ziglang/zig/blob/master/lib/std/atomic.zig" class="uri">https://github.com/ziglang/zig/blob/master/lib/std/atomic.zig</a>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p><a href="https://github.com/kprotty/zap/blob/blog/src/thread_pool.zig" class="uri">https://github.com/kprotty/zap/blob/blog/src/thread_pool.zig</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
<<<<<<< HEAD
=======
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
>>>>>>> origin
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../Chapters/01-zig-weird.html" class="pagination-link" aria-label="Introducing Zig">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introducing Zig</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../Chapters/01-memory.html" class="pagination-link" aria-label="Memory and Allocators">
        <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Memory and Allocators</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb65" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="an">engine:</span><span class="co"> knitr</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a><span class="an">knitr:</span><span class="co"> true</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a><span class="an">syntax-definition:</span><span class="co"> "../Assets/zig.xml"</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a><span class="co">#| include: false</span></span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a><span class="fu">source</span>(<span class="st">"../zig_engine.R"</span>)</span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>knitr<span class="sc">::</span>opts_chunk<span class="sc">$</span><span class="fu">set</span>(</span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a>    <span class="at">auto_main =</span> <span class="cn">FALSE</span>,</span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a>    <span class="at">build_type =</span> <span class="st">"lib"</span></span>
<span id="cb65-15"><a href="#cb65-15" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb65-16"><a href="#cb65-16" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-17"><a href="#cb65-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-18"><a href="#cb65-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-19"><a href="#cb65-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-20"><a href="#cb65-20" aria-hidden="true" tabindex="-1"></a><span class="fu"># Control flow, structs, modules and types</span></span>
<span id="cb65-21"><a href="#cb65-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-22"><a href="#cb65-22" aria-hidden="true" tabindex="-1"></a>We have discussed a lot of Zig's syntax in the last chapter,</span>
<span id="cb65-23"><a href="#cb65-23" aria-hidden="true" tabindex="-1"></a>especially in @sec-root-file and @sec-main-file.</span>
<span id="cb65-24"><a href="#cb65-24" aria-hidden="true" tabindex="-1"></a>But we still need to discuss some other very important</span>
<span id="cb65-25"><a href="#cb65-25" aria-hidden="true" tabindex="-1"></a>elements of the language. Elements that you will use constantly on your day-to-day</span>
<span id="cb65-26"><a href="#cb65-26" aria-hidden="true" tabindex="-1"></a>routine.</span>
<span id="cb65-27"><a href="#cb65-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-28"><a href="#cb65-28" aria-hidden="true" tabindex="-1"></a>We begin this chapter by discussing the different keywords and structures</span>
<span id="cb65-29"><a href="#cb65-29" aria-hidden="true" tabindex="-1"></a>in Zig related to control flow (e.g. loops and if statements).</span>
<span id="cb65-30"><a href="#cb65-30" aria-hidden="true" tabindex="-1"></a>Then, we talk about structs and how they can be used to do some</span>
<span id="cb65-31"><a href="#cb65-31" aria-hidden="true" tabindex="-1"></a>basic Object-Oriented (OOP) patterns in Zig. We also talk about</span>
<span id="cb65-32"><a href="#cb65-32" aria-hidden="true" tabindex="-1"></a>type inference and type casting.</span>
<span id="cb65-33"><a href="#cb65-33" aria-hidden="true" tabindex="-1"></a>Finally, we end this chapter by discussing modules, and how they relate</span>
<span id="cb65-34"><a href="#cb65-34" aria-hidden="true" tabindex="-1"></a>to structs.</span>
<span id="cb65-35"><a href="#cb65-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-36"><a href="#cb65-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-37"><a href="#cb65-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-38"><a href="#cb65-38" aria-hidden="true" tabindex="-1"></a><span class="fu">## Control flow {#sec-zig-control-flow}</span></span>
<span id="cb65-39"><a href="#cb65-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-40"><a href="#cb65-40" aria-hidden="true" tabindex="-1"></a>Sometimes, you need to make decisions in your program. Maybe you need to decide</span>
<span id="cb65-41"><a href="#cb65-41" aria-hidden="true" tabindex="-1"></a>whether or not to execute a specific piece of code. Or maybe,</span>
<span id="cb65-42"><a href="#cb65-42" aria-hidden="true" tabindex="-1"></a>you need to apply the same operation over a sequence of values. These kinds of tasks,</span>
<span id="cb65-43"><a href="#cb65-43" aria-hidden="true" tabindex="-1"></a>involve using structures that are capable of changing the "control flow" of our program.</span>
<span id="cb65-44"><a href="#cb65-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-45"><a href="#cb65-45" aria-hidden="true" tabindex="-1"></a>In computer science, the term "control flow" usually refers to the order in which expressions (or commands)</span>
<span id="cb65-46"><a href="#cb65-46" aria-hidden="true" tabindex="-1"></a>are evaluated in a given language or program. But this term is also used to refer</span>
<span id="cb65-47"><a href="#cb65-47" aria-hidden="true" tabindex="-1"></a>to structures that are capable of changing this "evaluation order" of the commands</span>
<span id="cb65-48"><a href="#cb65-48" aria-hidden="true" tabindex="-1"></a>executed by a given language/program.</span>
<span id="cb65-49"><a href="#cb65-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-50"><a href="#cb65-50" aria-hidden="true" tabindex="-1"></a>These structures are better known</span>
<span id="cb65-51"><a href="#cb65-51" aria-hidden="true" tabindex="-1"></a>by a set of terms, such as: loops, if/else statements, switch statements, among others. So,</span>
<span id="cb65-52"><a href="#cb65-52" aria-hidden="true" tabindex="-1"></a>loops and if/else statements are examples of structures that can change the "control</span>
<span id="cb65-53"><a href="#cb65-53" aria-hidden="true" tabindex="-1"></a>flow" of our program. The keywords <span class="in">`continue`</span> and <span class="in">`break`</span> are also examples of symbols</span>
<span id="cb65-54"><a href="#cb65-54" aria-hidden="true" tabindex="-1"></a>that can change the order of evaluation, since they can move our program to the next iteration</span>
<span id="cb65-55"><a href="#cb65-55" aria-hidden="true" tabindex="-1"></a>of a loop, or make the loop stop completely.</span>
<span id="cb65-56"><a href="#cb65-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-57"><a href="#cb65-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-58"><a href="#cb65-58" aria-hidden="true" tabindex="-1"></a><span class="fu">### If/else statements</span></span>
<span id="cb65-59"><a href="#cb65-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-60"><a href="#cb65-60" aria-hidden="true" tabindex="-1"></a>An if/else statement performs a "conditional flow operation".</span>
<span id="cb65-61"><a href="#cb65-61" aria-hidden="true" tabindex="-1"></a>A conditional flow control (or choice control) allows you to execute</span>
<span id="cb65-62"><a href="#cb65-62" aria-hidden="true" tabindex="-1"></a>or ignore a certain block of commands based on a logical condition.</span>
<span id="cb65-63"><a href="#cb65-63" aria-hidden="true" tabindex="-1"></a>Many programmers and computer science professionals also use</span>
<span id="cb65-64"><a href="#cb65-64" aria-hidden="true" tabindex="-1"></a>the term "branching" in this case.</span>
<span id="cb65-65"><a href="#cb65-65" aria-hidden="true" tabindex="-1"></a>In essence, an if/else statement allow us to use the result of a logical test</span>
<span id="cb65-66"><a href="#cb65-66" aria-hidden="true" tabindex="-1"></a>to decide whether or not to execute a given block of commands.</span>
<span id="cb65-67"><a href="#cb65-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-68"><a href="#cb65-68" aria-hidden="true" tabindex="-1"></a>In Zig, we write if/else statements by using the keywords <span class="in">`if`</span> and <span class="in">`else`</span>.</span>
<span id="cb65-69"><a href="#cb65-69" aria-hidden="true" tabindex="-1"></a>We start with the <span class="in">`if`</span> keyword followed by a logical test inside a pair</span>
<span id="cb65-70"><a href="#cb65-70" aria-hidden="true" tabindex="-1"></a>of parentheses, followed by a pair of curly braces which contains the lines</span>
<span id="cb65-71"><a href="#cb65-71" aria-hidden="true" tabindex="-1"></a>of code to be executed in case the logical test returns the value <span class="in">`true`</span>.</span>
<span id="cb65-72"><a href="#cb65-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-73"><a href="#cb65-73" aria-hidden="true" tabindex="-1"></a>After that, you can optionally add an <span class="in">`else`</span> statement. To do that, just add the <span class="in">`else`</span></span>
<span id="cb65-74"><a href="#cb65-74" aria-hidden="true" tabindex="-1"></a>keyword followed by a pair of curly braces, with the lines of code</span>
<span id="cb65-75"><a href="#cb65-75" aria-hidden="true" tabindex="-1"></a>to executed in case the logical test defined at <span class="in">`if`</span> returns <span class="in">`false`</span>.</span>
<span id="cb65-76"><a href="#cb65-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-77"><a href="#cb65-77" aria-hidden="true" tabindex="-1"></a>In the example below, we are testing if the object <span class="in">`x`</span> contains a number</span>
<span id="cb65-78"><a href="#cb65-78" aria-hidden="true" tabindex="-1"></a>that is greater than 10. Judging by the output printed to the console,</span>
<span id="cb65-79"><a href="#cb65-79" aria-hidden="true" tabindex="-1"></a>we know that this logical test returned <span class="in">`false`</span>. Because the output</span>
<span id="cb65-80"><a href="#cb65-80" aria-hidden="true" tabindex="-1"></a>in the console is compatible with the line of code present in the</span>
<span id="cb65-81"><a href="#cb65-81" aria-hidden="true" tabindex="-1"></a><span class="in">`else`</span> branch of the if/else statement.</span>
<span id="cb65-82"><a href="#cb65-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-83"><a href="#cb65-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-86"><a href="#cb65-86" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-87"><a href="#cb65-87" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb65-88"><a href="#cb65-88" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb65-89"><a href="#cb65-89" aria-hidden="true" tabindex="-1"></a><span class="in">const x = 5;</span></span>
<span id="cb65-90"><a href="#cb65-90" aria-hidden="true" tabindex="-1"></a><span class="in">if (x &gt; 10) {</span></span>
<span id="cb65-91"><a href="#cb65-91" aria-hidden="true" tabindex="-1"></a><span class="in">    try stdout.print(</span></span>
<span id="cb65-92"><a href="#cb65-92" aria-hidden="true" tabindex="-1"></a><span class="in">        "x &gt; 10!\n", .{}</span></span>
<span id="cb65-93"><a href="#cb65-93" aria-hidden="true" tabindex="-1"></a><span class="in">    );</span></span>
<span id="cb65-94"><a href="#cb65-94" aria-hidden="true" tabindex="-1"></a><span class="in">} else {</span></span>
<span id="cb65-95"><a href="#cb65-95" aria-hidden="true" tabindex="-1"></a><span class="in">    try stdout.print(</span></span>
<span id="cb65-96"><a href="#cb65-96" aria-hidden="true" tabindex="-1"></a><span class="in">        "x &lt;= 10!\n", .{}</span></span>
<span id="cb65-97"><a href="#cb65-97" aria-hidden="true" tabindex="-1"></a><span class="in">    );</span></span>
<span id="cb65-98"><a href="#cb65-98" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb65-99"><a href="#cb65-99" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-100"><a href="#cb65-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-101"><a href="#cb65-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-102"><a href="#cb65-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-103"><a href="#cb65-103" aria-hidden="true" tabindex="-1"></a><span class="fu">### Switch statements {#sec-switch}</span></span>
<span id="cb65-104"><a href="#cb65-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-105"><a href="#cb65-105" aria-hidden="true" tabindex="-1"></a>Switch statements are also available in Zig, and they have a very similar syntax to a switch statement in Rust.</span>
<span id="cb65-106"><a href="#cb65-106" aria-hidden="true" tabindex="-1"></a>As you would expect, to write a switch statement in Zig we use the <span class="in">`switch`</span> keyword.</span>
<span id="cb65-107"><a href="#cb65-107" aria-hidden="true" tabindex="-1"></a>We provide the value that we want to "switch over" inside a</span>
<span id="cb65-108"><a href="#cb65-108" aria-hidden="true" tabindex="-1"></a>pair of parentheses. Then, we list the possible combinations (or "branches")</span>
<span id="cb65-109"><a href="#cb65-109" aria-hidden="true" tabindex="-1"></a>inside a pair of curly braces.</span>
<span id="cb65-110"><a href="#cb65-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-111"><a href="#cb65-111" aria-hidden="true" tabindex="-1"></a>Let's take a look at the code example below. You can see that</span>
<span id="cb65-112"><a href="#cb65-112" aria-hidden="true" tabindex="-1"></a>I'm creating an enum type called <span class="in">`Role`</span>. We talk more about enums in @sec-enum.</span>
<span id="cb65-113"><a href="#cb65-113" aria-hidden="true" tabindex="-1"></a>But in summary, this <span class="in">`Role`</span> type is listing different types of roles in a fictitious</span>
<span id="cb65-114"><a href="#cb65-114" aria-hidden="true" tabindex="-1"></a>company, like <span class="in">`SE`</span> for Software Engineer, <span class="in">`DE`</span> for Data Engineer, <span class="in">`PM`</span> for Product Manager,</span>
<span id="cb65-115"><a href="#cb65-115" aria-hidden="true" tabindex="-1"></a>etc.</span>
<span id="cb65-116"><a href="#cb65-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-117"><a href="#cb65-117" aria-hidden="true" tabindex="-1"></a>Notice that we are using the value from the <span class="in">`role`</span> object in the</span>
<span id="cb65-118"><a href="#cb65-118" aria-hidden="true" tabindex="-1"></a>switch statement, to discover which exact area we need to store in the <span class="in">`area`</span> variable object.</span>
<span id="cb65-119"><a href="#cb65-119" aria-hidden="true" tabindex="-1"></a>Also notice that we are using type inference inside the switch statement, with the dot character,</span>
<span id="cb65-120"><a href="#cb65-120" aria-hidden="true" tabindex="-1"></a>as we are going to describe in @sec-type-inference.</span>
<span id="cb65-121"><a href="#cb65-121" aria-hidden="true" tabindex="-1"></a>This makes the <span class="in">`zig`</span> compiler infer the correct data type of the values (<span class="in">`PM`</span>, <span class="in">`SE`</span>, etc.) for us.</span>
<span id="cb65-122"><a href="#cb65-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-123"><a href="#cb65-123" aria-hidden="true" tabindex="-1"></a>Also notice that, we are grouping multiple values in the same branch of the switch statement.</span>
<span id="cb65-124"><a href="#cb65-124" aria-hidden="true" tabindex="-1"></a>We just separate each possible value with a comma. For example, if <span class="in">`role`</span> contains either <span class="in">`DE`</span> or <span class="in">`DA`</span>,</span>
<span id="cb65-125"><a href="#cb65-125" aria-hidden="true" tabindex="-1"></a>the <span class="in">`area`</span> variable would contain the value <span class="in">`"Data &amp; Analytics"`</span>, instead of <span class="in">`"Platform"`</span> or <span class="in">`"Sales"`</span>.</span>
<span id="cb65-126"><a href="#cb65-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-129"><a href="#cb65-129" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-130"><a href="#cb65-130" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb65-131"><a href="#cb65-131" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: false</span></span>
<span id="cb65-132"><a href="#cb65-132" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb65-133"><a href="#cb65-133" aria-hidden="true" tabindex="-1"></a><span class="in">const stdout = std.io.getStdOut().writer();</span></span>
<span id="cb65-134"><a href="#cb65-134" aria-hidden="true" tabindex="-1"></a><span class="in">const Role = enum {</span></span>
<span id="cb65-135"><a href="#cb65-135" aria-hidden="true" tabindex="-1"></a><span class="in">    SE, DPE, DE, DA, PM, PO, KS</span></span>
<span id="cb65-136"><a href="#cb65-136" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb65-137"><a href="#cb65-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-138"><a href="#cb65-138" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb65-139"><a href="#cb65-139" aria-hidden="true" tabindex="-1"></a><span class="in">    var area: []const u8 = undefined;</span></span>
<span id="cb65-140"><a href="#cb65-140" aria-hidden="true" tabindex="-1"></a><span class="in">    const role = Role.SE;</span></span>
<span id="cb65-141"><a href="#cb65-141" aria-hidden="true" tabindex="-1"></a><span class="in">    switch (role) {</span></span>
<span id="cb65-142"><a href="#cb65-142" aria-hidden="true" tabindex="-1"></a><span class="in">        .PM, .SE, .DPE, .PO =&gt; {</span></span>
<span id="cb65-143"><a href="#cb65-143" aria-hidden="true" tabindex="-1"></a><span class="in">            area = "Platform";</span></span>
<span id="cb65-144"><a href="#cb65-144" aria-hidden="true" tabindex="-1"></a><span class="in">        },</span></span>
<span id="cb65-145"><a href="#cb65-145" aria-hidden="true" tabindex="-1"></a><span class="in">        .DE, .DA =&gt; {</span></span>
<span id="cb65-146"><a href="#cb65-146" aria-hidden="true" tabindex="-1"></a><span class="in">            area = "Data &amp; Analytics";</span></span>
<span id="cb65-147"><a href="#cb65-147" aria-hidden="true" tabindex="-1"></a><span class="in">        },</span></span>
<span id="cb65-148"><a href="#cb65-148" aria-hidden="true" tabindex="-1"></a><span class="in">        .KS =&gt; {</span></span>
<span id="cb65-149"><a href="#cb65-149" aria-hidden="true" tabindex="-1"></a><span class="in">            area = "Sales";</span></span>
<span id="cb65-150"><a href="#cb65-150" aria-hidden="true" tabindex="-1"></a><span class="in">        },</span></span>
<span id="cb65-151"><a href="#cb65-151" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb65-152"><a href="#cb65-152" aria-hidden="true" tabindex="-1"></a><span class="in">    try stdout.print("{s}\n", .{area});</span></span>
<span id="cb65-153"><a href="#cb65-153" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb65-154"><a href="#cb65-154" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-155"><a href="#cb65-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-156"><a href="#cb65-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-157"><a href="#cb65-157" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Switch statements must exhaust all possibilities</span></span>
<span id="cb65-158"><a href="#cb65-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-159"><a href="#cb65-159" aria-hidden="true" tabindex="-1"></a>One very important aspect about switch statements in Zig</span>
<span id="cb65-160"><a href="#cb65-160" aria-hidden="true" tabindex="-1"></a>is that they must exhaust all existing possibilities.</span>
<span id="cb65-161"><a href="#cb65-161" aria-hidden="true" tabindex="-1"></a>In other words, all possible values that could be found inside the <span class="in">`role`</span></span>
<span id="cb65-162"><a href="#cb65-162" aria-hidden="true" tabindex="-1"></a>object must be explicitly handled in this switch statement.</span>
<span id="cb65-163"><a href="#cb65-163" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-164"><a href="#cb65-164" aria-hidden="true" tabindex="-1"></a>Since the <span class="in">`role`</span> object has type <span class="in">`Role`</span>, the only possible values to</span>
<span id="cb65-165"><a href="#cb65-165" aria-hidden="true" tabindex="-1"></a>be found inside this object are <span class="in">`PM`</span>, <span class="in">`SE`</span>, <span class="in">`DPE`</span>, <span class="in">`PO`</span>, <span class="in">`DE`</span>, <span class="in">`DA`</span> and <span class="in">`KS`</span>.</span>
<span id="cb65-166"><a href="#cb65-166" aria-hidden="true" tabindex="-1"></a>There are no other possible values to be stored in this <span class="in">`role`</span> object.</span>
<span id="cb65-167"><a href="#cb65-167" aria-hidden="true" tabindex="-1"></a>Thus, the switch statements must have a combination (branch) for each one of these values.</span>
<span id="cb65-168"><a href="#cb65-168" aria-hidden="true" tabindex="-1"></a>This is what "exhaust all existing possibilities" means. The switch statement covers</span>
<span id="cb65-169"><a href="#cb65-169" aria-hidden="true" tabindex="-1"></a>every possible case.</span>
<span id="cb65-170"><a href="#cb65-170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-171"><a href="#cb65-171" aria-hidden="true" tabindex="-1"></a>Therefore, you cannot write a switch statement in Zig, and leave an edge case</span>
<span id="cb65-172"><a href="#cb65-172" aria-hidden="true" tabindex="-1"></a>with no explicit action to be taken.</span>
<span id="cb65-173"><a href="#cb65-173" aria-hidden="true" tabindex="-1"></a>This is a similar behaviour to switch statements in Rust, which also have to</span>
<span id="cb65-174"><a href="#cb65-174" aria-hidden="true" tabindex="-1"></a>handle all possible cases.</span>
<span id="cb65-175"><a href="#cb65-175" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-176"><a href="#cb65-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-177"><a href="#cb65-177" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-178"><a href="#cb65-178" aria-hidden="true" tabindex="-1"></a><span class="fu">#### The else branch</span></span>
<span id="cb65-179"><a href="#cb65-179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-180"><a href="#cb65-180" aria-hidden="true" tabindex="-1"></a>Take a look at the <span class="in">`dump_hex_fallible()`</span> function below as an example. This function</span>
<span id="cb65-181"><a href="#cb65-181" aria-hidden="true" tabindex="-1"></a>comes from the Zig Standard Library. More precisely, from the</span>
<span id="cb65-182"><a href="#cb65-182" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">`debug.zig` module</span><span class="co">](https://github.com/ziglang/zig/blob/master/lib/std/debug.zig)</span><span class="ot">[^debug-mod]</span>.</span>
<span id="cb65-183"><a href="#cb65-183" aria-hidden="true" tabindex="-1"></a>There are multiple lines in this function, but I omitted them to focus solely on the</span>
<span id="cb65-184"><a href="#cb65-184" aria-hidden="true" tabindex="-1"></a>switch statement found in this function. Notice that this switch statement has four</span>
<span id="cb65-185"><a href="#cb65-185" aria-hidden="true" tabindex="-1"></a>possible cases (i.e., four explicit branches). Also, notice that we used an <span class="in">`else`</span> branch</span>
<span id="cb65-186"><a href="#cb65-186" aria-hidden="true" tabindex="-1"></a>in this case.</span>
<span id="cb65-187"><a href="#cb65-187" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-188"><a href="#cb65-188" aria-hidden="true" tabindex="-1"></a>An <span class="in">`else`</span> branch in a switch statement works as the "default branch".</span>
<span id="cb65-189"><a href="#cb65-189" aria-hidden="true" tabindex="-1"></a>Whenever you have multiple cases in your switch statement where</span>
<span id="cb65-190"><a href="#cb65-190" aria-hidden="true" tabindex="-1"></a>you want to apply the exact same action, you can use an <span class="in">`else`</span> branch to do that.</span>
<span id="cb65-191"><a href="#cb65-191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-192"><a href="#cb65-192" aria-hidden="true" tabindex="-1"></a><span class="ot">[^debug-mod]: &lt;https://github.com/ziglang/zig/blob/master/lib/std/debug.zig&gt;</span></span>
<span id="cb65-193"><a href="#cb65-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-196"><a href="#cb65-196" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-197"><a href="#cb65-197" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb65-198"><a href="#cb65-198" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn dump_hex_fallible(bytes: []const u8) !void {</span></span>
<span id="cb65-199"><a href="#cb65-199" aria-hidden="true" tabindex="-1"></a><span class="in">    // Many lines ...</span></span>
<span id="cb65-200"><a href="#cb65-200" aria-hidden="true" tabindex="-1"></a><span class="in">    switch (byte) {</span></span>
<span id="cb65-201"><a href="#cb65-201" aria-hidden="true" tabindex="-1"></a><span class="in">        '\n' =&gt; try writer.writeAll("␊"),</span></span>
<span id="cb65-202"><a href="#cb65-202" aria-hidden="true" tabindex="-1"></a><span class="in">        '\r' =&gt; try writer.writeAll("␍"),</span></span>
<span id="cb65-203"><a href="#cb65-203" aria-hidden="true" tabindex="-1"></a><span class="in">        '\t' =&gt; try writer.writeAll("␉"),</span></span>
<span id="cb65-204"><a href="#cb65-204" aria-hidden="true" tabindex="-1"></a><span class="in">        else =&gt; try writer.writeByte('.'),</span></span>
<span id="cb65-205"><a href="#cb65-205" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb65-206"><a href="#cb65-206" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb65-207"><a href="#cb65-207" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-208"><a href="#cb65-208" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-209"><a href="#cb65-209" aria-hidden="true" tabindex="-1"></a>Many programmers would also use an <span class="in">`else`</span> branch to handle a "not supported" case.</span>
<span id="cb65-210"><a href="#cb65-210" aria-hidden="true" tabindex="-1"></a>That is, a case that cannot be properly handled by your code, or, just a case that</span>
<span id="cb65-211"><a href="#cb65-211" aria-hidden="true" tabindex="-1"></a>should not be "fixed". Therefore, you can use an <span class="in">`else`</span> branch to panic (or raise an error)</span>
<span id="cb65-212"><a href="#cb65-212" aria-hidden="true" tabindex="-1"></a>in your program to stop the current execution.</span>
<span id="cb65-213"><a href="#cb65-213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-214"><a href="#cb65-214" aria-hidden="true" tabindex="-1"></a>Take the code example below. We can see that, we are handling the cases</span>
<span id="cb65-215"><a href="#cb65-215" aria-hidden="true" tabindex="-1"></a>for the <span class="in">`level`</span> object being either 1, 2, or 3. All other possible cases are not supported by default,</span>
<span id="cb65-216"><a href="#cb65-216" aria-hidden="true" tabindex="-1"></a>and, as consequence, we raise a runtime error in such cases through the <span class="in">`@panic()`</span> built-in function.</span>
<span id="cb65-217"><a href="#cb65-217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-218"><a href="#cb65-218" aria-hidden="true" tabindex="-1"></a>Also notice that, we are assigning the result of the switch statement to a new object called <span class="in">`category`</span>.</span>
<span id="cb65-219"><a href="#cb65-219" aria-hidden="true" tabindex="-1"></a>This is another thing that you can do with switch statements in Zig. If a branch</span>
<span id="cb65-220"><a href="#cb65-220" aria-hidden="true" tabindex="-1"></a>outputs a value as result, you can store the result value of the switch statement into</span>
<span id="cb65-221"><a href="#cb65-221" aria-hidden="true" tabindex="-1"></a>a new object.</span>
<span id="cb65-222"><a href="#cb65-222" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-225"><a href="#cb65-225" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-226"><a href="#cb65-226" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb65-227"><a href="#cb65-227" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "lib"</span></span>
<span id="cb65-228"><a href="#cb65-228" aria-hidden="true" tabindex="-1"></a><span class="in">const level: u8 = 4;</span></span>
<span id="cb65-229"><a href="#cb65-229" aria-hidden="true" tabindex="-1"></a><span class="in">const category = switch (level) {</span></span>
<span id="cb65-230"><a href="#cb65-230" aria-hidden="true" tabindex="-1"></a><span class="in">    1, 2 =&gt; "beginner",</span></span>
<span id="cb65-231"><a href="#cb65-231" aria-hidden="true" tabindex="-1"></a><span class="in">    3 =&gt; "professional",</span></span>
<span id="cb65-232"><a href="#cb65-232" aria-hidden="true" tabindex="-1"></a><span class="in">    else =&gt; {</span></span>
<span id="cb65-233"><a href="#cb65-233" aria-hidden="true" tabindex="-1"></a><span class="in">        @panic("Not supported level!");</span></span>
<span id="cb65-234"><a href="#cb65-234" aria-hidden="true" tabindex="-1"></a><span class="in">    },</span></span>
<span id="cb65-235"><a href="#cb65-235" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb65-236"><a href="#cb65-236" aria-hidden="true" tabindex="-1"></a><span class="in">try stdout.print("{s}\n", .{category});</span></span>
<span id="cb65-237"><a href="#cb65-237" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-238"><a href="#cb65-238" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-239"><a href="#cb65-239" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-240"><a href="#cb65-240" aria-hidden="true" tabindex="-1"></a><span class="in">thread 13103 panic: Not supported level!</span></span>
<span id="cb65-241"><a href="#cb65-241" aria-hidden="true" tabindex="-1"></a><span class="in">t.zig:9:13: 0x1033c58 in main (switch2)</span></span>
<span id="cb65-242"><a href="#cb65-242" aria-hidden="true" tabindex="-1"></a><span class="in">            @panic("Not supported level!");</span></span>
<span id="cb65-243"><a href="#cb65-243" aria-hidden="true" tabindex="-1"></a><span class="in">            ^</span></span>
<span id="cb65-244"><a href="#cb65-244" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-245"><a href="#cb65-245" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-246"><a href="#cb65-246" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-247"><a href="#cb65-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-248"><a href="#cb65-248" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Using ranges in switch</span></span>
<span id="cb65-249"><a href="#cb65-249" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-250"><a href="#cb65-250" aria-hidden="true" tabindex="-1"></a>Furthermore, you can also use ranges of values in switch statements.</span>
<span id="cb65-251"><a href="#cb65-251" aria-hidden="true" tabindex="-1"></a>That is, you can create a branch in your switch statement that is used</span>
<span id="cb65-252"><a href="#cb65-252" aria-hidden="true" tabindex="-1"></a>whenever the input value is within the specified range. These "range expressions"</span>
<span id="cb65-253"><a href="#cb65-253" aria-hidden="true" tabindex="-1"></a>are created with the operator <span class="in">`...`</span>. It's important</span>
<span id="cb65-254"><a href="#cb65-254" aria-hidden="true" tabindex="-1"></a>to emphasize that the ranges created by this operator are</span>
<span id="cb65-255"><a href="#cb65-255" aria-hidden="true" tabindex="-1"></a>inclusive on both ends.</span>
<span id="cb65-256"><a href="#cb65-256" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-257"><a href="#cb65-257" aria-hidden="true" tabindex="-1"></a>For example, I could easily change the previous code example to support all</span>
<span id="cb65-258"><a href="#cb65-258" aria-hidden="true" tabindex="-1"></a>levels between 0 and 100. Like this:</span>
<span id="cb65-259"><a href="#cb65-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-262"><a href="#cb65-262" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-263"><a href="#cb65-263" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb65-264"><a href="#cb65-264" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb65-265"><a href="#cb65-265" aria-hidden="true" tabindex="-1"></a><span class="in">const level: u8 = 4;</span></span>
<span id="cb65-266"><a href="#cb65-266" aria-hidden="true" tabindex="-1"></a><span class="in">const category = switch (level) {</span></span>
<span id="cb65-267"><a href="#cb65-267" aria-hidden="true" tabindex="-1"></a><span class="in">    0...25 =&gt; "beginner",</span></span>
<span id="cb65-268"><a href="#cb65-268" aria-hidden="true" tabindex="-1"></a><span class="in">    26...75 =&gt; "intermediary",</span></span>
<span id="cb65-269"><a href="#cb65-269" aria-hidden="true" tabindex="-1"></a><span class="in">    76...100 =&gt; "professional",</span></span>
<span id="cb65-270"><a href="#cb65-270" aria-hidden="true" tabindex="-1"></a><span class="in">    else =&gt; {</span></span>
<span id="cb65-271"><a href="#cb65-271" aria-hidden="true" tabindex="-1"></a><span class="in">        @panic("Not supported level!");</span></span>
<span id="cb65-272"><a href="#cb65-272" aria-hidden="true" tabindex="-1"></a><span class="in">    },</span></span>
<span id="cb65-273"><a href="#cb65-273" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb65-274"><a href="#cb65-274" aria-hidden="true" tabindex="-1"></a><span class="in">try stdout.print("{s}\n", .{category});</span></span>
<span id="cb65-275"><a href="#cb65-275" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-276"><a href="#cb65-276" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-277"><a href="#cb65-277" aria-hidden="true" tabindex="-1"></a>This is neat, and it works with character ranges too. That is, I could</span>
<span id="cb65-278"><a href="#cb65-278" aria-hidden="true" tabindex="-1"></a>simply write <span class="in">`'a'...'z'`</span>, to match any character value that is a</span>
<span id="cb65-279"><a href="#cb65-279" aria-hidden="true" tabindex="-1"></a>lowercase letter, and it would work fine.</span>
<span id="cb65-280"><a href="#cb65-280" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-281"><a href="#cb65-281" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-282"><a href="#cb65-282" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Labeled switch statements</span></span>
<span id="cb65-283"><a href="#cb65-283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-284"><a href="#cb65-284" aria-hidden="true" tabindex="-1"></a>In @sec-blocks we have talked about labeling blocks, and also, about using these labels</span>
<span id="cb65-285"><a href="#cb65-285" aria-hidden="true" tabindex="-1"></a>to return a value from the block. Well, from version 0.14.0 and onwards of the <span class="in">`zig`</span> compiler,</span>
<span id="cb65-286"><a href="#cb65-286" aria-hidden="true" tabindex="-1"></a>you can also apply labels over switch statements, which makes it possible to almost implement a</span>
<span id="cb65-287"><a href="#cb65-287" aria-hidden="true" tabindex="-1"></a>"C <span class="in">`goto`</span>" like pattern.</span>
<span id="cb65-288"><a href="#cb65-288" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-289"><a href="#cb65-289" aria-hidden="true" tabindex="-1"></a>For example, if you give the label <span class="in">`xsw`</span> to a switch statement, you can use this</span>
<span id="cb65-290"><a href="#cb65-290" aria-hidden="true" tabindex="-1"></a>label in conjunction with the <span class="in">`continue`</span> keyword to go back to the beginning of the switch</span>
<span id="cb65-291"><a href="#cb65-291" aria-hidden="true" tabindex="-1"></a>statement. In the example below, the execution goes back to the beginning of the</span>
<span id="cb65-292"><a href="#cb65-292" aria-hidden="true" tabindex="-1"></a>switch statement two times, before ending at the <span class="in">`3`</span> branch.</span>
<span id="cb65-293"><a href="#cb65-293" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-296"><a href="#cb65-296" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-297"><a href="#cb65-297" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb65-298"><a href="#cb65-298" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "lib"</span></span>
<span id="cb65-299"><a href="#cb65-299" aria-hidden="true" tabindex="-1"></a><span class="in">xsw: switch (@as(u8, 1)) {</span></span>
<span id="cb65-300"><a href="#cb65-300" aria-hidden="true" tabindex="-1"></a><span class="in">    1 =&gt; {</span></span>
<span id="cb65-301"><a href="#cb65-301" aria-hidden="true" tabindex="-1"></a><span class="in">        try stdout.print("First branch\n", .{});</span></span>
<span id="cb65-302"><a href="#cb65-302" aria-hidden="true" tabindex="-1"></a><span class="in">        continue :xsw 2;</span></span>
<span id="cb65-303"><a href="#cb65-303" aria-hidden="true" tabindex="-1"></a><span class="in">    },</span></span>
<span id="cb65-304"><a href="#cb65-304" aria-hidden="true" tabindex="-1"></a><span class="in">    2 =&gt; continue :xsw 3,</span></span>
<span id="cb65-305"><a href="#cb65-305" aria-hidden="true" tabindex="-1"></a><span class="in">    3 =&gt; return,</span></span>
<span id="cb65-306"><a href="#cb65-306" aria-hidden="true" tabindex="-1"></a><span class="in">    4 =&gt; {},</span></span>
<span id="cb65-307"><a href="#cb65-307" aria-hidden="true" tabindex="-1"></a><span class="in">    else =&gt; {</span></span>
<span id="cb65-308"><a href="#cb65-308" aria-hidden="true" tabindex="-1"></a><span class="in">        try stdout.print(</span></span>
<span id="cb65-309"><a href="#cb65-309" aria-hidden="true" tabindex="-1"></a><span class="in">            "Unmatched case, value: {d}\n", .{@as(u8, 1)}</span></span>
<span id="cb65-310"><a href="#cb65-310" aria-hidden="true" tabindex="-1"></a><span class="in">        );</span></span>
<span id="cb65-311"><a href="#cb65-311" aria-hidden="true" tabindex="-1"></a><span class="in">    },</span></span>
<span id="cb65-312"><a href="#cb65-312" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb65-313"><a href="#cb65-313" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-314"><a href="#cb65-314" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-315"><a href="#cb65-315" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-316"><a href="#cb65-316" aria-hidden="true" tabindex="-1"></a><span class="fu">### The `defer` keyword {#sec-defer}</span></span>
<span id="cb65-317"><a href="#cb65-317" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-318"><a href="#cb65-318" aria-hidden="true" tabindex="-1"></a>With the <span class="in">`defer`</span> keyword you can register an expression to be executed when you exit the current scope.</span>
<span id="cb65-319"><a href="#cb65-319" aria-hidden="true" tabindex="-1"></a>Therefore, this keyword has a similar functionality as the <span class="in">`on.exit()`</span> function from R.</span>
<span id="cb65-320"><a href="#cb65-320" aria-hidden="true" tabindex="-1"></a>Take the <span class="in">`foo()`</span> function below as an example. When we execute this <span class="in">`foo()`</span> function, the expression</span>
<span id="cb65-321"><a href="#cb65-321" aria-hidden="true" tabindex="-1"></a>that prints the message "Exiting function ..." is getting executed only when the function exits</span>
<span id="cb65-322"><a href="#cb65-322" aria-hidden="true" tabindex="-1"></a>its scope.</span>
<span id="cb65-323"><a href="#cb65-323" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-324"><a href="#cb65-324" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-327"><a href="#cb65-327" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-328"><a href="#cb65-328" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: false</span></span>
<span id="cb65-329"><a href="#cb65-329" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "lib"</span></span>
<span id="cb65-330"><a href="#cb65-330" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb65-331"><a href="#cb65-331" aria-hidden="true" tabindex="-1"></a><span class="in">const stdout = std.io.getStdOut().writer();</span></span>
<span id="cb65-332"><a href="#cb65-332" aria-hidden="true" tabindex="-1"></a><span class="in">fn foo() !void {</span></span>
<span id="cb65-333"><a href="#cb65-333" aria-hidden="true" tabindex="-1"></a><span class="in">    defer std.debug.print(</span></span>
<span id="cb65-334"><a href="#cb65-334" aria-hidden="true" tabindex="-1"></a><span class="in">        "Exiting function ...\n", .{}</span></span>
<span id="cb65-335"><a href="#cb65-335" aria-hidden="true" tabindex="-1"></a><span class="in">    );</span></span>
<span id="cb65-336"><a href="#cb65-336" aria-hidden="true" tabindex="-1"></a><span class="in">    try stdout.print("Adding some numbers ...\n", .{});</span></span>
<span id="cb65-337"><a href="#cb65-337" aria-hidden="true" tabindex="-1"></a><span class="in">    const x = 2 + 2; _ = x;</span></span>
<span id="cb65-338"><a href="#cb65-338" aria-hidden="true" tabindex="-1"></a><span class="in">    try stdout.print("Multiplying ...\n", .{});</span></span>
<span id="cb65-339"><a href="#cb65-339" aria-hidden="true" tabindex="-1"></a><span class="in">    const y = 2 * 8; _ = y;</span></span>
<span id="cb65-340"><a href="#cb65-340" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb65-341"><a href="#cb65-341" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-342"><a href="#cb65-342" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb65-343"><a href="#cb65-343" aria-hidden="true" tabindex="-1"></a><span class="in">    try foo();</span></span>
<span id="cb65-344"><a href="#cb65-344" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb65-345"><a href="#cb65-345" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-346"><a href="#cb65-346" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-347"><a href="#cb65-347" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-348"><a href="#cb65-348" aria-hidden="true" tabindex="-1"></a><span class="in">Adding some numbers ...</span></span>
<span id="cb65-349"><a href="#cb65-349" aria-hidden="true" tabindex="-1"></a><span class="in">Multiplying ...</span></span>
<span id="cb65-350"><a href="#cb65-350" aria-hidden="true" tabindex="-1"></a><span class="in">Exiting function ...</span></span>
<span id="cb65-351"><a href="#cb65-351" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-352"><a href="#cb65-352" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-353"><a href="#cb65-353" aria-hidden="true" tabindex="-1"></a>Therefore, we can use <span class="in">`defer`</span> to declare an expression that is going to be executed</span>
<span id="cb65-354"><a href="#cb65-354" aria-hidden="true" tabindex="-1"></a>when your code exits the current scope. Some programmers like to interpret the phrase "exit of the current scope"</span>
<span id="cb65-355"><a href="#cb65-355" aria-hidden="true" tabindex="-1"></a>as "the end of the current scope". But this interpretation might not be entirely correct, depending</span>
<span id="cb65-356"><a href="#cb65-356" aria-hidden="true" tabindex="-1"></a>on what you consider as "the end of the current scope".</span>
<span id="cb65-357"><a href="#cb65-357" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-358"><a href="#cb65-358" aria-hidden="true" tabindex="-1"></a>I mean, what do you consider as **the end** of the current scope? Is it the closing curly bracket (<span class="in">`}`</span>) of the scope?</span>
<span id="cb65-359"><a href="#cb65-359" aria-hidden="true" tabindex="-1"></a>Is it when the last expression in the function gets executed? Is it when the function returns to the previous scope?</span>
<span id="cb65-360"><a href="#cb65-360" aria-hidden="true" tabindex="-1"></a>Etc. For example, it would not be correct to interpret the "exit of the current scope" as the closing</span>
<span id="cb65-361"><a href="#cb65-361" aria-hidden="true" tabindex="-1"></a>curly bracket of the scope. Because the function might exit from an earlier position than this</span>
<span id="cb65-362"><a href="#cb65-362" aria-hidden="true" tabindex="-1"></a>closing curly bracket (e.g. an error value was generated at a previous line inside the function;</span>
<span id="cb65-363"><a href="#cb65-363" aria-hidden="true" tabindex="-1"></a>the function reached an earlier return statement; etc.). Anyway, just be careful with this interpretation.</span>
<span id="cb65-364"><a href="#cb65-364" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-365"><a href="#cb65-365" aria-hidden="true" tabindex="-1"></a>Now, if you remember of what we have discussed in @sec-blocks, there are multiple structures in the language</span>
<span id="cb65-366"><a href="#cb65-366" aria-hidden="true" tabindex="-1"></a>that create their own separate scopes. For/while loops, if/else statements,</span>
<span id="cb65-367"><a href="#cb65-367" aria-hidden="true" tabindex="-1"></a>functions, normal blocks, etc. This also affects the interpretation of <span class="in">`defer`</span>.</span>
<span id="cb65-368"><a href="#cb65-368" aria-hidden="true" tabindex="-1"></a>For example, if you use <span class="in">`defer`</span> inside a for loop, then, the given expression</span>
<span id="cb65-369"><a href="#cb65-369" aria-hidden="true" tabindex="-1"></a>will be executed everytime this specific for loop exits its own scope.</span>
<span id="cb65-370"><a href="#cb65-370" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-371"><a href="#cb65-371" aria-hidden="true" tabindex="-1"></a>Before we continue, it's worth emphasizing that the <span class="in">`defer`</span> keyword is an "unconditional defer".</span>
<span id="cb65-372"><a href="#cb65-372" aria-hidden="true" tabindex="-1"></a>Which means that the given expression will be executed no matter how the code exits</span>
<span id="cb65-373"><a href="#cb65-373" aria-hidden="true" tabindex="-1"></a>the current scope. For example, your code might exit the current scope because of an error value</span>
<span id="cb65-374"><a href="#cb65-374" aria-hidden="true" tabindex="-1"></a>being generated, or, because of a return statement, or, a break statement, etc.</span>
<span id="cb65-375"><a href="#cb65-375" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-376"><a href="#cb65-376" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-377"><a href="#cb65-377" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-378"><a href="#cb65-378" aria-hidden="true" tabindex="-1"></a><span class="fu">### The `errdefer` keyword {#sec-errdefer1}</span></span>
<span id="cb65-379"><a href="#cb65-379" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-380"><a href="#cb65-380" aria-hidden="true" tabindex="-1"></a>On the previous section, we have discussed the <span class="in">`defer`</span> keyword, which you can use to</span>
<span id="cb65-381"><a href="#cb65-381" aria-hidden="true" tabindex="-1"></a>register an expression to be executed at the exit of the current scope.</span>
<span id="cb65-382"><a href="#cb65-382" aria-hidden="true" tabindex="-1"></a>But this keyword has a brother, which is the <span class="in">`errdefer`</span> keyword. While <span class="in">`defer`</span></span>
<span id="cb65-383"><a href="#cb65-383" aria-hidden="true" tabindex="-1"></a>is an "unconditional defer", the <span class="in">`errdefer`</span> keyword is a "conditional defer".</span>
<span id="cb65-384"><a href="#cb65-384" aria-hidden="true" tabindex="-1"></a>Which means that the given expression is executed only when you exit the current</span>
<span id="cb65-385"><a href="#cb65-385" aria-hidden="true" tabindex="-1"></a>scope on a very specific circumstance.</span>
<span id="cb65-386"><a href="#cb65-386" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-387"><a href="#cb65-387" aria-hidden="true" tabindex="-1"></a>In more details, the expression given to <span class="in">`errdefer`</span> is executed only when an error occurs in the current scope.</span>
<span id="cb65-388"><a href="#cb65-388" aria-hidden="true" tabindex="-1"></a>Therefore, if the function (or for/while loop, if/else statement, etc.) exits the current scope</span>
<span id="cb65-389"><a href="#cb65-389" aria-hidden="true" tabindex="-1"></a>in a normal situation, without errors, the expression given to <span class="in">`errdefer`</span> is not executed.</span>
<span id="cb65-390"><a href="#cb65-390" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-391"><a href="#cb65-391" aria-hidden="true" tabindex="-1"></a>This makes the <span class="in">`errdefer`</span> keyword one of the many tools available in Zig for error handling.</span>
<span id="cb65-392"><a href="#cb65-392" aria-hidden="true" tabindex="-1"></a>In this section, we are more concerned with the control flow aspects around <span class="in">`errdefer`</span>.</span>
<span id="cb65-393"><a href="#cb65-393" aria-hidden="true" tabindex="-1"></a>But we are going to discuss <span class="in">`errdefer`</span> later as a error handling tool in @sec-errdefer2.</span>
<span id="cb65-394"><a href="#cb65-394" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-395"><a href="#cb65-395" aria-hidden="true" tabindex="-1"></a>The code example below demonstrates three things:</span>
<span id="cb65-396"><a href="#cb65-396" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-397"><a href="#cb65-397" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>that <span class="in">`defer`</span> is an "unconditional defer", because the given expression gets executed regardless of how the function <span class="in">`foo()`</span> exits its own scope.</span>
<span id="cb65-398"><a href="#cb65-398" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>that <span class="in">`errdefer`</span> is executed because the function <span class="in">`foo()`</span> returned an error value.</span>
<span id="cb65-399"><a href="#cb65-399" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>that <span class="in">`defer`</span> and <span class="in">`errdefer`</span> expressions are executed in a LIFO (*last in, first out*) order.</span>
<span id="cb65-400"><a href="#cb65-400" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-403"><a href="#cb65-403" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-404"><a href="#cb65-404" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: false</span></span>
<span id="cb65-405"><a href="#cb65-405" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "lib"</span></span>
<span id="cb65-406"><a href="#cb65-406" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb65-407"><a href="#cb65-407" aria-hidden="true" tabindex="-1"></a><span class="in">fn foo() !void { return error.FooError; }</span></span>
<span id="cb65-408"><a href="#cb65-408" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb65-409"><a href="#cb65-409" aria-hidden="true" tabindex="-1"></a><span class="in">    var i: usize = 1;</span></span>
<span id="cb65-410"><a href="#cb65-410" aria-hidden="true" tabindex="-1"></a><span class="in">    errdefer std.debug.print("Value of i: {d}\n", .{i});</span></span>
<span id="cb65-411"><a href="#cb65-411" aria-hidden="true" tabindex="-1"></a><span class="in">    defer i = 2;</span></span>
<span id="cb65-412"><a href="#cb65-412" aria-hidden="true" tabindex="-1"></a><span class="in">    try foo();</span></span>
<span id="cb65-413"><a href="#cb65-413" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb65-414"><a href="#cb65-414" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-415"><a href="#cb65-415" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-416"><a href="#cb65-416" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-417"><a href="#cb65-417" aria-hidden="true" tabindex="-1"></a><span class="in">Value of i: 2</span></span>
<span id="cb65-418"><a href="#cb65-418" aria-hidden="true" tabindex="-1"></a><span class="in">error: FooError</span></span>
<span id="cb65-419"><a href="#cb65-419" aria-hidden="true" tabindex="-1"></a><span class="in">/t.zig:6:5: 0x1037e48 in foo (defer)</span></span>
<span id="cb65-420"><a href="#cb65-420" aria-hidden="true" tabindex="-1"></a><span class="in">    return error.FooError;</span></span>
<span id="cb65-421"><a href="#cb65-421" aria-hidden="true" tabindex="-1"></a><span class="in">    ^</span></span>
<span id="cb65-422"><a href="#cb65-422" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-423"><a href="#cb65-423" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-424"><a href="#cb65-424" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-425"><a href="#cb65-425" aria-hidden="true" tabindex="-1"></a>When I say that "defer expressions" are executed in a LIFO order, what I want to say is that</span>
<span id="cb65-426"><a href="#cb65-426" aria-hidden="true" tabindex="-1"></a>the last <span class="in">`defer`</span> or <span class="in">`errdefer`</span> expressions in the code are the first ones to be executed.</span>
<span id="cb65-427"><a href="#cb65-427" aria-hidden="true" tabindex="-1"></a>You could also interpret this as: "defer expressions" are executed from bottom to top, or,</span>
<span id="cb65-428"><a href="#cb65-428" aria-hidden="true" tabindex="-1"></a>from last to first.</span>
<span id="cb65-429"><a href="#cb65-429" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-430"><a href="#cb65-430" aria-hidden="true" tabindex="-1"></a>Therefore, if I change the order of the <span class="in">`defer`</span> and <span class="in">`errdefer`</span> expressions, you will notice that</span>
<span id="cb65-431"><a href="#cb65-431" aria-hidden="true" tabindex="-1"></a>the value of <span class="in">`i`</span> that gets printed to the console changes to 1. This doesn't mean that the</span>
<span id="cb65-432"><a href="#cb65-432" aria-hidden="true" tabindex="-1"></a><span class="in">`defer`</span> expression was not executed in this case. This actually means that the <span class="in">`defer`</span> expression</span>
<span id="cb65-433"><a href="#cb65-433" aria-hidden="true" tabindex="-1"></a>was executed only after the <span class="in">`errdefer`</span> expression. The code example below demonstrates this:</span>
<span id="cb65-434"><a href="#cb65-434" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-437"><a href="#cb65-437" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-438"><a href="#cb65-438" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: false</span></span>
<span id="cb65-439"><a href="#cb65-439" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "lib"</span></span>
<span id="cb65-440"><a href="#cb65-440" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb65-441"><a href="#cb65-441" aria-hidden="true" tabindex="-1"></a><span class="in">fn foo() !void { return error.FooError; }</span></span>
<span id="cb65-442"><a href="#cb65-442" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb65-443"><a href="#cb65-443" aria-hidden="true" tabindex="-1"></a><span class="in">    var i: usize = 1;</span></span>
<span id="cb65-444"><a href="#cb65-444" aria-hidden="true" tabindex="-1"></a><span class="in">    defer i = 2;</span></span>
<span id="cb65-445"><a href="#cb65-445" aria-hidden="true" tabindex="-1"></a><span class="in">    errdefer std.debug.print("Value of i: {d}\n", .{i});</span></span>
<span id="cb65-446"><a href="#cb65-446" aria-hidden="true" tabindex="-1"></a><span class="in">    try foo();</span></span>
<span id="cb65-447"><a href="#cb65-447" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb65-448"><a href="#cb65-448" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-449"><a href="#cb65-449" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-450"><a href="#cb65-450" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-451"><a href="#cb65-451" aria-hidden="true" tabindex="-1"></a><span class="in">Value of i: 1</span></span>
<span id="cb65-452"><a href="#cb65-452" aria-hidden="true" tabindex="-1"></a><span class="in">error: FooError</span></span>
<span id="cb65-453"><a href="#cb65-453" aria-hidden="true" tabindex="-1"></a><span class="in">/t.zig:6:5: 0x1037e48 in foo (defer)</span></span>
<span id="cb65-454"><a href="#cb65-454" aria-hidden="true" tabindex="-1"></a><span class="in">    return error.FooError;</span></span>
<span id="cb65-455"><a href="#cb65-455" aria-hidden="true" tabindex="-1"></a><span class="in">    ^</span></span>
<span id="cb65-456"><a href="#cb65-456" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-457"><a href="#cb65-457" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-458"><a href="#cb65-458" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-459"><a href="#cb65-459" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-460"><a href="#cb65-460" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-461"><a href="#cb65-461" aria-hidden="true" tabindex="-1"></a><span class="fu">### For loops</span></span>
<span id="cb65-462"><a href="#cb65-462" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-463"><a href="#cb65-463" aria-hidden="true" tabindex="-1"></a>A loop allows you to execute the same lines of code multiple times,</span>
<span id="cb65-464"><a href="#cb65-464" aria-hidden="true" tabindex="-1"></a>thus, creating a "repetition space" in the execution flow of your program.</span>
<span id="cb65-465"><a href="#cb65-465" aria-hidden="true" tabindex="-1"></a>Loops are particularly useful when we want to replicate the same function</span>
<span id="cb65-466"><a href="#cb65-466" aria-hidden="true" tabindex="-1"></a>(or the same set of commands) over different inputs.</span>
<span id="cb65-467"><a href="#cb65-467" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-468"><a href="#cb65-468" aria-hidden="true" tabindex="-1"></a>There are different types of loops available in Zig. But the most</span>
<span id="cb65-469"><a href="#cb65-469" aria-hidden="true" tabindex="-1"></a>essential of them all is probably the *for loop*. A for loop is</span>
<span id="cb65-470"><a href="#cb65-470" aria-hidden="true" tabindex="-1"></a>used to apply the same piece of code over the elements of a slice, or, an array.</span>
<span id="cb65-471"><a href="#cb65-471" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-472"><a href="#cb65-472" aria-hidden="true" tabindex="-1"></a>For loops in Zig use a syntax that may be unfamiliar to programmers coming from</span>
<span id="cb65-473"><a href="#cb65-473" aria-hidden="true" tabindex="-1"></a>other languages. You start with the <span class="in">`for`</span> keyword, then, you</span>
<span id="cb65-474"><a href="#cb65-474" aria-hidden="true" tabindex="-1"></a>list the items that you want to iterate</span>
<span id="cb65-475"><a href="#cb65-475" aria-hidden="true" tabindex="-1"></a>over inside a pair of parentheses. Then, inside of a pair of pipes (<span class="in">`|`</span>)</span>
<span id="cb65-476"><a href="#cb65-476" aria-hidden="true" tabindex="-1"></a>you should declare an identifier that will serve as your iterator, or,</span>
<span id="cb65-477"><a href="#cb65-477" aria-hidden="true" tabindex="-1"></a>the "repetition index of the loop".</span>
<span id="cb65-478"><a href="#cb65-478" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-481"><a href="#cb65-481" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-482"><a href="#cb65-482" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb65-483"><a href="#cb65-483" aria-hidden="true" tabindex="-1"></a><span class="in">for (items) |value| {</span></span>
<span id="cb65-484"><a href="#cb65-484" aria-hidden="true" tabindex="-1"></a><span class="in">    // code to execute</span></span>
<span id="cb65-485"><a href="#cb65-485" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb65-486"><a href="#cb65-486" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-487"><a href="#cb65-487" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-488"><a href="#cb65-488" aria-hidden="true" tabindex="-1"></a>Therefore, instead of using a <span class="in">`(value in items)`</span> syntax,</span>
<span id="cb65-489"><a href="#cb65-489" aria-hidden="true" tabindex="-1"></a>in Zig, for loops use the syntax <span class="in">`(items) |value|`</span>. In the example</span>
<span id="cb65-490"><a href="#cb65-490" aria-hidden="true" tabindex="-1"></a>below, you can see that we are looping through the items</span>
<span id="cb65-491"><a href="#cb65-491" aria-hidden="true" tabindex="-1"></a>of the array stored at the object <span class="in">`name`</span>, and printing to the</span>
<span id="cb65-492"><a href="#cb65-492" aria-hidden="true" tabindex="-1"></a>console the decimal representation of each character in this array.</span>
<span id="cb65-493"><a href="#cb65-493" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-494"><a href="#cb65-494" aria-hidden="true" tabindex="-1"></a>If we wanted, we could also iterate through a slice (or a portion) of</span>
<span id="cb65-495"><a href="#cb65-495" aria-hidden="true" tabindex="-1"></a>the array, instead of iterating through the entire array stored in the <span class="in">`name`</span> object.</span>
<span id="cb65-496"><a href="#cb65-496" aria-hidden="true" tabindex="-1"></a>Just use a range selector to select the section you want. For example,</span>
<span id="cb65-497"><a href="#cb65-497" aria-hidden="true" tabindex="-1"></a>I could provide the expression <span class="in">`name[0..3]`</span> to the for loop, to iterate</span>
<span id="cb65-498"><a href="#cb65-498" aria-hidden="true" tabindex="-1"></a>just through the first 3 elements in the array.</span>
<span id="cb65-499"><a href="#cb65-499" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-502"><a href="#cb65-502" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-503"><a href="#cb65-503" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb65-504"><a href="#cb65-504" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb65-505"><a href="#cb65-505" aria-hidden="true" tabindex="-1"></a><span class="in">const name = [_]u8{'P','e','d','r','o'};</span></span>
<span id="cb65-506"><a href="#cb65-506" aria-hidden="true" tabindex="-1"></a><span class="in">for (name) |char| {</span></span>
<span id="cb65-507"><a href="#cb65-507" aria-hidden="true" tabindex="-1"></a><span class="in">    try stdout.print("{d} | ", .{char});</span></span>
<span id="cb65-508"><a href="#cb65-508" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb65-509"><a href="#cb65-509" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-510"><a href="#cb65-510" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-511"><a href="#cb65-511" aria-hidden="true" tabindex="-1"></a>In the above example we are using the value itself of each</span>
<span id="cb65-512"><a href="#cb65-512" aria-hidden="true" tabindex="-1"></a>element in the array as our iterator. But there are many situations where</span>
<span id="cb65-513"><a href="#cb65-513" aria-hidden="true" tabindex="-1"></a>we need to use an index instead of the actual values of the items.</span>
<span id="cb65-514"><a href="#cb65-514" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-515"><a href="#cb65-515" aria-hidden="true" tabindex="-1"></a>You can do that by providing a second set of items to iterate over.</span>
<span id="cb65-516"><a href="#cb65-516" aria-hidden="true" tabindex="-1"></a>More precisely, you provide the range selector <span class="in">`0..`</span> to the for loop. So,</span>
<span id="cb65-517"><a href="#cb65-517" aria-hidden="true" tabindex="-1"></a>yes, you can use two different iterators at the same time in a for</span>
<span id="cb65-518"><a href="#cb65-518" aria-hidden="true" tabindex="-1"></a>loop in Zig.</span>
<span id="cb65-519"><a href="#cb65-519" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-520"><a href="#cb65-520" aria-hidden="true" tabindex="-1"></a>But remember from @sec-assignments that, every object</span>
<span id="cb65-521"><a href="#cb65-521" aria-hidden="true" tabindex="-1"></a>you create in Zig must be used in some way. So if you declare two iterators</span>
<span id="cb65-522"><a href="#cb65-522" aria-hidden="true" tabindex="-1"></a>in your for loop, you must use both iterators inside the for loop body.</span>
<span id="cb65-523"><a href="#cb65-523" aria-hidden="true" tabindex="-1"></a>But if you want to use just the index iterator, and not use the "value iterator",</span>
<span id="cb65-524"><a href="#cb65-524" aria-hidden="true" tabindex="-1"></a>then, you can discard the value iterator by maching the</span>
<span id="cb65-525"><a href="#cb65-525" aria-hidden="true" tabindex="-1"></a>value items to the underscore character, like in the example below:</span>
<span id="cb65-526"><a href="#cb65-526" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-527"><a href="#cb65-527" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-530"><a href="#cb65-530" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-531"><a href="#cb65-531" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb65-532"><a href="#cb65-532" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "ast"</span></span>
<span id="cb65-533"><a href="#cb65-533" aria-hidden="true" tabindex="-1"></a><span class="in">const name = "Pedro";</span></span>
<span id="cb65-534"><a href="#cb65-534" aria-hidden="true" tabindex="-1"></a><span class="in">for (name, 0..) |_, i| {</span></span>
<span id="cb65-535"><a href="#cb65-535" aria-hidden="true" tabindex="-1"></a><span class="in">    try stdout.print("{d} | ", .{i});</span></span>
<span id="cb65-536"><a href="#cb65-536" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb65-537"><a href="#cb65-537" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-538"><a href="#cb65-538" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-539"><a href="#cb65-539" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-540"><a href="#cb65-540" aria-hidden="true" tabindex="-1"></a><span class="in">0 | 1 | 2 | 3 | 4 |</span></span>
<span id="cb65-541"><a href="#cb65-541" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-542"><a href="#cb65-542" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-543"><a href="#cb65-543" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-544"><a href="#cb65-544" aria-hidden="true" tabindex="-1"></a><span class="fu">### While loops</span></span>
<span id="cb65-545"><a href="#cb65-545" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-546"><a href="#cb65-546" aria-hidden="true" tabindex="-1"></a>A while loop is created from the <span class="in">`while`</span> keyword. A <span class="in">`for`</span> loop</span>
<span id="cb65-547"><a href="#cb65-547" aria-hidden="true" tabindex="-1"></a>iterates through the items of an array, but a <span class="in">`while`</span> loop</span>
<span id="cb65-548"><a href="#cb65-548" aria-hidden="true" tabindex="-1"></a>will loop continuously, and infinitely, until a logical test</span>
<span id="cb65-549"><a href="#cb65-549" aria-hidden="true" tabindex="-1"></a>(specified by you) becomes false.</span>
<span id="cb65-550"><a href="#cb65-550" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-551"><a href="#cb65-551" aria-hidden="true" tabindex="-1"></a>You start with the <span class="in">`while`</span> keyword, then, you define a logical</span>
<span id="cb65-552"><a href="#cb65-552" aria-hidden="true" tabindex="-1"></a>expression inside a pair of parentheses, and the body of the</span>
<span id="cb65-553"><a href="#cb65-553" aria-hidden="true" tabindex="-1"></a>loop is provided inside a pair of curly braces, like in the example below:</span>
<span id="cb65-554"><a href="#cb65-554" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-557"><a href="#cb65-557" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-558"><a href="#cb65-558" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb65-559"><a href="#cb65-559" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb65-560"><a href="#cb65-560" aria-hidden="true" tabindex="-1"></a><span class="in">var i: u8 = 1;</span></span>
<span id="cb65-561"><a href="#cb65-561" aria-hidden="true" tabindex="-1"></a><span class="in">while (i &lt; 5) {</span></span>
<span id="cb65-562"><a href="#cb65-562" aria-hidden="true" tabindex="-1"></a><span class="in">    try stdout.print("{d} | ", .{i});</span></span>
<span id="cb65-563"><a href="#cb65-563" aria-hidden="true" tabindex="-1"></a><span class="in">    i += 1;</span></span>
<span id="cb65-564"><a href="#cb65-564" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb65-565"><a href="#cb65-565" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-566"><a href="#cb65-566" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-567"><a href="#cb65-567" aria-hidden="true" tabindex="-1"></a>You can also specify the increment expression to be used at the beginning of a while loop.</span>
<span id="cb65-568"><a href="#cb65-568" aria-hidden="true" tabindex="-1"></a>To do that, we write the increment expression inside a pair of parentheses after a colon character (<span class="in">`:`</span>).</span>
<span id="cb65-569"><a href="#cb65-569" aria-hidden="true" tabindex="-1"></a>The code example below demonstrates this other pattern.</span>
<span id="cb65-570"><a href="#cb65-570" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-573"><a href="#cb65-573" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-574"><a href="#cb65-574" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb65-575"><a href="#cb65-575" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb65-576"><a href="#cb65-576" aria-hidden="true" tabindex="-1"></a><span class="in">var i: u8 = 1;</span></span>
<span id="cb65-577"><a href="#cb65-577" aria-hidden="true" tabindex="-1"></a><span class="in">while (i &lt; 5) : (i += 1) {</span></span>
<span id="cb65-578"><a href="#cb65-578" aria-hidden="true" tabindex="-1"></a><span class="in">    try stdout.print("{d} | ", .{i});</span></span>
<span id="cb65-579"><a href="#cb65-579" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb65-580"><a href="#cb65-580" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-581"><a href="#cb65-581" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-582"><a href="#cb65-582" aria-hidden="true" tabindex="-1"></a><span class="fu">### Using `break` and `continue`</span></span>
<span id="cb65-583"><a href="#cb65-583" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-584"><a href="#cb65-584" aria-hidden="true" tabindex="-1"></a>In Zig, you can explicitly stop the execution of a loop, or, jump to the next iteration of the loop, by using</span>
<span id="cb65-585"><a href="#cb65-585" aria-hidden="true" tabindex="-1"></a>the keywords <span class="in">`break`</span> and <span class="in">`continue`</span>, respectively. The <span class="in">`while`</span> loop presented in the next code example is,</span>
<span id="cb65-586"><a href="#cb65-586" aria-hidden="true" tabindex="-1"></a>at first sight, an infinite loop. Because the logical value inside the parenthese will always be equal to <span class="in">`true`</span>.</span>
<span id="cb65-587"><a href="#cb65-587" aria-hidden="true" tabindex="-1"></a>But what makes this <span class="in">`while`</span> loop stop when the <span class="in">`i`</span> object reaches the count</span>
<span id="cb65-588"><a href="#cb65-588" aria-hidden="true" tabindex="-1"></a>10? It's the <span class="in">`break`</span> keyword!</span>
<span id="cb65-589"><a href="#cb65-589" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-590"><a href="#cb65-590" aria-hidden="true" tabindex="-1"></a>Inside the while loop, we have an if statement that is constantly checking if the <span class="in">`i`</span> variable</span>
<span id="cb65-591"><a href="#cb65-591" aria-hidden="true" tabindex="-1"></a>is equal to 10. Since we are incrementing the value of <span class="in">`i`</span> at each iteration of the</span>
<span id="cb65-592"><a href="#cb65-592" aria-hidden="true" tabindex="-1"></a>while loop, this <span class="in">`i`</span> object will eventually be equal to 10, and when it is, the if statement</span>
<span id="cb65-593"><a href="#cb65-593" aria-hidden="true" tabindex="-1"></a>will execute the <span class="in">`break`</span> expression, and, as a result, the execution of the while loop is stopped.</span>
<span id="cb65-594"><a href="#cb65-594" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-595"><a href="#cb65-595" aria-hidden="true" tabindex="-1"></a>Notice the use of the <span class="in">`expect()`</span> function from the Zig Standard Library after the while loop.</span>
<span id="cb65-596"><a href="#cb65-596" aria-hidden="true" tabindex="-1"></a>This <span class="in">`expect()`</span> function is an "assert" type of function.</span>
<span id="cb65-597"><a href="#cb65-597" aria-hidden="true" tabindex="-1"></a>This function checks if the logical test provided is equal to true. If so, the function do nothing.</span>
<span id="cb65-598"><a href="#cb65-598" aria-hidden="true" tabindex="-1"></a>Otherwise (i.e., the logical test is equal to false), the function raises an assertion error.</span>
<span id="cb65-599"><a href="#cb65-599" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-602"><a href="#cb65-602" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-603"><a href="#cb65-603" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb65-604"><a href="#cb65-604" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb65-605"><a href="#cb65-605" aria-hidden="true" tabindex="-1"></a><span class="in">var i: usize = 0;</span></span>
<span id="cb65-606"><a href="#cb65-606" aria-hidden="true" tabindex="-1"></a><span class="in">while (true) {</span></span>
<span id="cb65-607"><a href="#cb65-607" aria-hidden="true" tabindex="-1"></a><span class="in">    if (i == 10) {</span></span>
<span id="cb65-608"><a href="#cb65-608" aria-hidden="true" tabindex="-1"></a><span class="in">        break;</span></span>
<span id="cb65-609"><a href="#cb65-609" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb65-610"><a href="#cb65-610" aria-hidden="true" tabindex="-1"></a><span class="in">    i += 1;</span></span>
<span id="cb65-611"><a href="#cb65-611" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb65-612"><a href="#cb65-612" aria-hidden="true" tabindex="-1"></a><span class="in">try std.testing.expect(i == 10);</span></span>
<span id="cb65-613"><a href="#cb65-613" aria-hidden="true" tabindex="-1"></a><span class="in">try stdout.print("Everything worked!", .{});</span></span>
<span id="cb65-614"><a href="#cb65-614" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-615"><a href="#cb65-615" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-616"><a href="#cb65-616" aria-hidden="true" tabindex="-1"></a>Since this code example was executed successfully by the <span class="in">`zig`</span> compiler,</span>
<span id="cb65-617"><a href="#cb65-617" aria-hidden="true" tabindex="-1"></a>without raising any errors, we known that, after the execution of the while loop,</span>
<span id="cb65-618"><a href="#cb65-618" aria-hidden="true" tabindex="-1"></a>the <span class="in">`i`</span> object is equal to 10. Because if it wasn't equal to 10, an error would have</span>
<span id="cb65-619"><a href="#cb65-619" aria-hidden="true" tabindex="-1"></a>been raised by <span class="in">`expect()`</span>.</span>
<span id="cb65-620"><a href="#cb65-620" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-621"><a href="#cb65-621" aria-hidden="true" tabindex="-1"></a>Now, in the next example, we have a use case for</span>
<span id="cb65-622"><a href="#cb65-622" aria-hidden="true" tabindex="-1"></a>the <span class="in">`continue`</span> keyword. The if statement is constantly</span>
<span id="cb65-623"><a href="#cb65-623" aria-hidden="true" tabindex="-1"></a>checking if the current index is a multiple of 2. If</span>
<span id="cb65-624"><a href="#cb65-624" aria-hidden="true" tabindex="-1"></a>it is, we jump to the next iteration of the loop.</span>
<span id="cb65-625"><a href="#cb65-625" aria-hidden="true" tabindex="-1"></a>Otherwise, the loop just prints the current index to the console.</span>
<span id="cb65-626"><a href="#cb65-626" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-629"><a href="#cb65-629" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-630"><a href="#cb65-630" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb65-631"><a href="#cb65-631" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb65-632"><a href="#cb65-632" aria-hidden="true" tabindex="-1"></a><span class="in">const ns = [_]u8{1,2,3,4,5,6};</span></span>
<span id="cb65-633"><a href="#cb65-633" aria-hidden="true" tabindex="-1"></a><span class="in">for (ns) |i| {</span></span>
<span id="cb65-634"><a href="#cb65-634" aria-hidden="true" tabindex="-1"></a><span class="in">    if ((i % 2) == 0) {</span></span>
<span id="cb65-635"><a href="#cb65-635" aria-hidden="true" tabindex="-1"></a><span class="in">        continue;</span></span>
<span id="cb65-636"><a href="#cb65-636" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb65-637"><a href="#cb65-637" aria-hidden="true" tabindex="-1"></a><span class="in">    try stdout.print("{d} | ", .{i});</span></span>
<span id="cb65-638"><a href="#cb65-638" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb65-639"><a href="#cb65-639" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-640"><a href="#cb65-640" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-641"><a href="#cb65-641" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-642"><a href="#cb65-642" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-643"><a href="#cb65-643" aria-hidden="true" tabindex="-1"></a><span class="fu">## Function parameters are immutable {#sec-fun-pars}</span></span>
<span id="cb65-644"><a href="#cb65-644" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-645"><a href="#cb65-645" aria-hidden="true" tabindex="-1"></a>We have already discussed a lot of the syntax behind function declarations in @sec-root-file and @sec-main-file.</span>
<span id="cb65-646"><a href="#cb65-646" aria-hidden="true" tabindex="-1"></a>But I want to emphasize a curious fact about function parameters (a.k.a. function arguments) in Zig.</span>
<span id="cb65-647"><a href="#cb65-647" aria-hidden="true" tabindex="-1"></a>In summary, function parameters are immutable in Zig.</span>
<span id="cb65-648"><a href="#cb65-648" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-649"><a href="#cb65-649" aria-hidden="true" tabindex="-1"></a>Take the code example below, where we declare a simple function that just tries to add</span>
<span id="cb65-650"><a href="#cb65-650" aria-hidden="true" tabindex="-1"></a>some amount to the input integer, and returns the result back. If you look closely</span>
<span id="cb65-651"><a href="#cb65-651" aria-hidden="true" tabindex="-1"></a>at the body of this <span class="in">`add2()`</span> function, you will notice that we try</span>
<span id="cb65-652"><a href="#cb65-652" aria-hidden="true" tabindex="-1"></a>to save the result back into the <span class="in">`x`</span> function argument.</span>
<span id="cb65-653"><a href="#cb65-653" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-654"><a href="#cb65-654" aria-hidden="true" tabindex="-1"></a>In other words, this function not only uses the value that it received through the function argument</span>
<span id="cb65-655"><a href="#cb65-655" aria-hidden="true" tabindex="-1"></a><span class="in">`x`</span>, but it also tries to change the value of this function argument, by assigning the addition result</span>
<span id="cb65-656"><a href="#cb65-656" aria-hidden="true" tabindex="-1"></a>into <span class="in">`x`</span>. However, function arguments in Zig are immutable. You cannot change their values, or, you</span>
<span id="cb65-657"><a href="#cb65-657" aria-hidden="true" tabindex="-1"></a>cannot assign values to them inside the body's function.</span>
<span id="cb65-658"><a href="#cb65-658" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-659"><a href="#cb65-659" aria-hidden="true" tabindex="-1"></a>This is the reason why, the code example below does not compile successfully. If you try to compile</span>
<span id="cb65-660"><a href="#cb65-660" aria-hidden="true" tabindex="-1"></a>this code example, you will get a compile error message about "trying to change the value of a</span>
<span id="cb65-661"><a href="#cb65-661" aria-hidden="true" tabindex="-1"></a>immutable (i.e., constant) object".</span>
<span id="cb65-662"><a href="#cb65-662" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-665"><a href="#cb65-665" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-666"><a href="#cb65-666" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb65-667"><a href="#cb65-667" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: false</span></span>
<span id="cb65-668"><a href="#cb65-668" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "lib"</span></span>
<span id="cb65-669"><a href="#cb65-669" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb65-670"><a href="#cb65-670" aria-hidden="true" tabindex="-1"></a><span class="in">fn add2(x: u32) u32 {</span></span>
<span id="cb65-671"><a href="#cb65-671" aria-hidden="true" tabindex="-1"></a><span class="in">    x = x + 2;</span></span>
<span id="cb65-672"><a href="#cb65-672" aria-hidden="true" tabindex="-1"></a><span class="in">    return x;</span></span>
<span id="cb65-673"><a href="#cb65-673" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb65-674"><a href="#cb65-674" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-675"><a href="#cb65-675" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb65-676"><a href="#cb65-676" aria-hidden="true" tabindex="-1"></a><span class="in">    const y = add2(4);</span></span>
<span id="cb65-677"><a href="#cb65-677" aria-hidden="true" tabindex="-1"></a><span class="in">    std.debug.print("{d}\n", .{y});</span></span>
<span id="cb65-678"><a href="#cb65-678" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb65-679"><a href="#cb65-679" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-680"><a href="#cb65-680" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-681"><a href="#cb65-681" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-682"><a href="#cb65-682" aria-hidden="true" tabindex="-1"></a><span class="in">t.zig:3:5: error: cannot assign to constant</span></span>
<span id="cb65-683"><a href="#cb65-683" aria-hidden="true" tabindex="-1"></a><span class="in">    x = x + 2;</span></span>
<span id="cb65-684"><a href="#cb65-684" aria-hidden="true" tabindex="-1"></a><span class="in">    ^</span></span>
<span id="cb65-685"><a href="#cb65-685" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-686"><a href="#cb65-686" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-687"><a href="#cb65-687" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-688"><a href="#cb65-688" aria-hidden="true" tabindex="-1"></a><span class="fu">### A free optimization</span></span>
<span id="cb65-689"><a href="#cb65-689" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-690"><a href="#cb65-690" aria-hidden="true" tabindex="-1"></a>If a function argument receives as input an object whose data type is</span>
<span id="cb65-691"><a href="#cb65-691" aria-hidden="true" tabindex="-1"></a>any of the primitive types that we have listed in @sec-primitive-data-types,</span>
<span id="cb65-692"><a href="#cb65-692" aria-hidden="true" tabindex="-1"></a>this object is always passed by value to the function. In other words, this object</span>
<span id="cb65-693"><a href="#cb65-693" aria-hidden="true" tabindex="-1"></a>is copied into the function stack frame.</span>
<span id="cb65-694"><a href="#cb65-694" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-695"><a href="#cb65-695" aria-hidden="true" tabindex="-1"></a>However, if the input object have a more complex data type, for example, it might</span>
<span id="cb65-696"><a href="#cb65-696" aria-hidden="true" tabindex="-1"></a>be a struct instance, or an array, or an union value, etc., in cases like that, the <span class="in">`zig`</span> compiler</span>
<span id="cb65-697"><a href="#cb65-697" aria-hidden="true" tabindex="-1"></a>will take the liberty of deciding for you which strategy is best. Thus, the <span class="in">`zig`</span> compiler will</span>
<span id="cb65-698"><a href="#cb65-698" aria-hidden="true" tabindex="-1"></a>pass your object to the function either by value, or by reference. The compiler will always</span>
<span id="cb65-699"><a href="#cb65-699" aria-hidden="true" tabindex="-1"></a>choose the strategy that is faster for you.</span>
<span id="cb65-700"><a href="#cb65-700" aria-hidden="true" tabindex="-1"></a>This optimization that you get for free is possible only because function arguments are</span>
<span id="cb65-701"><a href="#cb65-701" aria-hidden="true" tabindex="-1"></a>immutable in Zig.</span>
<span id="cb65-702"><a href="#cb65-702" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-703"><a href="#cb65-703" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-704"><a href="#cb65-704" aria-hidden="true" tabindex="-1"></a><span class="fu">### How to overcome this barrier</span></span>
<span id="cb65-705"><a href="#cb65-705" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-706"><a href="#cb65-706" aria-hidden="true" tabindex="-1"></a>There are some situations where you might need to change the value of your function argument</span>
<span id="cb65-707"><a href="#cb65-707" aria-hidden="true" tabindex="-1"></a>directly inside the function's body. This happens more often when we are passing</span>
<span id="cb65-708"><a href="#cb65-708" aria-hidden="true" tabindex="-1"></a>C structs as inputs to Zig functions.</span>
<span id="cb65-709"><a href="#cb65-709" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-710"><a href="#cb65-710" aria-hidden="true" tabindex="-1"></a>In a situation like this, you can overcome this barrier by using a pointer. In other words,</span>
<span id="cb65-711"><a href="#cb65-711" aria-hidden="true" tabindex="-1"></a>instead of passing a value as input to the argument, you can pass a "pointer to value" instead.</span>
<span id="cb65-712"><a href="#cb65-712" aria-hidden="true" tabindex="-1"></a>You can change the value that the pointer points to, by dereferencing it.</span>
<span id="cb65-713"><a href="#cb65-713" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-714"><a href="#cb65-714" aria-hidden="true" tabindex="-1"></a>Therefore, if we take our previous <span class="in">`add2()`</span> example, we can change the value of the</span>
<span id="cb65-715"><a href="#cb65-715" aria-hidden="true" tabindex="-1"></a>function argument <span class="in">`x`</span> inside the function's body by marking the <span class="in">`x`</span> argument as a</span>
<span id="cb65-716"><a href="#cb65-716" aria-hidden="true" tabindex="-1"></a>"pointer to a <span class="in">`u32`</span> value" (i.e., <span class="in">`*u32`</span> data type), instead of a <span class="in">`u32`</span> value.</span>
<span id="cb65-717"><a href="#cb65-717" aria-hidden="true" tabindex="-1"></a>By making it a pointer, we can finally alter the value of this function argument directly inside</span>
<span id="cb65-718"><a href="#cb65-718" aria-hidden="true" tabindex="-1"></a>the body of the <span class="in">`add2()`</span> function. You can see that the code example below compiles successfully.</span>
<span id="cb65-719"><a href="#cb65-719" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-722"><a href="#cb65-722" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-723"><a href="#cb65-723" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "lib"</span></span>
<span id="cb65-724"><a href="#cb65-724" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: false</span></span>
<span id="cb65-725"><a href="#cb65-725" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb65-726"><a href="#cb65-726" aria-hidden="true" tabindex="-1"></a><span class="in">fn add2(x: *u32) void {</span></span>
<span id="cb65-727"><a href="#cb65-727" aria-hidden="true" tabindex="-1"></a><span class="in">    const d: u32 = 2;</span></span>
<span id="cb65-728"><a href="#cb65-728" aria-hidden="true" tabindex="-1"></a><span class="in">    x.* = x.* + d;</span></span>
<span id="cb65-729"><a href="#cb65-729" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb65-730"><a href="#cb65-730" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-731"><a href="#cb65-731" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb65-732"><a href="#cb65-732" aria-hidden="true" tabindex="-1"></a><span class="in">    var x: u32 = 4;</span></span>
<span id="cb65-733"><a href="#cb65-733" aria-hidden="true" tabindex="-1"></a><span class="in">    add2(&amp;x);</span></span>
<span id="cb65-734"><a href="#cb65-734" aria-hidden="true" tabindex="-1"></a><span class="in">    std.debug.print("Result: {d}\n", .{x});</span></span>
<span id="cb65-735"><a href="#cb65-735" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb65-736"><a href="#cb65-736" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-737"><a href="#cb65-737" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-738"><a href="#cb65-738" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-739"><a href="#cb65-739" aria-hidden="true" tabindex="-1"></a><span class="in">Result: 6</span></span>
<span id="cb65-740"><a href="#cb65-740" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-741"><a href="#cb65-741" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-742"><a href="#cb65-742" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-743"><a href="#cb65-743" aria-hidden="true" tabindex="-1"></a>Even in this code example above, the <span class="in">`x`</span> argument is still immutable. Which means that the pointer itself is immutable.</span>
<span id="cb65-744"><a href="#cb65-744" aria-hidden="true" tabindex="-1"></a>Therefore, you cannot change the memory address that it points to. However, you can dereference the pointer</span>
<span id="cb65-745"><a href="#cb65-745" aria-hidden="true" tabindex="-1"></a>to access the value that it points to, and also, to change this value, if you need to.</span>
<span id="cb65-746"><a href="#cb65-746" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-747"><a href="#cb65-747" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-748"><a href="#cb65-748" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-749"><a href="#cb65-749" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-750"><a href="#cb65-750" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-751"><a href="#cb65-751" aria-hidden="true" tabindex="-1"></a><span class="fu">## Structs and OOP {#sec-structs-and-oop}</span></span>
<span id="cb65-752"><a href="#cb65-752" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-753"><a href="#cb65-753" aria-hidden="true" tabindex="-1"></a>Zig is a language more closely related to C (which is a procedural language),</span>
<span id="cb65-754"><a href="#cb65-754" aria-hidden="true" tabindex="-1"></a>than it is to C++ or Java (which are object-oriented languages). Because of that, you do not</span>
<span id="cb65-755"><a href="#cb65-755" aria-hidden="true" tabindex="-1"></a>have advanced OOP (Object-Oriented Programming) patterns available in Zig, such as classes, interfaces or</span>
<span id="cb65-756"><a href="#cb65-756" aria-hidden="true" tabindex="-1"></a>class inheritance. Nonetheless, OOP in Zig is still possible by using struct definitions.</span>
<span id="cb65-757"><a href="#cb65-757" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-758"><a href="#cb65-758" aria-hidden="true" tabindex="-1"></a>With struct definitions, you can create (or define) a new data type in Zig. These struct definitions work the same way as they work in C.</span>
<span id="cb65-759"><a href="#cb65-759" aria-hidden="true" tabindex="-1"></a>You give a name to this new struct (or, to this new data type you are creating), then, you list the data members of this new struct. You can</span>
<span id="cb65-760"><a href="#cb65-760" aria-hidden="true" tabindex="-1"></a>also register functions inside this struct, and they become the methods of this particular struct (or data type), so that, every object</span>
<span id="cb65-761"><a href="#cb65-761" aria-hidden="true" tabindex="-1"></a>that you create with this new type, will always have these methods available and associated with them.</span>
<span id="cb65-762"><a href="#cb65-762" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-763"><a href="#cb65-763" aria-hidden="true" tabindex="-1"></a>In C++, when we create a new class, we normally have a constructor method (or, a constructor function) which</span>
<span id="cb65-764"><a href="#cb65-764" aria-hidden="true" tabindex="-1"></a>is used to construct (or, to instantiate) every object of this particular class, and we also have</span>
<span id="cb65-765"><a href="#cb65-765" aria-hidden="true" tabindex="-1"></a>a destructor method (or a destructor function), which is the function responsible for destroying</span>
<span id="cb65-766"><a href="#cb65-766" aria-hidden="true" tabindex="-1"></a>every object of this class.</span>
<span id="cb65-767"><a href="#cb65-767" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-768"><a href="#cb65-768" aria-hidden="true" tabindex="-1"></a>In Zig, we normally declare the constructor and the destructor methods</span>
<span id="cb65-769"><a href="#cb65-769" aria-hidden="true" tabindex="-1"></a>of our structs, by declaring an <span class="in">`init()`</span> and a <span class="in">`deinit()`</span> methods inside the struct.</span>
<span id="cb65-770"><a href="#cb65-770" aria-hidden="true" tabindex="-1"></a>This is just a naming convention that you will find across the entire Zig Standard Library.</span>
<span id="cb65-771"><a href="#cb65-771" aria-hidden="true" tabindex="-1"></a>So, in Zig, the <span class="in">`init()`</span> method of a struct is normally the constructor method of the class represented by this struct.</span>
<span id="cb65-772"><a href="#cb65-772" aria-hidden="true" tabindex="-1"></a>While the <span class="in">`deinit()`</span> method is the method used for destroying an existing instance of that struct.</span>
<span id="cb65-773"><a href="#cb65-773" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-774"><a href="#cb65-774" aria-hidden="true" tabindex="-1"></a>The <span class="in">`init()`</span> and <span class="in">`deinit()`</span> methods are both used extensively in Zig code, and you will see both of</span>
<span id="cb65-775"><a href="#cb65-775" aria-hidden="true" tabindex="-1"></a>them being used when we talk about allocators in @sec-allocators.</span>
<span id="cb65-776"><a href="#cb65-776" aria-hidden="true" tabindex="-1"></a>But, as another example, let's build a simple <span class="in">`User`</span> struct to represent a user of some sort of system.</span>
<span id="cb65-777"><a href="#cb65-777" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-778"><a href="#cb65-778" aria-hidden="true" tabindex="-1"></a>If you look at the <span class="in">`User`</span> struct below, you can see the <span class="in">`struct`</span> keyword.</span>
<span id="cb65-779"><a href="#cb65-779" aria-hidden="true" tabindex="-1"></a>Notice the data members of this struct: <span class="in">`id`</span>, <span class="in">`name`</span> and <span class="in">`email`</span>. Every data member has its</span>
<span id="cb65-780"><a href="#cb65-780" aria-hidden="true" tabindex="-1"></a>type explicitly annotated, with the colon character (<span class="in">`:`</span>) syntax that we described earlier in @sec-root-file.</span>
<span id="cb65-781"><a href="#cb65-781" aria-hidden="true" tabindex="-1"></a>But also notice that every line in the struct body that describes a data member, ends with a comma character (<span class="in">`,`</span>).</span>
<span id="cb65-782"><a href="#cb65-782" aria-hidden="true" tabindex="-1"></a>So every time you declare a data member in your Zig code, always end the line with a comma character, instead</span>
<span id="cb65-783"><a href="#cb65-783" aria-hidden="true" tabindex="-1"></a>of ending it with the traditional semicolon character (<span class="in">`;`</span>).</span>
<span id="cb65-784"><a href="#cb65-784" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-785"><a href="#cb65-785" aria-hidden="true" tabindex="-1"></a>Next, we have registered an <span class="in">`init()`</span> function as a method</span>
<span id="cb65-786"><a href="#cb65-786" aria-hidden="true" tabindex="-1"></a>of this <span class="in">`User`</span> struct. This <span class="in">`init()`</span> method is the constructor method that we will use to instantiate</span>
<span id="cb65-787"><a href="#cb65-787" aria-hidden="true" tabindex="-1"></a>every new <span class="in">`User`</span> object. That is why this <span class="in">`init()`</span> function returns a new <span class="in">`User`</span> object as result.</span>
<span id="cb65-788"><a href="#cb65-788" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-789"><a href="#cb65-789" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-792"><a href="#cb65-792" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-793"><a href="#cb65-793" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: false</span></span>
<span id="cb65-794"><a href="#cb65-794" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb65-795"><a href="#cb65-795" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb65-796"><a href="#cb65-796" aria-hidden="true" tabindex="-1"></a><span class="in">const stdout = std.io.getStdOut().writer();</span></span>
<span id="cb65-797"><a href="#cb65-797" aria-hidden="true" tabindex="-1"></a><span class="in">const User = struct {</span></span>
<span id="cb65-798"><a href="#cb65-798" aria-hidden="true" tabindex="-1"></a><span class="in">    id: u64,</span></span>
<span id="cb65-799"><a href="#cb65-799" aria-hidden="true" tabindex="-1"></a><span class="in">    name: []const u8,</span></span>
<span id="cb65-800"><a href="#cb65-800" aria-hidden="true" tabindex="-1"></a><span class="in">    email: []const u8,</span></span>
<span id="cb65-801"><a href="#cb65-801" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-802"><a href="#cb65-802" aria-hidden="true" tabindex="-1"></a><span class="in">    fn init(id: u64,</span></span>
<span id="cb65-803"><a href="#cb65-803" aria-hidden="true" tabindex="-1"></a><span class="in">            name: []const u8,</span></span>
<span id="cb65-804"><a href="#cb65-804" aria-hidden="true" tabindex="-1"></a><span class="in">            email: []const u8) User {</span></span>
<span id="cb65-805"><a href="#cb65-805" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-806"><a href="#cb65-806" aria-hidden="true" tabindex="-1"></a><span class="in">        return User {</span></span>
<span id="cb65-807"><a href="#cb65-807" aria-hidden="true" tabindex="-1"></a><span class="in">            .id = id,</span></span>
<span id="cb65-808"><a href="#cb65-808" aria-hidden="true" tabindex="-1"></a><span class="in">            .name = name,</span></span>
<span id="cb65-809"><a href="#cb65-809" aria-hidden="true" tabindex="-1"></a><span class="in">            .email = email</span></span>
<span id="cb65-810"><a href="#cb65-810" aria-hidden="true" tabindex="-1"></a><span class="in">        };</span></span>
<span id="cb65-811"><a href="#cb65-811" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb65-812"><a href="#cb65-812" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-813"><a href="#cb65-813" aria-hidden="true" tabindex="-1"></a><span class="in">    fn print_name(self: User) !void {</span></span>
<span id="cb65-814"><a href="#cb65-814" aria-hidden="true" tabindex="-1"></a><span class="in">        try stdout.print("{s}\n", .{self.name});</span></span>
<span id="cb65-815"><a href="#cb65-815" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb65-816"><a href="#cb65-816" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb65-817"><a href="#cb65-817" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-818"><a href="#cb65-818" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb65-819"><a href="#cb65-819" aria-hidden="true" tabindex="-1"></a><span class="in">    const u = User.init(1, "pedro", "email@gmail.com");</span></span>
<span id="cb65-820"><a href="#cb65-820" aria-hidden="true" tabindex="-1"></a><span class="in">    try u.print_name();</span></span>
<span id="cb65-821"><a href="#cb65-821" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb65-822"><a href="#cb65-822" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-823"><a href="#cb65-823" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-824"><a href="#cb65-824" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-825"><a href="#cb65-825" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-826"><a href="#cb65-826" aria-hidden="true" tabindex="-1"></a><span class="fu">### The `pub` keyword</span></span>
<span id="cb65-827"><a href="#cb65-827" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-828"><a href="#cb65-828" aria-hidden="true" tabindex="-1"></a>The <span class="in">`pub`</span> keyword plays an important role in struct declarations, and OOP in Zig.</span>
<span id="cb65-829"><a href="#cb65-829" aria-hidden="true" tabindex="-1"></a>In essence, this keyword is short for "public", and it makes an item/component available outside of the</span>
<span id="cb65-830"><a href="#cb65-830" aria-hidden="true" tabindex="-1"></a>module where this item/component is declared. In other words, if I don't apply the <span class="in">`pub`</span> keyword on</span>
<span id="cb65-831"><a href="#cb65-831" aria-hidden="true" tabindex="-1"></a>something, it means that this "something" is available to be called/used only from within the module</span>
<span id="cb65-832"><a href="#cb65-832" aria-hidden="true" tabindex="-1"></a>where this "something" is declared.</span>
<span id="cb65-833"><a href="#cb65-833" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-834"><a href="#cb65-834" aria-hidden="true" tabindex="-1"></a>To demonstrate the effect of this keyword let's focus again on the <span class="in">`User`</span> struct that we have</span>
<span id="cb65-835"><a href="#cb65-835" aria-hidden="true" tabindex="-1"></a>declared on the previous section. For our example here, let's suppose that this <span class="in">`User`</span> struct is declared inside</span>
<span id="cb65-836"><a href="#cb65-836" aria-hidden="true" tabindex="-1"></a>a Zig module named <span class="in">`user.zig`</span>. If I don't use the <span class="in">`pub`</span> keyword on the <span class="in">`User`</span> struct, it means that I can create</span>
<span id="cb65-837"><a href="#cb65-837" aria-hidden="true" tabindex="-1"></a>an <span class="in">`User`</span> object, and call it's methods (<span class="in">`print_name()`</span> and <span class="in">`init()`</span>) only from within the module where the <span class="in">`User`</span></span>
<span id="cb65-838"><a href="#cb65-838" aria-hidden="true" tabindex="-1"></a>struct is declared, which in this case is the <span class="in">`user.zig`</span> module.</span>
<span id="cb65-839"><a href="#cb65-839" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-840"><a href="#cb65-840" aria-hidden="true" tabindex="-1"></a>This is why the previous code example works fine. Because we declare and also use the <span class="in">`User`</span> struct</span>
<span id="cb65-841"><a href="#cb65-841" aria-hidden="true" tabindex="-1"></a>inside the same module. But problems start to arise when we try to import and call/use this struct</span>
<span id="cb65-842"><a href="#cb65-842" aria-hidden="true" tabindex="-1"></a>from another module. For example, if I create a new module called <span class="in">`register.zig`</span>, and import the <span class="in">`user.zig`</span></span>
<span id="cb65-843"><a href="#cb65-843" aria-hidden="true" tabindex="-1"></a>module into it, and try to annotate any variable with the <span class="in">`User`</span> type, I get an error from the compiler.</span>
<span id="cb65-844"><a href="#cb65-844" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-845"><a href="#cb65-845" aria-hidden="true" tabindex="-1"></a><span class="in">```zig</span></span>
<span id="cb65-846"><a href="#cb65-846" aria-hidden="true" tabindex="-1"></a><span class="in">// register.zig</span></span>
<span id="cb65-847"><a href="#cb65-847" aria-hidden="true" tabindex="-1"></a><span class="in">const user = @import("user.zig");</span></span>
<span id="cb65-848"><a href="#cb65-848" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb65-849"><a href="#cb65-849" aria-hidden="true" tabindex="-1"></a><span class="in">    const u: user.User = undefined;</span></span>
<span id="cb65-850"><a href="#cb65-850" aria-hidden="true" tabindex="-1"></a><span class="in">    _ = u;</span></span>
<span id="cb65-851"><a href="#cb65-851" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb65-852"><a href="#cb65-852" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-853"><a href="#cb65-853" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-854"><a href="#cb65-854" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-855"><a href="#cb65-855" aria-hidden="true" tabindex="-1"></a><span class="in">register.zig:3:18: error: 'User' is not marked 'pub'</span></span>
<span id="cb65-856"><a href="#cb65-856" aria-hidden="true" tabindex="-1"></a><span class="in">    const u: user.User = undefined;</span></span>
<span id="cb65-857"><a href="#cb65-857" aria-hidden="true" tabindex="-1"></a><span class="in">             ~~~~^~~~~</span></span>
<span id="cb65-858"><a href="#cb65-858" aria-hidden="true" tabindex="-1"></a><span class="in">user.zig:3:1: note: declared here</span></span>
<span id="cb65-859"><a href="#cb65-859" aria-hidden="true" tabindex="-1"></a><span class="in">const User = struct {</span></span>
<span id="cb65-860"><a href="#cb65-860" aria-hidden="true" tabindex="-1"></a><span class="in">^~~~~</span></span>
<span id="cb65-861"><a href="#cb65-861" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-862"><a href="#cb65-862" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-863"><a href="#cb65-863" aria-hidden="true" tabindex="-1"></a>Therefore, if you want to use something outside of the module where this "something" is declared,</span>
<span id="cb65-864"><a href="#cb65-864" aria-hidden="true" tabindex="-1"></a>you have to mark it with the <span class="in">`pub`</span> keyword. This "something" can be a module,</span>
<span id="cb65-865"><a href="#cb65-865" aria-hidden="true" tabindex="-1"></a>a struct, a function, an object, etc.</span>
<span id="cb65-866"><a href="#cb65-866" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-867"><a href="#cb65-867" aria-hidden="true" tabindex="-1"></a>For our example here, if we go back to the <span class="in">`user.zig`</span> module, and add the <span class="in">`pub`</span> keyword</span>
<span id="cb65-868"><a href="#cb65-868" aria-hidden="true" tabindex="-1"></a>to the <span class="in">`User`</span> struct declaration, then, I can successfully compile the <span class="in">`register.zig`</span> module.</span>
<span id="cb65-869"><a href="#cb65-869" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-870"><a href="#cb65-870" aria-hidden="true" tabindex="-1"></a><span class="in">```zig</span></span>
<span id="cb65-871"><a href="#cb65-871" aria-hidden="true" tabindex="-1"></a><span class="in">// user.zig</span></span>
<span id="cb65-872"><a href="#cb65-872" aria-hidden="true" tabindex="-1"></a><span class="in">// Added the `pub` keyword to `User`</span></span>
<span id="cb65-873"><a href="#cb65-873" aria-hidden="true" tabindex="-1"></a><span class="in">pub const User = struct {</span></span>
<span id="cb65-874"><a href="#cb65-874" aria-hidden="true" tabindex="-1"></a><span class="in">// ...</span></span>
<span id="cb65-875"><a href="#cb65-875" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-876"><a href="#cb65-876" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-877"><a href="#cb65-877" aria-hidden="true" tabindex="-1"></a><span class="in">```zig</span></span>
<span id="cb65-878"><a href="#cb65-878" aria-hidden="true" tabindex="-1"></a><span class="in">// register.zig</span></span>
<span id="cb65-879"><a href="#cb65-879" aria-hidden="true" tabindex="-1"></a><span class="in">// This works fine now!</span></span>
<span id="cb65-880"><a href="#cb65-880" aria-hidden="true" tabindex="-1"></a><span class="in">const user = @import("user.zig");</span></span>
<span id="cb65-881"><a href="#cb65-881" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb65-882"><a href="#cb65-882" aria-hidden="true" tabindex="-1"></a><span class="in">    const u: user.User = undefined;</span></span>
<span id="cb65-883"><a href="#cb65-883" aria-hidden="true" tabindex="-1"></a><span class="in">    _ = u;</span></span>
<span id="cb65-884"><a href="#cb65-884" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb65-885"><a href="#cb65-885" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-886"><a href="#cb65-886" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-887"><a href="#cb65-887" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-888"><a href="#cb65-888" aria-hidden="true" tabindex="-1"></a>Now, what do you think it will happen if I try to actually call from <span class="in">`register.zig`</span> any of the methods</span>
<span id="cb65-889"><a href="#cb65-889" aria-hidden="true" tabindex="-1"></a>of the <span class="in">`User`</span> struct? For example, if I try to call the <span class="in">`init()`</span> method? The answer is: I get a similar error message,</span>
<span id="cb65-890"><a href="#cb65-890" aria-hidden="true" tabindex="-1"></a>warning me that the <span class="in">`init()`</span> method is not marked as <span class="in">`pub`</span>, as you can see below:</span>
<span id="cb65-891"><a href="#cb65-891" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-892"><a href="#cb65-892" aria-hidden="true" tabindex="-1"></a><span class="in">```zig</span></span>
<span id="cb65-893"><a href="#cb65-893" aria-hidden="true" tabindex="-1"></a><span class="in">const user = @import("user.zig");</span></span>
<span id="cb65-894"><a href="#cb65-894" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb65-895"><a href="#cb65-895" aria-hidden="true" tabindex="-1"></a><span class="in">    const u: user.User = user.User.init(</span></span>
<span id="cb65-896"><a href="#cb65-896" aria-hidden="true" tabindex="-1"></a><span class="in">        1, "pedro", "email@gmail.com"</span></span>
<span id="cb65-897"><a href="#cb65-897" aria-hidden="true" tabindex="-1"></a><span class="in">    );</span></span>
<span id="cb65-898"><a href="#cb65-898" aria-hidden="true" tabindex="-1"></a><span class="in">    _ = u;</span></span>
<span id="cb65-899"><a href="#cb65-899" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb65-900"><a href="#cb65-900" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-901"><a href="#cb65-901" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-902"><a href="#cb65-902" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-903"><a href="#cb65-903" aria-hidden="true" tabindex="-1"></a><span class="in">register.zig:3:35: error: 'init' is not marked 'pub'</span></span>
<span id="cb65-904"><a href="#cb65-904" aria-hidden="true" tabindex="-1"></a><span class="in">    const u: user.User = user.User.init(</span></span>
<span id="cb65-905"><a href="#cb65-905" aria-hidden="true" tabindex="-1"></a><span class="in">                         ~~~~~~~~~^~~~~</span></span>
<span id="cb65-906"><a href="#cb65-906" aria-hidden="true" tabindex="-1"></a><span class="in">user.zig:8:5: note: declared here</span></span>
<span id="cb65-907"><a href="#cb65-907" aria-hidden="true" tabindex="-1"></a><span class="in">    fn init(id: u64,</span></span>
<span id="cb65-908"><a href="#cb65-908" aria-hidden="true" tabindex="-1"></a><span class="in">    ^~~~~~~</span></span>
<span id="cb65-909"><a href="#cb65-909" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-910"><a href="#cb65-910" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-911"><a href="#cb65-911" aria-hidden="true" tabindex="-1"></a>Thus, just because we have applied the <span class="in">`pub`</span> keyword on the struct declaration,</span>
<span id="cb65-912"><a href="#cb65-912" aria-hidden="true" tabindex="-1"></a>this does not make the methods of that struct public as well. If we want to use</span>
<span id="cb65-913"><a href="#cb65-913" aria-hidden="true" tabindex="-1"></a>any method from a struct (such as the <span class="in">`init()`</span> method) outside of the module</span>
<span id="cb65-914"><a href="#cb65-914" aria-hidden="true" tabindex="-1"></a>where this struct is declared, we have to mark this method with the <span class="in">`pub`</span> keyword</span>
<span id="cb65-915"><a href="#cb65-915" aria-hidden="true" tabindex="-1"></a>as well.</span>
<span id="cb65-916"><a href="#cb65-916" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-917"><a href="#cb65-917" aria-hidden="true" tabindex="-1"></a>Going back to the <span class="in">`user.zig`</span> module, and marking both the <span class="in">`init()`</span> and <span class="in">`print_name()`</span></span>
<span id="cb65-918"><a href="#cb65-918" aria-hidden="true" tabindex="-1"></a>methods with the <span class="in">`pub`</span> keyword, makes them both available to the outside world, and,</span>
<span id="cb65-919"><a href="#cb65-919" aria-hidden="true" tabindex="-1"></a>as consequence, makes the previous code example work.</span>
<span id="cb65-920"><a href="#cb65-920" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-921"><a href="#cb65-921" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-922"><a href="#cb65-922" aria-hidden="true" tabindex="-1"></a><span class="in">```zig</span></span>
<span id="cb65-923"><a href="#cb65-923" aria-hidden="true" tabindex="-1"></a><span class="in">// user.zig</span></span>
<span id="cb65-924"><a href="#cb65-924" aria-hidden="true" tabindex="-1"></a><span class="in">// Added the `pub` keyword to `User.init`</span></span>
<span id="cb65-925"><a href="#cb65-925" aria-hidden="true" tabindex="-1"></a><span class="in">    pub fn init(</span></span>
<span id="cb65-926"><a href="#cb65-926" aria-hidden="true" tabindex="-1"></a><span class="in">// ...</span></span>
<span id="cb65-927"><a href="#cb65-927" aria-hidden="true" tabindex="-1"></a><span class="in">// Added the `pub` keyword to `User.print_name`</span></span>
<span id="cb65-928"><a href="#cb65-928" aria-hidden="true" tabindex="-1"></a><span class="in">    pub fn print_name(self: User) !void {</span></span>
<span id="cb65-929"><a href="#cb65-929" aria-hidden="true" tabindex="-1"></a><span class="in">// ...</span></span>
<span id="cb65-930"><a href="#cb65-930" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-931"><a href="#cb65-931" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-932"><a href="#cb65-932" aria-hidden="true" tabindex="-1"></a><span class="in">```zig</span></span>
<span id="cb65-933"><a href="#cb65-933" aria-hidden="true" tabindex="-1"></a><span class="in">// register.zig</span></span>
<span id="cb65-934"><a href="#cb65-934" aria-hidden="true" tabindex="-1"></a><span class="in">// This works fine now!</span></span>
<span id="cb65-935"><a href="#cb65-935" aria-hidden="true" tabindex="-1"></a><span class="in">const user = @import("user.zig");</span></span>
<span id="cb65-936"><a href="#cb65-936" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb65-937"><a href="#cb65-937" aria-hidden="true" tabindex="-1"></a><span class="in">    const u: user.User = user.User.init(</span></span>
<span id="cb65-938"><a href="#cb65-938" aria-hidden="true" tabindex="-1"></a><span class="in">        1, "pedro", "email@gmail.com"</span></span>
<span id="cb65-939"><a href="#cb65-939" aria-hidden="true" tabindex="-1"></a><span class="in">    );</span></span>
<span id="cb65-940"><a href="#cb65-940" aria-hidden="true" tabindex="-1"></a><span class="in">    _ = u;</span></span>
<span id="cb65-941"><a href="#cb65-941" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb65-942"><a href="#cb65-942" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-943"><a href="#cb65-943" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-944"><a href="#cb65-944" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-945"><a href="#cb65-945" aria-hidden="true" tabindex="-1"></a><span class="fu">### Anonymous struct literals {#sec-anonymous-struct-literals}</span></span>
<span id="cb65-946"><a href="#cb65-946" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-947"><a href="#cb65-947" aria-hidden="true" tabindex="-1"></a>You can declare a struct object as a literal value. When we do that, we normally specify the</span>
<span id="cb65-948"><a href="#cb65-948" aria-hidden="true" tabindex="-1"></a>data type of this struct literal by writing its data type just before the opening curly brace.</span>
<span id="cb65-949"><a href="#cb65-949" aria-hidden="true" tabindex="-1"></a>For example, I could write a struct literal value of the type <span class="in">`User`</span> that we have defined</span>
<span id="cb65-950"><a href="#cb65-950" aria-hidden="true" tabindex="-1"></a>in the previous section like this:</span>
<span id="cb65-951"><a href="#cb65-951" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-954"><a href="#cb65-954" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-955"><a href="#cb65-955" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb65-956"><a href="#cb65-956" aria-hidden="true" tabindex="-1"></a><span class="in">const eu = User {</span></span>
<span id="cb65-957"><a href="#cb65-957" aria-hidden="true" tabindex="-1"></a><span class="in">    .id = 1,</span></span>
<span id="cb65-958"><a href="#cb65-958" aria-hidden="true" tabindex="-1"></a><span class="in">    .name = "Pedro",</span></span>
<span id="cb65-959"><a href="#cb65-959" aria-hidden="true" tabindex="-1"></a><span class="in">    .email = "someemail@gmail.com"</span></span>
<span id="cb65-960"><a href="#cb65-960" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb65-961"><a href="#cb65-961" aria-hidden="true" tabindex="-1"></a><span class="in">_ = eu;</span></span>
<span id="cb65-962"><a href="#cb65-962" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-963"><a href="#cb65-963" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-964"><a href="#cb65-964" aria-hidden="true" tabindex="-1"></a>However, in Zig, we can also write an anonymous struct literal. That is, you can write a</span>
<span id="cb65-965"><a href="#cb65-965" aria-hidden="true" tabindex="-1"></a>struct literal, but not specify explicitly the type of this particular struct.</span>
<span id="cb65-966"><a href="#cb65-966" aria-hidden="true" tabindex="-1"></a>An anonymous struct is written by using the syntax <span class="in">`.{}`</span>. So, we essentially</span>
<span id="cb65-967"><a href="#cb65-967" aria-hidden="true" tabindex="-1"></a>replaced the explicit type of the struct literal with a dot character (<span class="in">`.`</span>).</span>
<span id="cb65-968"><a href="#cb65-968" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-969"><a href="#cb65-969" aria-hidden="true" tabindex="-1"></a>As we described in @sec-type-inference, when you put a dot before a struct literal,</span>
<span id="cb65-970"><a href="#cb65-970" aria-hidden="true" tabindex="-1"></a>the type of this struct literal is automatically inferred by the <span class="in">`zig`</span> compiler.</span>
<span id="cb65-971"><a href="#cb65-971" aria-hidden="true" tabindex="-1"></a>In essence, the <span class="in">`zig`</span> compiler will look for some hint of what is the type of that struct.</span>
<span id="cb65-972"><a href="#cb65-972" aria-hidden="true" tabindex="-1"></a>This hint can be the type annotation of a function argument,</span>
<span id="cb65-973"><a href="#cb65-973" aria-hidden="true" tabindex="-1"></a>or the return type annotation of the function that you are using, or the type annotation</span>
<span id="cb65-974"><a href="#cb65-974" aria-hidden="true" tabindex="-1"></a>of an existing object.</span>
<span id="cb65-975"><a href="#cb65-975" aria-hidden="true" tabindex="-1"></a>If the compiler does find such type annotation, it will use this</span>
<span id="cb65-976"><a href="#cb65-976" aria-hidden="true" tabindex="-1"></a>type in your literal struct.</span>
<span id="cb65-977"><a href="#cb65-977" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-978"><a href="#cb65-978" aria-hidden="true" tabindex="-1"></a>Anonymous structs are very commonly used as inputs to function arguments in Zig.</span>
<span id="cb65-979"><a href="#cb65-979" aria-hidden="true" tabindex="-1"></a>One example that you have seen already constantly, is the <span class="in">`print()`</span></span>
<span id="cb65-980"><a href="#cb65-980" aria-hidden="true" tabindex="-1"></a>function from the <span class="in">`stdout`</span> object.</span>
<span id="cb65-981"><a href="#cb65-981" aria-hidden="true" tabindex="-1"></a>This function takes two arguments.</span>
<span id="cb65-982"><a href="#cb65-982" aria-hidden="true" tabindex="-1"></a>The first argument, is a template string, which should</span>
<span id="cb65-983"><a href="#cb65-983" aria-hidden="true" tabindex="-1"></a>contain string format specifiers in it, which tells how the values provided</span>
<span id="cb65-984"><a href="#cb65-984" aria-hidden="true" tabindex="-1"></a>in the second argument should be printed into the message.</span>
<span id="cb65-985"><a href="#cb65-985" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-986"><a href="#cb65-986" aria-hidden="true" tabindex="-1"></a>While the second argument is a struct literal that lists the values</span>
<span id="cb65-987"><a href="#cb65-987" aria-hidden="true" tabindex="-1"></a>to be printed into the template message specified in the first argument.</span>
<span id="cb65-988"><a href="#cb65-988" aria-hidden="true" tabindex="-1"></a>You normally want to use an anonymous struct literal here, so that the</span>
<span id="cb65-989"><a href="#cb65-989" aria-hidden="true" tabindex="-1"></a><span class="in">`zig`</span> compiler do the job of specifying the type of this particular</span>
<span id="cb65-990"><a href="#cb65-990" aria-hidden="true" tabindex="-1"></a>anonymous struct for you.</span>
<span id="cb65-991"><a href="#cb65-991" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-994"><a href="#cb65-994" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-995"><a href="#cb65-995" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb65-996"><a href="#cb65-996" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: false</span></span>
<span id="cb65-997"><a href="#cb65-997" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb65-998"><a href="#cb65-998" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb65-999"><a href="#cb65-999" aria-hidden="true" tabindex="-1"></a><span class="in">    const stdout = std.io.getStdOut().writer();</span></span>
<span id="cb65-1000"><a href="#cb65-1000" aria-hidden="true" tabindex="-1"></a><span class="in">    try stdout.print("Hello, {s}!\n", .{"world"});</span></span>
<span id="cb65-1001"><a href="#cb65-1001" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb65-1002"><a href="#cb65-1002" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-1003"><a href="#cb65-1003" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1004"><a href="#cb65-1004" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1005"><a href="#cb65-1005" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1006"><a href="#cb65-1006" aria-hidden="true" tabindex="-1"></a><span class="fu">### Struct declarations must be constant</span></span>
<span id="cb65-1007"><a href="#cb65-1007" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1008"><a href="#cb65-1008" aria-hidden="true" tabindex="-1"></a>Types in Zig must be <span class="in">`const`</span> or <span class="in">`comptime`</span> (we are going to talk more about comptime in @sec-comptime).</span>
<span id="cb65-1009"><a href="#cb65-1009" aria-hidden="true" tabindex="-1"></a>What this means is that you cannot create a new data type, and mark it as variable with the <span class="in">`var`</span> keyword.</span>
<span id="cb65-1010"><a href="#cb65-1010" aria-hidden="true" tabindex="-1"></a>So struct declarations are always constant. You cannot declare a new struct type using the <span class="in">`var`</span> keyword.</span>
<span id="cb65-1011"><a href="#cb65-1011" aria-hidden="true" tabindex="-1"></a>It must be <span class="in">`const`</span>.</span>
<span id="cb65-1012"><a href="#cb65-1012" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1013"><a href="#cb65-1013" aria-hidden="true" tabindex="-1"></a>In the <span class="in">`Vec3`</span> example below, this declaration is allowed because I'm using the <span class="in">`const`</span> keyword</span>
<span id="cb65-1014"><a href="#cb65-1014" aria-hidden="true" tabindex="-1"></a>to declare this new data type.</span>
<span id="cb65-1015"><a href="#cb65-1015" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1018"><a href="#cb65-1018" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-1019"><a href="#cb65-1019" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "lib"</span></span>
<span id="cb65-1020"><a href="#cb65-1020" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: false</span></span>
<span id="cb65-1021"><a href="#cb65-1021" aria-hidden="true" tabindex="-1"></a><span class="in">const Vec3 = struct {</span></span>
<span id="cb65-1022"><a href="#cb65-1022" aria-hidden="true" tabindex="-1"></a><span class="in">    x: f64,</span></span>
<span id="cb65-1023"><a href="#cb65-1023" aria-hidden="true" tabindex="-1"></a><span class="in">    y: f64,</span></span>
<span id="cb65-1024"><a href="#cb65-1024" aria-hidden="true" tabindex="-1"></a><span class="in">    z: f64,</span></span>
<span id="cb65-1025"><a href="#cb65-1025" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb65-1026"><a href="#cb65-1026" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-1027"><a href="#cb65-1027" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1028"><a href="#cb65-1028" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1029"><a href="#cb65-1029" aria-hidden="true" tabindex="-1"></a><span class="fu">### The `self` method argument {#sec-self-arg}</span></span>
<span id="cb65-1030"><a href="#cb65-1030" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1031"><a href="#cb65-1031" aria-hidden="true" tabindex="-1"></a>In every language that have OOP, when we declare a method of some class or struct, we</span>
<span id="cb65-1032"><a href="#cb65-1032" aria-hidden="true" tabindex="-1"></a>usually declare this method as a function that has a <span class="in">`self`</span> argument.</span>
<span id="cb65-1033"><a href="#cb65-1033" aria-hidden="true" tabindex="-1"></a>This <span class="in">`self`</span> argument is the reference to the object itself from which the method</span>
<span id="cb65-1034"><a href="#cb65-1034" aria-hidden="true" tabindex="-1"></a>is being called from.</span>
<span id="cb65-1035"><a href="#cb65-1035" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1036"><a href="#cb65-1036" aria-hidden="true" tabindex="-1"></a>It's not mandatory to use this <span class="in">`self`</span> argument. But why would you not use this <span class="in">`self`</span> argument?</span>
<span id="cb65-1037"><a href="#cb65-1037" aria-hidden="true" tabindex="-1"></a>There is no reason to not use it. Because the only way to get access to the data stored in the</span>
<span id="cb65-1038"><a href="#cb65-1038" aria-hidden="true" tabindex="-1"></a>data members of your struct is to access them through this <span class="in">`self`</span> argument.</span>
<span id="cb65-1039"><a href="#cb65-1039" aria-hidden="true" tabindex="-1"></a>If you don't need to use the data in the data members of your struct inside your method, you very likely don't need</span>
<span id="cb65-1040"><a href="#cb65-1040" aria-hidden="true" tabindex="-1"></a>a method. You can just declare this logic as a simple function, outside of your</span>
<span id="cb65-1041"><a href="#cb65-1041" aria-hidden="true" tabindex="-1"></a>struct declaration.</span>
<span id="cb65-1042"><a href="#cb65-1042" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1043"><a href="#cb65-1043" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1044"><a href="#cb65-1044" aria-hidden="true" tabindex="-1"></a>Take the <span class="in">`Vec3`</span> struct below. Inside this <span class="in">`Vec3`</span> struct we declared a method named <span class="in">`distance()`</span>.</span>
<span id="cb65-1045"><a href="#cb65-1045" aria-hidden="true" tabindex="-1"></a>This method calculates the distance between two <span class="in">`Vec3`</span> objects, by following the distance</span>
<span id="cb65-1046"><a href="#cb65-1046" aria-hidden="true" tabindex="-1"></a>formula in euclidean space. Notice that this <span class="in">`distance()`</span> method takes two <span class="in">`Vec3`</span> objects</span>
<span id="cb65-1047"><a href="#cb65-1047" aria-hidden="true" tabindex="-1"></a>as input, <span class="in">`self`</span> and <span class="in">`other`</span>.</span>
<span id="cb65-1048"><a href="#cb65-1048" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1049"><a href="#cb65-1049" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1052"><a href="#cb65-1052" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-1053"><a href="#cb65-1053" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "lib"</span></span>
<span id="cb65-1054"><a href="#cb65-1054" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: false</span></span>
<span id="cb65-1055"><a href="#cb65-1055" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb65-1056"><a href="#cb65-1056" aria-hidden="true" tabindex="-1"></a><span class="in">const m = std.math;</span></span>
<span id="cb65-1057"><a href="#cb65-1057" aria-hidden="true" tabindex="-1"></a><span class="in">const Vec3 = struct {</span></span>
<span id="cb65-1058"><a href="#cb65-1058" aria-hidden="true" tabindex="-1"></a><span class="in">    x: f64,</span></span>
<span id="cb65-1059"><a href="#cb65-1059" aria-hidden="true" tabindex="-1"></a><span class="in">    y: f64,</span></span>
<span id="cb65-1060"><a href="#cb65-1060" aria-hidden="true" tabindex="-1"></a><span class="in">    z: f64,</span></span>
<span id="cb65-1061"><a href="#cb65-1061" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1062"><a href="#cb65-1062" aria-hidden="true" tabindex="-1"></a><span class="in">    pub fn distance(self: Vec3, other: Vec3) f64 {</span></span>
<span id="cb65-1063"><a href="#cb65-1063" aria-hidden="true" tabindex="-1"></a><span class="in">        const xd = m.pow(f64, self.x - other.x, 2.0);</span></span>
<span id="cb65-1064"><a href="#cb65-1064" aria-hidden="true" tabindex="-1"></a><span class="in">        const yd = m.pow(f64, self.y - other.y, 2.0);</span></span>
<span id="cb65-1065"><a href="#cb65-1065" aria-hidden="true" tabindex="-1"></a><span class="in">        const zd = m.pow(f64, self.z - other.z, 2.0);</span></span>
<span id="cb65-1066"><a href="#cb65-1066" aria-hidden="true" tabindex="-1"></a><span class="in">        return m.sqrt(xd + yd + zd);</span></span>
<span id="cb65-1067"><a href="#cb65-1067" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb65-1068"><a href="#cb65-1068" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb65-1069"><a href="#cb65-1069" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-1070"><a href="#cb65-1070" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1071"><a href="#cb65-1071" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1072"><a href="#cb65-1072" aria-hidden="true" tabindex="-1"></a>The <span class="in">`self`</span> argument corresponds to the <span class="in">`Vec3`</span> object from which this <span class="in">`distance()`</span> method</span>
<span id="cb65-1073"><a href="#cb65-1073" aria-hidden="true" tabindex="-1"></a>is being called from. While the <span class="in">`other`</span> is a separate <span class="in">`Vec3`</span> object that is given as input</span>
<span id="cb65-1074"><a href="#cb65-1074" aria-hidden="true" tabindex="-1"></a>to this method. In the example below, the <span class="in">`self`</span> argument corresponds to the object</span>
<span id="cb65-1075"><a href="#cb65-1075" aria-hidden="true" tabindex="-1"></a><span class="in">`v1`</span>, because the <span class="in">`distance()`</span> method is being called from the <span class="in">`v1`</span> object,</span>
<span id="cb65-1076"><a href="#cb65-1076" aria-hidden="true" tabindex="-1"></a>while the <span class="in">`other`</span> argument corresponds to the object <span class="in">`v2`</span>.</span>
<span id="cb65-1077"><a href="#cb65-1077" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1078"><a href="#cb65-1078" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1081"><a href="#cb65-1081" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-1082"><a href="#cb65-1082" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb65-1083"><a href="#cb65-1083" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb65-1084"><a href="#cb65-1084" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "ast"</span></span>
<span id="cb65-1085"><a href="#cb65-1085" aria-hidden="true" tabindex="-1"></a><span class="in">const v1 = Vec3 {</span></span>
<span id="cb65-1086"><a href="#cb65-1086" aria-hidden="true" tabindex="-1"></a><span class="in">    .x = 4.2, .y = 2.4, .z = 0.9</span></span>
<span id="cb65-1087"><a href="#cb65-1087" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb65-1088"><a href="#cb65-1088" aria-hidden="true" tabindex="-1"></a><span class="in">const v2 = Vec3 {</span></span>
<span id="cb65-1089"><a href="#cb65-1089" aria-hidden="true" tabindex="-1"></a><span class="in">    .x = 5.1, .y = 5.6, .z = 1.6</span></span>
<span id="cb65-1090"><a href="#cb65-1090" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb65-1091"><a href="#cb65-1091" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1092"><a href="#cb65-1092" aria-hidden="true" tabindex="-1"></a><span class="in">std.debug.print(</span></span>
<span id="cb65-1093"><a href="#cb65-1093" aria-hidden="true" tabindex="-1"></a><span class="in">    "Distance: {d}\n",</span></span>
<span id="cb65-1094"><a href="#cb65-1094" aria-hidden="true" tabindex="-1"></a><span class="in">    .{v1.distance(v2)}</span></span>
<span id="cb65-1095"><a href="#cb65-1095" aria-hidden="true" tabindex="-1"></a><span class="in">);</span></span>
<span id="cb65-1096"><a href="#cb65-1096" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-1097"><a href="#cb65-1097" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1098"><a href="#cb65-1098" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-1099"><a href="#cb65-1099" aria-hidden="true" tabindex="-1"></a><span class="in">Distance: 3.3970575502926055</span></span>
<span id="cb65-1100"><a href="#cb65-1100" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-1101"><a href="#cb65-1101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1102"><a href="#cb65-1102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1103"><a href="#cb65-1103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1104"><a href="#cb65-1104" aria-hidden="true" tabindex="-1"></a><span class="fu">### About the struct state</span></span>
<span id="cb65-1105"><a href="#cb65-1105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1106"><a href="#cb65-1106" aria-hidden="true" tabindex="-1"></a>Sometimes you don't need to care about the state of your struct object. Sometimes, you just need</span>
<span id="cb65-1107"><a href="#cb65-1107" aria-hidden="true" tabindex="-1"></a>to instantiate and use the objects, without altering their state. You can notice that when you have methods</span>
<span id="cb65-1108"><a href="#cb65-1108" aria-hidden="true" tabindex="-1"></a>inside your struct declaration that might use the values that are present in the data members, but they</span>
<span id="cb65-1109"><a href="#cb65-1109" aria-hidden="true" tabindex="-1"></a>do not alter the values in these data members of the struct in anyway.</span>
<span id="cb65-1110"><a href="#cb65-1110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1111"><a href="#cb65-1111" aria-hidden="true" tabindex="-1"></a>The <span class="in">`Vec3`</span> struct that was presented in @sec-self-arg is an example of that.</span>
<span id="cb65-1112"><a href="#cb65-1112" aria-hidden="true" tabindex="-1"></a>This struct have a single method named <span class="in">`distance()`</span>, and this method does use the values</span>
<span id="cb65-1113"><a href="#cb65-1113" aria-hidden="true" tabindex="-1"></a>present in all three data members of the struct (<span class="in">`x`</span>, <span class="in">`y`</span> and <span class="in">`z`</span>). But at the same time,</span>
<span id="cb65-1114"><a href="#cb65-1114" aria-hidden="true" tabindex="-1"></a>this method does not change the values of these data members at any point.</span>
<span id="cb65-1115"><a href="#cb65-1115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1116"><a href="#cb65-1116" aria-hidden="true" tabindex="-1"></a>As a result of that, when we create <span class="in">`Vec3`</span> objects we usually create them as</span>
<span id="cb65-1117"><a href="#cb65-1117" aria-hidden="true" tabindex="-1"></a>constant objects, like the <span class="in">`v1`</span> and <span class="in">`v2`</span> objects presented in @sec-self-arg.</span>
<span id="cb65-1118"><a href="#cb65-1118" aria-hidden="true" tabindex="-1"></a>We can create them as variable objects with the <span class="in">`var`</span> keyword,</span>
<span id="cb65-1119"><a href="#cb65-1119" aria-hidden="true" tabindex="-1"></a>if we want to. But because the methods of this <span class="in">`Vec3`</span> struct do not change</span>
<span id="cb65-1120"><a href="#cb65-1120" aria-hidden="true" tabindex="-1"></a>the state of the objects in any point, it's unnecessary to mark them</span>
<span id="cb65-1121"><a href="#cb65-1121" aria-hidden="true" tabindex="-1"></a>as variable objects.</span>
<span id="cb65-1122"><a href="#cb65-1122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1123"><a href="#cb65-1123" aria-hidden="true" tabindex="-1"></a>But why? Why am I talking about this here? It's because the <span class="in">`self`</span> argument</span>
<span id="cb65-1124"><a href="#cb65-1124" aria-hidden="true" tabindex="-1"></a>in the methods are affected depending on whether the</span>
<span id="cb65-1125"><a href="#cb65-1125" aria-hidden="true" tabindex="-1"></a>methods present in a struct change or don't change the state of the object itself.</span>
<span id="cb65-1126"><a href="#cb65-1126" aria-hidden="true" tabindex="-1"></a>More specifically, when you have a method in a struct that changes the state</span>
<span id="cb65-1127"><a href="#cb65-1127" aria-hidden="true" tabindex="-1"></a>of the object (i.e., changes the value of a data member), the <span class="in">`self`</span> argument</span>
<span id="cb65-1128"><a href="#cb65-1128" aria-hidden="true" tabindex="-1"></a>in this method must be annotated in a different manner.</span>
<span id="cb65-1129"><a href="#cb65-1129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1130"><a href="#cb65-1130" aria-hidden="true" tabindex="-1"></a>As I described in @sec-self-arg, the <span class="in">`self`</span> argument in methods of</span>
<span id="cb65-1131"><a href="#cb65-1131" aria-hidden="true" tabindex="-1"></a>a struct is the argument that receives as input the object from which the method</span>
<span id="cb65-1132"><a href="#cb65-1132" aria-hidden="true" tabindex="-1"></a>was called from. We usually annotate this argument in the methods by writing <span class="in">`self`</span>,</span>
<span id="cb65-1133"><a href="#cb65-1133" aria-hidden="true" tabindex="-1"></a>followed by the colon character (<span class="in">`:`</span>), and the data type of the struct to which</span>
<span id="cb65-1134"><a href="#cb65-1134" aria-hidden="true" tabindex="-1"></a>the method belongs to (e.g. <span class="in">`User`</span>, <span class="in">`Vec3`</span>, etc.).</span>
<span id="cb65-1135"><a href="#cb65-1135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1136"><a href="#cb65-1136" aria-hidden="true" tabindex="-1"></a>If we take the <span class="in">`Vec3`</span> struct that we defined in the previous section as an example,</span>
<span id="cb65-1137"><a href="#cb65-1137" aria-hidden="true" tabindex="-1"></a>we can see in the <span class="in">`distance()`</span> method that this <span class="in">`self`</span> argument is annotated as</span>
<span id="cb65-1138"><a href="#cb65-1138" aria-hidden="true" tabindex="-1"></a><span class="in">`self: Vec3`</span>. Because the state of the <span class="in">`Vec3`</span> object is never altered by this</span>
<span id="cb65-1139"><a href="#cb65-1139" aria-hidden="true" tabindex="-1"></a>method.</span>
<span id="cb65-1140"><a href="#cb65-1140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1141"><a href="#cb65-1141" aria-hidden="true" tabindex="-1"></a>But what if we do have a method that alters the state of the object, by altering the</span>
<span id="cb65-1142"><a href="#cb65-1142" aria-hidden="true" tabindex="-1"></a>values of its data members, how should we annotate <span class="in">`self`</span> in this instance? The answer is:</span>
<span id="cb65-1143"><a href="#cb65-1143" aria-hidden="true" tabindex="-1"></a>"we should annotate <span class="in">`self`</span> as a pointer of <span class="in">`x`</span>, instead of just <span class="in">`x`</span>".</span>
<span id="cb65-1144"><a href="#cb65-1144" aria-hidden="true" tabindex="-1"></a>In other words, you should annotate <span class="in">`self`</span> as <span class="in">`self: *x`</span>, instead of annotating it</span>
<span id="cb65-1145"><a href="#cb65-1145" aria-hidden="true" tabindex="-1"></a>as <span class="in">`self: x`</span>.</span>
<span id="cb65-1146"><a href="#cb65-1146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1147"><a href="#cb65-1147" aria-hidden="true" tabindex="-1"></a>If we create a new method inside the <span class="in">`Vec3`</span> object that, for example, expands the</span>
<span id="cb65-1148"><a href="#cb65-1148" aria-hidden="true" tabindex="-1"></a>vector by multiplying its coordinates by a factor of two, then, we need to follow</span>
<span id="cb65-1149"><a href="#cb65-1149" aria-hidden="true" tabindex="-1"></a>this rule specified in the previous paragraph. The code example below demonstrates</span>
<span id="cb65-1150"><a href="#cb65-1150" aria-hidden="true" tabindex="-1"></a>this idea:</span>
<span id="cb65-1151"><a href="#cb65-1151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1154"><a href="#cb65-1154" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-1155"><a href="#cb65-1155" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "lib"</span></span>
<span id="cb65-1156"><a href="#cb65-1156" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: false</span></span>
<span id="cb65-1157"><a href="#cb65-1157" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb65-1158"><a href="#cb65-1158" aria-hidden="true" tabindex="-1"></a><span class="in">const m = std.math;</span></span>
<span id="cb65-1159"><a href="#cb65-1159" aria-hidden="true" tabindex="-1"></a><span class="in">const Vec3 = struct {</span></span>
<span id="cb65-1160"><a href="#cb65-1160" aria-hidden="true" tabindex="-1"></a><span class="in">    x: f64,</span></span>
<span id="cb65-1161"><a href="#cb65-1161" aria-hidden="true" tabindex="-1"></a><span class="in">    y: f64,</span></span>
<span id="cb65-1162"><a href="#cb65-1162" aria-hidden="true" tabindex="-1"></a><span class="in">    z: f64,</span></span>
<span id="cb65-1163"><a href="#cb65-1163" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1164"><a href="#cb65-1164" aria-hidden="true" tabindex="-1"></a><span class="in">    pub fn distance(self: Vec3, other: Vec3) f64 {</span></span>
<span id="cb65-1165"><a href="#cb65-1165" aria-hidden="true" tabindex="-1"></a><span class="in">        const xd = m.pow(f64, self.x - other.x, 2.0);</span></span>
<span id="cb65-1166"><a href="#cb65-1166" aria-hidden="true" tabindex="-1"></a><span class="in">        const yd = m.pow(f64, self.y - other.y, 2.0);</span></span>
<span id="cb65-1167"><a href="#cb65-1167" aria-hidden="true" tabindex="-1"></a><span class="in">        const zd = m.pow(f64, self.z - other.z, 2.0);</span></span>
<span id="cb65-1168"><a href="#cb65-1168" aria-hidden="true" tabindex="-1"></a><span class="in">        return m.sqrt(xd + yd + zd);</span></span>
<span id="cb65-1169"><a href="#cb65-1169" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb65-1170"><a href="#cb65-1170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1171"><a href="#cb65-1171" aria-hidden="true" tabindex="-1"></a><span class="in">    pub fn twice(self: *Vec3) void {</span></span>
<span id="cb65-1172"><a href="#cb65-1172" aria-hidden="true" tabindex="-1"></a><span class="in">        self.x = self.x * 2.0;</span></span>
<span id="cb65-1173"><a href="#cb65-1173" aria-hidden="true" tabindex="-1"></a><span class="in">        self.y = self.y * 2.0;</span></span>
<span id="cb65-1174"><a href="#cb65-1174" aria-hidden="true" tabindex="-1"></a><span class="in">        self.z = self.z * 2.0;</span></span>
<span id="cb65-1175"><a href="#cb65-1175" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb65-1176"><a href="#cb65-1176" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb65-1177"><a href="#cb65-1177" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-1178"><a href="#cb65-1178" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1179"><a href="#cb65-1179" aria-hidden="true" tabindex="-1"></a>Notice in the code example above that we have added a new method</span>
<span id="cb65-1180"><a href="#cb65-1180" aria-hidden="true" tabindex="-1"></a>to our <span class="in">`Vec3`</span> struct named <span class="in">`twice()`</span>. This method doubles the</span>
<span id="cb65-1181"><a href="#cb65-1181" aria-hidden="true" tabindex="-1"></a>coordinate values of our vector object. In the</span>
<span id="cb65-1182"><a href="#cb65-1182" aria-hidden="true" tabindex="-1"></a>case of the <span class="in">`twice()`</span> method, we annotated the <span class="in">`self`</span> argument as <span class="in">`*Vec3`</span>,</span>
<span id="cb65-1183"><a href="#cb65-1183" aria-hidden="true" tabindex="-1"></a>indicating that this argument receives a pointer (or a reference, if you prefer to call it this way)</span>
<span id="cb65-1184"><a href="#cb65-1184" aria-hidden="true" tabindex="-1"></a>to a <span class="in">`Vec3`</span> object as input.</span>
<span id="cb65-1185"><a href="#cb65-1185" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1188"><a href="#cb65-1188" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-1189"><a href="#cb65-1189" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb65-1190"><a href="#cb65-1190" aria-hidden="true" tabindex="-1"></a><span class="in">var v3 = Vec3 {</span></span>
<span id="cb65-1191"><a href="#cb65-1191" aria-hidden="true" tabindex="-1"></a><span class="in">    .x = 4.2, .y = 2.4, .z = 0.9</span></span>
<span id="cb65-1192"><a href="#cb65-1192" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb65-1193"><a href="#cb65-1193" aria-hidden="true" tabindex="-1"></a><span class="in">v3.twice();</span></span>
<span id="cb65-1194"><a href="#cb65-1194" aria-hidden="true" tabindex="-1"></a><span class="in">std.debug.print("Doubled: {d}\n", .{v3.x});</span></span>
<span id="cb65-1195"><a href="#cb65-1195" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-1196"><a href="#cb65-1196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1197"><a href="#cb65-1197" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-1198"><a href="#cb65-1198" aria-hidden="true" tabindex="-1"></a><span class="in">Doubled: 8.4</span></span>
<span id="cb65-1199"><a href="#cb65-1199" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-1200"><a href="#cb65-1200" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1201"><a href="#cb65-1201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1202"><a href="#cb65-1202" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1203"><a href="#cb65-1203" aria-hidden="true" tabindex="-1"></a>Now, if you change the <span class="in">`self`</span> argument in this <span class="in">`twice()`</span> method to <span class="in">`self: Vec3`</span>, like in the</span>
<span id="cb65-1204"><a href="#cb65-1204" aria-hidden="true" tabindex="-1"></a><span class="in">`distance()`</span> method, you will get the compiler error exposed below as result. Notice that this</span>
<span id="cb65-1205"><a href="#cb65-1205" aria-hidden="true" tabindex="-1"></a>error message is showing a line from the <span class="in">`twice()`</span> method body,</span>
<span id="cb65-1206"><a href="#cb65-1206" aria-hidden="true" tabindex="-1"></a>indicating that you cannot alter the value of the <span class="in">`x`</span> data member.</span>
<span id="cb65-1207"><a href="#cb65-1207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1210"><a href="#cb65-1210" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-1211"><a href="#cb65-1211" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb65-1212"><a href="#cb65-1212" aria-hidden="true" tabindex="-1"></a><span class="in">// If we change the function signature of double to:</span></span>
<span id="cb65-1213"><a href="#cb65-1213" aria-hidden="true" tabindex="-1"></a><span class="in">    pub fn twice(self: Vec3) void {</span></span>
<span id="cb65-1214"><a href="#cb65-1214" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-1215"><a href="#cb65-1215" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1216"><a href="#cb65-1216" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-1217"><a href="#cb65-1217" aria-hidden="true" tabindex="-1"></a><span class="in">t.zig:16:13: error: cannot assign to constant</span></span>
<span id="cb65-1218"><a href="#cb65-1218" aria-hidden="true" tabindex="-1"></a><span class="in">        self.x = self.x * 2.0;</span></span>
<span id="cb65-1219"><a href="#cb65-1219" aria-hidden="true" tabindex="-1"></a><span class="in">        ~~~~^~</span></span>
<span id="cb65-1220"><a href="#cb65-1220" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-1221"><a href="#cb65-1221" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1222"><a href="#cb65-1222" aria-hidden="true" tabindex="-1"></a>This error message indicates that the <span class="in">`x`</span> data member belongs to a constant object,</span>
<span id="cb65-1223"><a href="#cb65-1223" aria-hidden="true" tabindex="-1"></a>and, because of that, it cannot be changed. Ultimately, this error message</span>
<span id="cb65-1224"><a href="#cb65-1224" aria-hidden="true" tabindex="-1"></a>is telling us that the <span class="in">`self`</span> argument is constant.</span>
<span id="cb65-1225"><a href="#cb65-1225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1226"><a href="#cb65-1226" aria-hidden="true" tabindex="-1"></a>If you take some time, and think hard about this error message, you will understand it.</span>
<span id="cb65-1227"><a href="#cb65-1227" aria-hidden="true" tabindex="-1"></a>You already have the tools to understand why we are getting this error message.</span>
<span id="cb65-1228"><a href="#cb65-1228" aria-hidden="true" tabindex="-1"></a>We have talked about it already in @sec-fun-pars.</span>
<span id="cb65-1229"><a href="#cb65-1229" aria-hidden="true" tabindex="-1"></a>So remember, every function argument is immutable in Zig, and <span class="in">`self`</span></span>
<span id="cb65-1230"><a href="#cb65-1230" aria-hidden="true" tabindex="-1"></a>is no exception to this rule.</span>
<span id="cb65-1231"><a href="#cb65-1231" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1232"><a href="#cb65-1232" aria-hidden="true" tabindex="-1"></a>In this example, we marked the <span class="in">`v3`</span> object as a variable object.</span>
<span id="cb65-1233"><a href="#cb65-1233" aria-hidden="true" tabindex="-1"></a>But this does not matter. Because it's not about the input object, it's about</span>
<span id="cb65-1234"><a href="#cb65-1234" aria-hidden="true" tabindex="-1"></a>the function argument.</span>
<span id="cb65-1235"><a href="#cb65-1235" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1236"><a href="#cb65-1236" aria-hidden="true" tabindex="-1"></a>The problem begins when we try to alter the value of <span class="in">`self`</span> directly, which is a function argument,</span>
<span id="cb65-1237"><a href="#cb65-1237" aria-hidden="true" tabindex="-1"></a>and, every function argument is immutable by default. You may ask yourself how can we overcome</span>
<span id="cb65-1238"><a href="#cb65-1238" aria-hidden="true" tabindex="-1"></a>this barrier, and once again, the solution was also discussed in @sec-fun-pars.</span>
<span id="cb65-1239"><a href="#cb65-1239" aria-hidden="true" tabindex="-1"></a>We overcome this barrier, by explicitly marking the <span class="in">`self`</span> argument as a pointer.</span>
<span id="cb65-1240"><a href="#cb65-1240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1241"><a href="#cb65-1241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1242"><a href="#cb65-1242" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb65-1243"><a href="#cb65-1243" aria-hidden="true" tabindex="-1"></a>If a method of your <span class="in">`x`</span> struct alters the state of the object, by</span>
<span id="cb65-1244"><a href="#cb65-1244" aria-hidden="true" tabindex="-1"></a>changing the value of any data member, then, remember to use <span class="in">`self: *x`</span>,</span>
<span id="cb65-1245"><a href="#cb65-1245" aria-hidden="true" tabindex="-1"></a>instead of <span class="in">`self: x`</span> in the function signature of this method.</span>
<span id="cb65-1246"><a href="#cb65-1246" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb65-1247"><a href="#cb65-1247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1248"><a href="#cb65-1248" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1249"><a href="#cb65-1249" aria-hidden="true" tabindex="-1"></a>You could also interpret the content discussed in this section as:</span>
<span id="cb65-1250"><a href="#cb65-1250" aria-hidden="true" tabindex="-1"></a>"if you need to alter the state of your <span class="in">`x`</span> struct object in one of its methods,</span>
<span id="cb65-1251"><a href="#cb65-1251" aria-hidden="true" tabindex="-1"></a>you must explicitly pass the <span class="in">`x`</span> struct object by reference to the <span class="in">`self`</span> argument of this method".</span>
<span id="cb65-1252"><a href="#cb65-1252" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1253"><a href="#cb65-1253" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1254"><a href="#cb65-1254" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1255"><a href="#cb65-1255" aria-hidden="true" tabindex="-1"></a><span class="fu">## Type inference {#sec-type-inference}</span></span>
<span id="cb65-1256"><a href="#cb65-1256" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1257"><a href="#cb65-1257" aria-hidden="true" tabindex="-1"></a>Zig is a strongly typed language. But, there are some situations</span>
<span id="cb65-1258"><a href="#cb65-1258" aria-hidden="true" tabindex="-1"></a>where you don't have to explicitly write the type of every single object in your source code,</span>
<span id="cb65-1259"><a href="#cb65-1259" aria-hidden="true" tabindex="-1"></a>as you would expect from a traditional strongly typed language, such as C and C++.</span>
<span id="cb65-1260"><a href="#cb65-1260" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1261"><a href="#cb65-1261" aria-hidden="true" tabindex="-1"></a>In some situations, the <span class="in">`zig`</span> compiler can use type inference to solve the data types for you, easing some of</span>
<span id="cb65-1262"><a href="#cb65-1262" aria-hidden="true" tabindex="-1"></a>the burden that you carry as a developer.</span>
<span id="cb65-1263"><a href="#cb65-1263" aria-hidden="true" tabindex="-1"></a>The most common way this happens is through function arguments that receive struct objects</span>
<span id="cb65-1264"><a href="#cb65-1264" aria-hidden="true" tabindex="-1"></a>as input.</span>
<span id="cb65-1265"><a href="#cb65-1265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1266"><a href="#cb65-1266" aria-hidden="true" tabindex="-1"></a>In general, type inference in Zig is done by using the dot character (<span class="in">`.`</span>).</span>
<span id="cb65-1267"><a href="#cb65-1267" aria-hidden="true" tabindex="-1"></a>Everytime you see a dot character written before a struct literal, or before an enum value, or something like that,</span>
<span id="cb65-1268"><a href="#cb65-1268" aria-hidden="true" tabindex="-1"></a>you know that this dot character is playing a special part in this place. More specifically, it's</span>
<span id="cb65-1269"><a href="#cb65-1269" aria-hidden="true" tabindex="-1"></a>telling the <span class="in">`zig`</span> compiler something along the lines of: "Hey! Can you infer the type of this</span>
<span id="cb65-1270"><a href="#cb65-1270" aria-hidden="true" tabindex="-1"></a>value for me? Please!". In other words, this dot character is playing a similar role as the <span class="in">`auto`</span> keyword in C++.</span>
<span id="cb65-1271"><a href="#cb65-1271" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1272"><a href="#cb65-1272" aria-hidden="true" tabindex="-1"></a>I gave you some examples of this in @sec-anonymous-struct-literals, where we used anonymous struct literals.</span>
<span id="cb65-1273"><a href="#cb65-1273" aria-hidden="true" tabindex="-1"></a>Anonymous struct literals are, struct literals that use type inference to</span>
<span id="cb65-1274"><a href="#cb65-1274" aria-hidden="true" tabindex="-1"></a>infer the exact type of this particular struct literal.</span>
<span id="cb65-1275"><a href="#cb65-1275" aria-hidden="true" tabindex="-1"></a>This type inference is done by looking for some minimal hint of the correct data type to be used.</span>
<span id="cb65-1276"><a href="#cb65-1276" aria-hidden="true" tabindex="-1"></a>You could say that the <span class="in">`zig`</span> compiler looks for any neighbouring type annotation that might tell it</span>
<span id="cb65-1277"><a href="#cb65-1277" aria-hidden="true" tabindex="-1"></a>what the correct type would be.</span>
<span id="cb65-1278"><a href="#cb65-1278" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1279"><a href="#cb65-1279" aria-hidden="true" tabindex="-1"></a>Another common place where we use type inference in Zig is at switch statements (which we talked about in @sec-switch).</span>
<span id="cb65-1280"><a href="#cb65-1280" aria-hidden="true" tabindex="-1"></a>I also gave some other examples of type inference in @sec-switch, where we were inferring the data types of enum values listed inside</span>
<span id="cb65-1281"><a href="#cb65-1281" aria-hidden="true" tabindex="-1"></a>of switch statements (e.g. <span class="in">`.DE`</span>).</span>
<span id="cb65-1282"><a href="#cb65-1282" aria-hidden="true" tabindex="-1"></a>But as another example, take a look at this <span class="in">`fence()`</span> function reproduced below,</span>
<span id="cb65-1283"><a href="#cb65-1283" aria-hidden="true" tabindex="-1"></a>which comes from the <span class="co">[</span><span class="ot">`atomic.zig` module</span><span class="co">](https://github.com/ziglang/zig/blob/master/lib/std/atomic.zig)</span><span class="ot">[^fence-fn]</span></span>
<span id="cb65-1284"><a href="#cb65-1284" aria-hidden="true" tabindex="-1"></a>of the Zig Standard Library.</span>
<span id="cb65-1285"><a href="#cb65-1285" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1286"><a href="#cb65-1286" aria-hidden="true" tabindex="-1"></a><span class="ot">[^fence-fn]: &lt;https://github.com/ziglang/zig/blob/master/lib/std/atomic.zig&gt;</span>.</span>
<span id="cb65-1287"><a href="#cb65-1287" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1288"><a href="#cb65-1288" aria-hidden="true" tabindex="-1"></a>There are a lot of things in this function that we haven't talked about yet, such as:</span>
<span id="cb65-1289"><a href="#cb65-1289" aria-hidden="true" tabindex="-1"></a>what <span class="in">`comptime`</span> means? <span class="in">`inline`</span>? <span class="in">`extern`</span>?</span>
<span id="cb65-1290"><a href="#cb65-1290" aria-hidden="true" tabindex="-1"></a>Let's just ignore all of these things, and focus solely on the switch statement</span>
<span id="cb65-1291"><a href="#cb65-1291" aria-hidden="true" tabindex="-1"></a>that is inside this function.</span>
<span id="cb65-1292"><a href="#cb65-1292" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1293"><a href="#cb65-1293" aria-hidden="true" tabindex="-1"></a>We can see that this switch statement uses the <span class="in">`order`</span> object as input. This <span class="in">`order`</span></span>
<span id="cb65-1294"><a href="#cb65-1294" aria-hidden="true" tabindex="-1"></a>object is one of the inputs of this <span class="in">`fence()`</span> function, and we can see in the type annotation,</span>
<span id="cb65-1295"><a href="#cb65-1295" aria-hidden="true" tabindex="-1"></a>that this object is of type <span class="in">`AtomicOrder`</span>. We can also see a bunch of values inside the</span>
<span id="cb65-1296"><a href="#cb65-1296" aria-hidden="true" tabindex="-1"></a>switch statements that begin with a dot character, such as <span class="in">`.release`</span> and <span class="in">`.acquire`</span>.</span>
<span id="cb65-1297"><a href="#cb65-1297" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1298"><a href="#cb65-1298" aria-hidden="true" tabindex="-1"></a>Because these weird values contain a dot character before them, we are asking the <span class="in">`zig`</span></span>
<span id="cb65-1299"><a href="#cb65-1299" aria-hidden="true" tabindex="-1"></a>compiler to infer the types of these values inside the switch statement. Then, the <span class="in">`zig`</span></span>
<span id="cb65-1300"><a href="#cb65-1300" aria-hidden="true" tabindex="-1"></a>compiler is looking into the current context where these values are being used, and trying</span>
<span id="cb65-1301"><a href="#cb65-1301" aria-hidden="true" tabindex="-1"></a>to infer the types of these values.</span>
<span id="cb65-1302"><a href="#cb65-1302" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1303"><a href="#cb65-1303" aria-hidden="true" tabindex="-1"></a>Since they are being used inside a switch statement, the <span class="in">`zig`</span> compiler looks into the type</span>
<span id="cb65-1304"><a href="#cb65-1304" aria-hidden="true" tabindex="-1"></a>of the input object given to the switch statement, which is the <span class="in">`order`</span> object in this case.</span>
<span id="cb65-1305"><a href="#cb65-1305" aria-hidden="true" tabindex="-1"></a>Because this object have type <span class="in">`AtomicOrder`</span>, the <span class="in">`zig`</span> compiler infers that these values</span>
<span id="cb65-1306"><a href="#cb65-1306" aria-hidden="true" tabindex="-1"></a>are data members from this type <span class="in">`AtomicOrder`</span>.</span>
<span id="cb65-1307"><a href="#cb65-1307" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1310"><a href="#cb65-1310" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-1311"><a href="#cb65-1311" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb65-1312"><a href="#cb65-1312" aria-hidden="true" tabindex="-1"></a><span class="in">pub inline fn fence(self: *Self, comptime order: AtomicOrder) void {</span></span>
<span id="cb65-1313"><a href="#cb65-1313" aria-hidden="true" tabindex="-1"></a><span class="in">    // many lines of code ...</span></span>
<span id="cb65-1314"><a href="#cb65-1314" aria-hidden="true" tabindex="-1"></a><span class="in">    if (builtin.sanitize_thread) {</span></span>
<span id="cb65-1315"><a href="#cb65-1315" aria-hidden="true" tabindex="-1"></a><span class="in">        const tsan = struct {</span></span>
<span id="cb65-1316"><a href="#cb65-1316" aria-hidden="true" tabindex="-1"></a><span class="in">            extern "c" fn __tsan_acquire(addr: *anyopaque) void;</span></span>
<span id="cb65-1317"><a href="#cb65-1317" aria-hidden="true" tabindex="-1"></a><span class="in">            extern "c" fn __tsan_release(addr: *anyopaque) void;</span></span>
<span id="cb65-1318"><a href="#cb65-1318" aria-hidden="true" tabindex="-1"></a><span class="in">        };</span></span>
<span id="cb65-1319"><a href="#cb65-1319" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1320"><a href="#cb65-1320" aria-hidden="true" tabindex="-1"></a><span class="in">        const addr: *anyopaque = self;</span></span>
<span id="cb65-1321"><a href="#cb65-1321" aria-hidden="true" tabindex="-1"></a><span class="in">        return switch (order) {</span></span>
<span id="cb65-1322"><a href="#cb65-1322" aria-hidden="true" tabindex="-1"></a><span class="in">            .unordered, .monotonic =&gt; @compileError(</span></span>
<span id="cb65-1323"><a href="#cb65-1323" aria-hidden="true" tabindex="-1"></a><span class="in">                @tagName(order)</span></span>
<span id="cb65-1324"><a href="#cb65-1324" aria-hidden="true" tabindex="-1"></a><span class="in">                ++ " only applies to atomic loads and stores"</span></span>
<span id="cb65-1325"><a href="#cb65-1325" aria-hidden="true" tabindex="-1"></a><span class="in">            ),</span></span>
<span id="cb65-1326"><a href="#cb65-1326" aria-hidden="true" tabindex="-1"></a><span class="in">            .acquire =&gt; tsan.__tsan_acquire(addr),</span></span>
<span id="cb65-1327"><a href="#cb65-1327" aria-hidden="true" tabindex="-1"></a><span class="in">            .release =&gt; tsan.__tsan_release(addr),</span></span>
<span id="cb65-1328"><a href="#cb65-1328" aria-hidden="true" tabindex="-1"></a><span class="in">            .acq_rel, .seq_cst =&gt; {</span></span>
<span id="cb65-1329"><a href="#cb65-1329" aria-hidden="true" tabindex="-1"></a><span class="in">                tsan.__tsan_acquire(addr);</span></span>
<span id="cb65-1330"><a href="#cb65-1330" aria-hidden="true" tabindex="-1"></a><span class="in">                tsan.__tsan_release(addr);</span></span>
<span id="cb65-1331"><a href="#cb65-1331" aria-hidden="true" tabindex="-1"></a><span class="in">            },</span></span>
<span id="cb65-1332"><a href="#cb65-1332" aria-hidden="true" tabindex="-1"></a><span class="in">        };</span></span>
<span id="cb65-1333"><a href="#cb65-1333" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb65-1334"><a href="#cb65-1334" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1335"><a href="#cb65-1335" aria-hidden="true" tabindex="-1"></a><span class="in">    return @fence(order);</span></span>
<span id="cb65-1336"><a href="#cb65-1336" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb65-1337"><a href="#cb65-1337" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-1338"><a href="#cb65-1338" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1339"><a href="#cb65-1339" aria-hidden="true" tabindex="-1"></a>This is how basic type inference is done in Zig. If we didn't use the dot character before</span>
<span id="cb65-1340"><a href="#cb65-1340" aria-hidden="true" tabindex="-1"></a>the values inside this switch statement, then, we would be forced to explicitly write</span>
<span id="cb65-1341"><a href="#cb65-1341" aria-hidden="true" tabindex="-1"></a>the data types of these values. For example, instead of writing <span class="in">`.release`</span> we would have to</span>
<span id="cb65-1342"><a href="#cb65-1342" aria-hidden="true" tabindex="-1"></a>write <span class="in">`AtomicOrder.release`</span>. We would have to do this for every single value</span>
<span id="cb65-1343"><a href="#cb65-1343" aria-hidden="true" tabindex="-1"></a>in this switch statement, and this is a lot of work. That is why type inference</span>
<span id="cb65-1344"><a href="#cb65-1344" aria-hidden="true" tabindex="-1"></a>is commonly used on switch statements in Zig.</span>
<span id="cb65-1345"><a href="#cb65-1345" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1346"><a href="#cb65-1346" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1347"><a href="#cb65-1347" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1348"><a href="#cb65-1348" aria-hidden="true" tabindex="-1"></a><span class="fu">## Type casting {#sec-type-cast}</span></span>
<span id="cb65-1349"><a href="#cb65-1349" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1350"><a href="#cb65-1350" aria-hidden="true" tabindex="-1"></a>In this section, I want to discuss type casting (or, type conversion) with you.</span>
<span id="cb65-1351"><a href="#cb65-1351" aria-hidden="true" tabindex="-1"></a>We use type casting when we have an object of type "x", and we want to convert</span>
<span id="cb65-1352"><a href="#cb65-1352" aria-hidden="true" tabindex="-1"></a>it into an object of type "y", i.e., we want to change the data type of the object.</span>
<span id="cb65-1353"><a href="#cb65-1353" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1354"><a href="#cb65-1354" aria-hidden="true" tabindex="-1"></a>Most languages have a formal way to perform type casting. In Rust for example, we normally</span>
<span id="cb65-1355"><a href="#cb65-1355" aria-hidden="true" tabindex="-1"></a>use the keyword <span class="in">`as`</span>, and in C, we normally use the type casting syntax, e.g. <span class="in">`(int) x`</span>.</span>
<span id="cb65-1356"><a href="#cb65-1356" aria-hidden="true" tabindex="-1"></a>In Zig, we use the <span class="in">`@as()`</span> built-in function to cast an object of type "x", into</span>
<span id="cb65-1357"><a href="#cb65-1357" aria-hidden="true" tabindex="-1"></a>an object of type "y".</span>
<span id="cb65-1358"><a href="#cb65-1358" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1359"><a href="#cb65-1359" aria-hidden="true" tabindex="-1"></a>This <span class="in">`@as()`</span> function is the preferred way to perform type conversion (or type casting)</span>
<span id="cb65-1360"><a href="#cb65-1360" aria-hidden="true" tabindex="-1"></a>in Zig. Because it's explicit, and, it also performs the casting only if it</span>
<span id="cb65-1361"><a href="#cb65-1361" aria-hidden="true" tabindex="-1"></a>is unambiguous and safe. To use this function, you just provide the target data type</span>
<span id="cb65-1362"><a href="#cb65-1362" aria-hidden="true" tabindex="-1"></a>in the first argument, and, the object that you want cast as the second argument.</span>
<span id="cb65-1363"><a href="#cb65-1363" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1366"><a href="#cb65-1366" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-1367"><a href="#cb65-1367" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: false</span></span>
<span id="cb65-1368"><a href="#cb65-1368" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "test"</span></span>
<span id="cb65-1369"><a href="#cb65-1369" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb65-1370"><a href="#cb65-1370" aria-hidden="true" tabindex="-1"></a><span class="in">const expect = std.testing.expect;</span></span>
<span id="cb65-1371"><a href="#cb65-1371" aria-hidden="true" tabindex="-1"></a><span class="in">test {</span></span>
<span id="cb65-1372"><a href="#cb65-1372" aria-hidden="true" tabindex="-1"></a><span class="in">    const x: usize = 500;</span></span>
<span id="cb65-1373"><a href="#cb65-1373" aria-hidden="true" tabindex="-1"></a><span class="in">    const y = @as(u32, x);</span></span>
<span id="cb65-1374"><a href="#cb65-1374" aria-hidden="true" tabindex="-1"></a><span class="in">    try expect(@TypeOf(y) == u32);</span></span>
<span id="cb65-1375"><a href="#cb65-1375" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb65-1376"><a href="#cb65-1376" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-1377"><a href="#cb65-1377" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1378"><a href="#cb65-1378" aria-hidden="true" tabindex="-1"></a>This is the general way to perform type casting in Zig. But remember, <span class="in">`@as()`</span> works only when casting</span>
<span id="cb65-1379"><a href="#cb65-1379" aria-hidden="true" tabindex="-1"></a>is unambiguous and safe. There are many situations where these assumptions do not hold. For example,</span>
<span id="cb65-1380"><a href="#cb65-1380" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1381"><a href="#cb65-1381" aria-hidden="true" tabindex="-1"></a>when casting an integer value into a float value, or vice-versa, it's not clear to the compiler</span>
<span id="cb65-1382"><a href="#cb65-1382" aria-hidden="true" tabindex="-1"></a>how to perform this conversion safely.</span>
<span id="cb65-1383"><a href="#cb65-1383" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1384"><a href="#cb65-1384" aria-hidden="true" tabindex="-1"></a>Therefore, we need to use specialized "casting functions" in such situations.</span>
<span id="cb65-1385"><a href="#cb65-1385" aria-hidden="true" tabindex="-1"></a>For example, if you want to cast an integer value into a float value, then, you</span>
<span id="cb65-1386"><a href="#cb65-1386" aria-hidden="true" tabindex="-1"></a>should use the <span class="in">`@floatFromInt()`</span> function. In the inverse scenario, you should use</span>
<span id="cb65-1387"><a href="#cb65-1387" aria-hidden="true" tabindex="-1"></a>the <span class="in">`@intFromFloat()`</span> function.</span>
<span id="cb65-1388"><a href="#cb65-1388" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1389"><a href="#cb65-1389" aria-hidden="true" tabindex="-1"></a>In these functions, you just provide the object that you want to</span>
<span id="cb65-1390"><a href="#cb65-1390" aria-hidden="true" tabindex="-1"></a>cast as input. Then, the target data type of the "type casting operation" is determined by</span>
<span id="cb65-1391"><a href="#cb65-1391" aria-hidden="true" tabindex="-1"></a>the type annotation of the object where you are saving the results.</span>
<span id="cb65-1392"><a href="#cb65-1392" aria-hidden="true" tabindex="-1"></a>In the example below, we are casting the object <span class="in">`x`</span> into a value of type <span class="in">`f32`</span>,</span>
<span id="cb65-1393"><a href="#cb65-1393" aria-hidden="true" tabindex="-1"></a>because the object <span class="in">`y`</span>, which is where we are saving the results, is annotated</span>
<span id="cb65-1394"><a href="#cb65-1394" aria-hidden="true" tabindex="-1"></a>as an object of type <span class="in">`f32`</span>.</span>
<span id="cb65-1395"><a href="#cb65-1395" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1398"><a href="#cb65-1398" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-1399"><a href="#cb65-1399" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: false</span></span>
<span id="cb65-1400"><a href="#cb65-1400" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "test"</span></span>
<span id="cb65-1401"><a href="#cb65-1401" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb65-1402"><a href="#cb65-1402" aria-hidden="true" tabindex="-1"></a><span class="in">const expect = std.testing.expect;</span></span>
<span id="cb65-1403"><a href="#cb65-1403" aria-hidden="true" tabindex="-1"></a><span class="in">test {</span></span>
<span id="cb65-1404"><a href="#cb65-1404" aria-hidden="true" tabindex="-1"></a><span class="in">    const x: usize = 565;</span></span>
<span id="cb65-1405"><a href="#cb65-1405" aria-hidden="true" tabindex="-1"></a><span class="in">    const y: f32 = @floatFromInt(x);</span></span>
<span id="cb65-1406"><a href="#cb65-1406" aria-hidden="true" tabindex="-1"></a><span class="in">    try expect(@TypeOf(y) == f32);</span></span>
<span id="cb65-1407"><a href="#cb65-1407" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb65-1408"><a href="#cb65-1408" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-1409"><a href="#cb65-1409" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1410"><a href="#cb65-1410" aria-hidden="true" tabindex="-1"></a>Another built-in function that is very useful when performing type casting operations is <span class="in">`@ptrCast()`</span>.</span>
<span id="cb65-1411"><a href="#cb65-1411" aria-hidden="true" tabindex="-1"></a>In essence, we use the <span class="in">`@as()`</span> built-in function when we want to explicit convert (or cast) a Zig value/object</span>
<span id="cb65-1412"><a href="#cb65-1412" aria-hidden="true" tabindex="-1"></a>from a type "x" to a type "y", etc. However, pointers (we are going to discuss pointers</span>
<span id="cb65-1413"><a href="#cb65-1413" aria-hidden="true" tabindex="-1"></a>in more depth in @sec-pointer) are a special type of object in Zig,</span>
<span id="cb65-1414"><a href="#cb65-1414" aria-hidden="true" tabindex="-1"></a>i.e., they are treated differently from "normal objects".</span>
<span id="cb65-1415"><a href="#cb65-1415" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1416"><a href="#cb65-1416" aria-hidden="true" tabindex="-1"></a>Everytime a pointer is involved in some "type casting operation" in Zig, the <span class="in">`@ptrCast()`</span> function is used.</span>
<span id="cb65-1417"><a href="#cb65-1417" aria-hidden="true" tabindex="-1"></a>This function works similarly to <span class="in">`@floatFromInt()`</span>.</span>
<span id="cb65-1418"><a href="#cb65-1418" aria-hidden="true" tabindex="-1"></a>You just provide the pointer object that you want to cast as input to this function, and the</span>
<span id="cb65-1419"><a href="#cb65-1419" aria-hidden="true" tabindex="-1"></a>target data type is, once again, determined by the type annotation of the object where the results are being</span>
<span id="cb65-1420"><a href="#cb65-1420" aria-hidden="true" tabindex="-1"></a>stored.</span>
<span id="cb65-1421"><a href="#cb65-1421" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1424"><a href="#cb65-1424" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-1425"><a href="#cb65-1425" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: false</span></span>
<span id="cb65-1426"><a href="#cb65-1426" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "test"</span></span>
<span id="cb65-1427"><a href="#cb65-1427" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb65-1428"><a href="#cb65-1428" aria-hidden="true" tabindex="-1"></a><span class="in">const expect = std.testing.expect;</span></span>
<span id="cb65-1429"><a href="#cb65-1429" aria-hidden="true" tabindex="-1"></a><span class="in">test {</span></span>
<span id="cb65-1430"><a href="#cb65-1430" aria-hidden="true" tabindex="-1"></a><span class="in">    const bytes align(@alignOf(u32)) = [_]u8{</span></span>
<span id="cb65-1431"><a href="#cb65-1431" aria-hidden="true" tabindex="-1"></a><span class="in">        0x12, 0x12, 0x12, 0x12</span></span>
<span id="cb65-1432"><a href="#cb65-1432" aria-hidden="true" tabindex="-1"></a><span class="in">    };</span></span>
<span id="cb65-1433"><a href="#cb65-1433" aria-hidden="true" tabindex="-1"></a><span class="in">    const u32_ptr: *const u32 = @ptrCast(&amp;bytes);</span></span>
<span id="cb65-1434"><a href="#cb65-1434" aria-hidden="true" tabindex="-1"></a><span class="in">    try expect(@TypeOf(u32_ptr) == *const u32);</span></span>
<span id="cb65-1435"><a href="#cb65-1435" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb65-1436"><a href="#cb65-1436" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-1437"><a href="#cb65-1437" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1438"><a href="#cb65-1438" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1439"><a href="#cb65-1439" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1440"><a href="#cb65-1440" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1441"><a href="#cb65-1441" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1442"><a href="#cb65-1442" aria-hidden="true" tabindex="-1"></a><span class="fu">## Modules</span></span>
<span id="cb65-1443"><a href="#cb65-1443" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1444"><a href="#cb65-1444" aria-hidden="true" tabindex="-1"></a>We already talked about what modules are, and also, how to import other modules into</span>
<span id="cb65-1445"><a href="#cb65-1445" aria-hidden="true" tabindex="-1"></a>your current module via *import statements*. Every Zig module (i.e., a <span class="in">`.zig`</span> file) that you write in your project</span>
<span id="cb65-1446"><a href="#cb65-1446" aria-hidden="true" tabindex="-1"></a>is internally stored as a struct object. Take the line exposed below as an example. In this line we are importing the</span>
<span id="cb65-1447"><a href="#cb65-1447" aria-hidden="true" tabindex="-1"></a>Zig Standard Library into our current module.</span>
<span id="cb65-1448"><a href="#cb65-1448" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1451"><a href="#cb65-1451" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-1452"><a href="#cb65-1452" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb65-1453"><a href="#cb65-1453" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb65-1454"><a href="#cb65-1454" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb65-1455"><a href="#cb65-1455" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1456"><a href="#cb65-1456" aria-hidden="true" tabindex="-1"></a>When we want to access the functions and objects from the standard library, we</span>
<span id="cb65-1457"><a href="#cb65-1457" aria-hidden="true" tabindex="-1"></a>are basically accessing the data members of the struct stored in the <span class="in">`std`</span></span>
<span id="cb65-1458"><a href="#cb65-1458" aria-hidden="true" tabindex="-1"></a>object. That is why we use the same syntax that we use in normal structs, with the dot operator (<span class="in">`.`</span>)</span>
<span id="cb65-1459"><a href="#cb65-1459" aria-hidden="true" tabindex="-1"></a>to access the data members and methods of the struct.</span>
<span id="cb65-1460"><a href="#cb65-1460" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1461"><a href="#cb65-1461" aria-hidden="true" tabindex="-1"></a>When this "import statement" gets executed, the result of this expression is a struct</span>
<span id="cb65-1462"><a href="#cb65-1462" aria-hidden="true" tabindex="-1"></a>object that contains the Zig Standard Library modules, global variables, functions, etc.</span>
<span id="cb65-1463"><a href="#cb65-1463" aria-hidden="true" tabindex="-1"></a>And this struct object gets saved (or stored) inside the constant object named <span class="in">`std`</span>.</span>
<span id="cb65-1464"><a href="#cb65-1464" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1465"><a href="#cb65-1465" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1466"><a href="#cb65-1466" aria-hidden="true" tabindex="-1"></a>Take the <span class="co">[</span><span class="ot">`thread_pool.zig` module from the project `zap`</span><span class="co">](https://github.com/kprotty/zap/blob/blog/src/thread_pool.zig)</span><span class="ot">[^thread]</span></span>
<span id="cb65-1467"><a href="#cb65-1467" aria-hidden="true" tabindex="-1"></a>as an example. This module is written as if it was</span>
<span id="cb65-1468"><a href="#cb65-1468" aria-hidden="true" tabindex="-1"></a>a big struct. That is why we have a top-level and public <span class="in">`init()`</span> method</span>
<span id="cb65-1469"><a href="#cb65-1469" aria-hidden="true" tabindex="-1"></a>written in this module. The idea is that all top-level functions written in this</span>
<span id="cb65-1470"><a href="#cb65-1470" aria-hidden="true" tabindex="-1"></a>module are methods from the struct, and all top-level objects and struct declarations</span>
<span id="cb65-1471"><a href="#cb65-1471" aria-hidden="true" tabindex="-1"></a>are data members of this struct. The module is the struct itself.</span>
<span id="cb65-1472"><a href="#cb65-1472" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1473"><a href="#cb65-1473" aria-hidden="true" tabindex="-1"></a><span class="ot">[^thread]: &lt;https://github.com/kprotty/zap/blob/blog/src/thread_pool.zig&gt;</span></span>
<span id="cb65-1474"><a href="#cb65-1474" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1475"><a href="#cb65-1475" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1476"><a href="#cb65-1476" aria-hidden="true" tabindex="-1"></a>So you would import and use this module by doing something like this:</span>
<span id="cb65-1477"><a href="#cb65-1477" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-1480"><a href="#cb65-1480" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb65-1481"><a href="#cb65-1481" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb65-1482"><a href="#cb65-1482" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb65-1483"><a href="#cb65-1483" aria-hidden="true" tabindex="-1"></a><span class="in">const ThreadPool = @import("thread_pool.zig");</span></span>
<span id="cb65-1484"><a href="#cb65-1484" aria-hidden="true" tabindex="-1"></a><span class="in">const num_cpus = std.Thread.getCpuCount()</span></span>
<span id="cb65-1485"><a href="#cb65-1485" aria-hidden="true" tabindex="-1"></a><span class="in">    catch @panic("failed to get cpu core count");</span></span>
<span id="cb65-1486"><a href="#cb65-1486" aria-hidden="true" tabindex="-1"></a><span class="in">const num_threads = std.math.cast(u16, num_cpus)</span></span>
<span id="cb65-1487"><a href="#cb65-1487" aria-hidden="true" tabindex="-1"></a><span class="in">    catch std.math.maxInt(u16);</span></span>
<span id="cb65-1488"><a href="#cb65-1488" aria-hidden="true" tabindex="-1"></a><span class="in">const pool = ThreadPool.init(</span></span>
<span id="cb65-1489"><a href="#cb65-1489" aria-hidden="true" tabindex="-1"></a><span class="in">    .{ .max_threads = num_threads }</span></span>
<span id="cb65-1490"><a href="#cb65-1490" aria-hidden="true" tabindex="-1"></a><span class="in">);</span></span>
<span id="cb65-1491"><a href="#cb65-1491" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>