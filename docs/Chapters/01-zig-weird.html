<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Introduction to Zig - 1&nbsp; Introducing Zig</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../Chapters/03-structs.html" rel="next">
<link href="../index.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-6CHJXK4CEV"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-6CHJXK4CEV', { 'anonymize_ip': true});
</script>


</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../Chapters/01-zig-weird.html"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introducing Zig</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Introduction to Zig</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Welcome</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/01-zig-weird.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introducing Zig</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/03-structs.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Control flow, structs, modules and types</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/01-memory.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Memory and Allocators</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/01-base64.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Project 1 - Building a base64 encoder/decoder</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/02-debugging.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Debugging Zig applications</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/05-pointers.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Pointers and Optionals</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/04-http-server.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Project 2 - Building a HTTP Server from scratch</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/03-unittests.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Unit tests</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/07-build-system.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Build System</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/09-error-handling.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Error handling and unions</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/09-data-structures.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Data Structures</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/10-stack-project.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Project 3 - Building a stack data structure</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/12-file-op.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Filesystem and Input/Output (IO)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/14-zig-c-interop.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Zig interoperability with C</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/13-image-filter.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Project 4 - Developing an image filter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/14-threads.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Introducing threads and parallelism in Zig</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Chapters/15-vectors.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Introducing Vectors and SIMD</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#what-is-zig" id="toc-what-is-zig" class="nav-link active" data-scroll-target="#what-is-zig"><span class="header-section-number">1.1</span> What is Zig?</a></li>
  <li><a href="#hello-world-in-zig" id="toc-hello-world-in-zig" class="nav-link" data-scroll-target="#hello-world-in-zig"><span class="header-section-number">1.2</span> Hello world in Zig</a>
  <ul class="collapse">
  <li><a href="#sec-project-files" id="toc-sec-project-files" class="nav-link" data-scroll-target="#sec-project-files"><span class="header-section-number">1.2.1</span> Understanding the project files</a></li>
  <li><a href="#sec-root-file" id="toc-sec-root-file" class="nav-link" data-scroll-target="#sec-root-file"><span class="header-section-number">1.2.2</span> The file <code>root.zig</code></a></li>
  <li><a href="#sec-main-file" id="toc-sec-main-file" class="nav-link" data-scroll-target="#sec-main-file"><span class="header-section-number">1.2.3</span> The <code>main.zig</code> file</a></li>
  <li><a href="#sec-compile-code" id="toc-sec-compile-code" class="nav-link" data-scroll-target="#sec-compile-code"><span class="header-section-number">1.2.4</span> Compiling your source code</a></li>
  <li><a href="#sec-compile-run-code" id="toc-sec-compile-run-code" class="nav-link" data-scroll-target="#sec-compile-run-code"><span class="header-section-number">1.2.5</span> Compile and execute at the same time</a></li>
  <li><a href="#important-note-for-windows-users" id="toc-important-note-for-windows-users" class="nav-link" data-scroll-target="#important-note-for-windows-users"><span class="header-section-number">1.2.6</span> Important note for Windows users</a></li>
  <li><a href="#sec-compile-project" id="toc-sec-compile-project" class="nav-link" data-scroll-target="#sec-compile-project"><span class="header-section-number">1.2.7</span> Compiling the entire project</a></li>
  </ul></li>
  <li><a href="#how-to-learn-zig" id="toc-how-to-learn-zig" class="nav-link" data-scroll-target="#how-to-learn-zig"><span class="header-section-number">1.3</span> How to learn Zig?</a></li>
  <li><a href="#sec-assignments" id="toc-sec-assignments" class="nav-link" data-scroll-target="#sec-assignments"><span class="header-section-number">1.4</span> Creating new objects in Zig (i.e., identifiers)</a>
  <ul class="collapse">
  <li><a href="#constant-objects-vs-variable-objects" id="toc-constant-objects-vs-variable-objects" class="nav-link" data-scroll-target="#constant-objects-vs-variable-objects"><span class="header-section-number">1.4.1</span> Constant objects vs variable objects</a></li>
  <li><a href="#declaring-without-an-initial-value" id="toc-declaring-without-an-initial-value" class="nav-link" data-scroll-target="#declaring-without-an-initial-value"><span class="header-section-number">1.4.2</span> Declaring without an initial value</a></li>
  <li><a href="#there-is-no-such-thing-as-unused-objects" id="toc-there-is-no-such-thing-as-unused-objects" class="nav-link" data-scroll-target="#there-is-no-such-thing-as-unused-objects"><span class="header-section-number">1.4.3</span> There is no such thing as unused objects</a></li>
  <li><a href="#you-must-mutate-every-variable-objects" id="toc-you-must-mutate-every-variable-objects" class="nav-link" data-scroll-target="#you-must-mutate-every-variable-objects"><span class="header-section-number">1.4.4</span> You must mutate every variable objects</a></li>
  </ul></li>
  <li><a href="#sec-primitive-data-types" id="toc-sec-primitive-data-types" class="nav-link" data-scroll-target="#sec-primitive-data-types"><span class="header-section-number">1.5</span> Primitive Data Types</a></li>
  <li><a href="#sec-arrays" id="toc-sec-arrays" class="nav-link" data-scroll-target="#sec-arrays"><span class="header-section-number">1.6</span> Arrays</a>
  <ul class="collapse">
  <li><a href="#sec-select-array-elem" id="toc-sec-select-array-elem" class="nav-link" data-scroll-target="#sec-select-array-elem"><span class="header-section-number">1.6.1</span> Selecting elements of the array</a></li>
  <li><a href="#more-on-slices" id="toc-more-on-slices" class="nav-link" data-scroll-target="#more-on-slices"><span class="header-section-number">1.6.2</span> More on slices</a></li>
  <li><a href="#array-operators" id="toc-array-operators" class="nav-link" data-scroll-target="#array-operators"><span class="header-section-number">1.6.3</span> Array operators</a></li>
  <li><a href="#runtime-versus-compile-time-known-length-in-slices" id="toc-runtime-versus-compile-time-known-length-in-slices" class="nav-link" data-scroll-target="#runtime-versus-compile-time-known-length-in-slices"><span class="header-section-number">1.6.4</span> Runtime versus compile-time known length in slices</a></li>
  </ul></li>
  <li><a href="#sec-blocks" id="toc-sec-blocks" class="nav-link" data-scroll-target="#sec-blocks"><span class="header-section-number">1.7</span> Blocks and scopes</a></li>
  <li><a href="#sec-zig-strings" id="toc-sec-zig-strings" class="nav-link" data-scroll-target="#sec-zig-strings"><span class="header-section-number">1.8</span> How strings work in Zig?</a>
  <ul class="collapse">
  <li><a href="#using-a-slice-versus-a-sentinel-terminated-array" id="toc-using-a-slice-versus-a-sentinel-terminated-array" class="nav-link" data-scroll-target="#using-a-slice-versus-a-sentinel-terminated-array"><span class="header-section-number">1.8.1</span> Using a slice versus a sentinel-terminated array</a></li>
  <li><a href="#iterating-through-the-string" id="toc-iterating-through-the-string" class="nav-link" data-scroll-target="#iterating-through-the-string"><span class="header-section-number">1.8.2</span> Iterating through the string</a></li>
  <li><a href="#a-better-look-at-the-object-type" id="toc-a-better-look-at-the-object-type" class="nav-link" data-scroll-target="#a-better-look-at-the-object-type"><span class="header-section-number">1.8.3</span> A better look at the object type</a></li>
  <li><a href="#byte-vs-unicode-points" id="toc-byte-vs-unicode-points" class="nav-link" data-scroll-target="#byte-vs-unicode-points"><span class="header-section-number">1.8.4</span> Byte vs unicode points</a></li>
  <li><a href="#sec-strings-useful-funs" id="toc-sec-strings-useful-funs" class="nav-link" data-scroll-target="#sec-strings-useful-funs"><span class="header-section-number">1.8.5</span> Some useful functions for strings</a></li>
  </ul></li>
  <li><a href="#safety-in-zig" id="toc-safety-in-zig" class="nav-link" data-scroll-target="#safety-in-zig"><span class="header-section-number">1.9</span> Safety in Zig</a></li>
  <li><a href="#other-parts-of-zig" id="toc-other-parts-of-zig" class="nav-link" data-scroll-target="#other-parts-of-zig"><span class="header-section-number">1.10</span> Other parts of Zig</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introducing Zig</span></h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">View Source</a></li></ul></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>In this chapter, I want to introduce you to the world of Zig. Zig is a very young language that is being actively developed. As a consequence, its world is still very wild and to be explored. This book is my attempt to help you on your personal journey for understanding and exploring the exciting world of Zig.</p>
<p>I assume you have previous experience with some programming language in this book, not necessarily with a low-level one. So, if you have experience with Python, or Javascript, for example, it will be fine. But, if you do have experience with low-level languages, such as C, C++, or Rust, you will probably learn faster throughout this book.</p>
<section id="what-is-zig" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="what-is-zig"><span class="header-section-number">1.1</span> What is Zig?</h2>
<p>Zig is a modern, low-level, and general-purpose programming language. Some programmers think of Zig as a modern and better version of C.</p>
<p>In the author’s personal interpretation, Zig is tightly connected with “less is more”. Instead of trying to become a modern language by adding more and more features, many of the core improvements that Zig brings to the table are actually about removing annoying behaviours/features from C and C++. In other words, Zig tries to be better by simplifying the language, and by having more consistent and robust behaviour. As a result, analyzing, writing and debugging applications become much easier and simpler in Zig, than it is in C or C++.</p>
<p>This philosophy becomes clear with the following phrase from the official website of Zig:</p>
<blockquote class="blockquote">
<p>“Focus on debugging your application rather than debugging your programming language knowledge”.</p>
</blockquote>
<p>This phrase is specially true for C++ programmers. Because C++ is a gigantic language, with tons of features, and also, there are lots of different “flavors of C++”. These elements are what makes C++ so complex and hard to learn. Zig tries to go in the opposite direction. Zig is a very simple language, more closely related to other simple languages such as C and Go.</p>
<p>The phrase above is still important for C programmers too. Because, even C being a simple language, it’s still hard sometimes to read and understand C code. For example, pre-processor macros in C are a frequent source of confusion. Sometimes, they really make it hard to debug C programs. Because macros are essentially a second language embedded in C that obscures your C code. With macros, you are no longer 100% sure about which pieces of the code are being sent to the compiler, i.e. they obscure the actual source code that you wrote.</p>
<p>You don’t have macros in Zig. In Zig, the code you write, is the actual code that gets compiled by the compiler. You also don’t have a hidden control flow happening behind the scenes. And, you also don’t have functions or operators from the standard library that make hidden memory allocations behind your back.</p>
<p>By being a simpler language, Zig becomes much more clear and easier to read/write, but at the same time, it also achieves a much more robust state, with more consistent behaviour in edge situations. Once again, less is more.</p>
</section>
<section id="hello-world-in-zig" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="hello-world-in-zig"><span class="header-section-number">1.2</span> Hello world in Zig</h2>
<p>We begin our journey in Zig by creating a small “Hello World” program. To start a new Zig project in your computer, you simply call the <code>init</code> command from the <code>zig</code> compiler. Just create a new directory in your computer, then, init a new Zig project inside this directory, like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mkdir</span> hello_world</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> hello_world</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ex">zig</span> init</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>info: created build.zig
info: created build.zig.zon
info: created src/main.zig
info: created src/root.zig
info: see `zig build --help` for a menu of options</code></pre>
<section id="sec-project-files" class="level3" data-number="1.2.1">
<h3 data-number="1.2.1" class="anchored" data-anchor-id="sec-project-files"><span class="header-section-number">1.2.1</span> Understanding the project files</h3>
<p>After you run the <code>init</code> command from the <code>zig</code> compiler, some new files are created inside of your current directory. First, a “source” (<code>src</code>) directory is created, containing two files, <code>main.zig</code> and <code>root.zig</code>. Each <code>.zig</code> file is a separate Zig module, which is simply a text file that contains some Zig code.</p>
<p>By convention, the <code>main.zig</code> module is where your main function lives. Thus, if you are building an executable program in Zig, you need to declare a <code>main()</code> function, which represents the entrypoint of your program, i.e., where the execution of your program begins.</p>
<p>However, if you are building a library (instead of an executable program), then, the normal procedure is to delete this <code>main.zig</code> file and start with the <code>root.zig</code> module. By convention, the <code>root.zig</code> module is the root source file of your library.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ex">tree</span> .</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>.
├── build.zig
├── build.zig.zon
└── src
    ├── main.zig
    └── root.zig

1 directory, 4 files</code></pre>
<p>The <code>init</code> command also creates two additional files in our working directory: <code>build.zig</code> and <code>build.zig.zon</code>. The first file (<code>build.zig</code>) represents a build script written in Zig. This script is executed when you call the <code>build</code> command from the <code>zig</code> compiler. In other words, this file contains Zig code that executes the necessary steps to build the entire project.</p>
<p>Low-level languages normally use a compiler to build your source code into binary executables or binary libraries. Nevertheless, this process of compiling your source code and building binary executables or binary libraries from it, became a real challenge in the programming world, once the projects became bigger and bigger. As a result, programmers created “build systems”, which are a second set of tools designed to make this process of compiling and building complex projects, easier.</p>
<p>Examples of build systems are CMake, GNU Make, GNU Autoconf and Ninja, which are used to build complex C and C++ projects. With these systems, you can write scripts, which are called “build scripts”. They simply are scripts that describes the necessary steps to compile/build your project.</p>
<p>However, these are separate tools, that do not belong to C/C++ compilers, like <code>gcc</code> or <code>clang</code>. As a result, in C/C++ projects, you have not only to install and manage your C/C++ compilers, but you also have to install and manage these build systems separately.</p>
<p>In Zig, we don’t need to use a separate set of tools to build our projects, because a build system is embedded inside the language itself. We can use this build system to write small scripts in Zig, which describe the necessary steps to build/compile our Zig project<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. So, everything you need to build a complex Zig project is the <code>zig</code> compiler, and nothing more.</p>
<p>The second generated file (<code>build.zig.zon</code>) is a JSON-like file, in which you can describe your project, and also, declare a set of dependencies of your project that you want to fetch from the internet. In other words, you can use this <code>build.zig.zon</code> file to include a list of external libraries in your project.</p>
<p>One possible way to include an external Zig library in your project, is to manually build and install the library in your system, and just link your source code with the library at the build step of your project.</p>
<p>However, if this external Zig library is available on GitHub for example, and it has a valid <code>build.zig.zon</code> file in root folder of the project, which describes the project, you can easily include this library in your project by simply listing this external library in your <code>build.zig.zon</code> file.</p>
<p>In other words, this <code>build.zig.zon</code> file works similarly to the <code>package.json</code> file in Javascript projects, or the <code>Pipfile</code> file in Python projects, or the <code>Cargo.toml</code> file in Rust projects. You can read more about this specific file in a couple of articles on the internet<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>, and you can also see the expected schema for this <code>build.zig.zon</code> file in a documentation file inside the official repository of Zig<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>.</p>
</section>
<section id="sec-root-file" class="level3" data-number="1.2.2">
<h3 data-number="1.2.2" class="anchored" data-anchor-id="sec-root-file"><span class="header-section-number">1.2.2</span> The file <code>root.zig</code></h3>
<p>Let’s take a look into the <code>root.zig</code> file. You might have noticed that every line of code with an expression ends with a semicolon (<code>;</code>). This follows the syntax of a C-family programming language<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>.</p>
<p>Also, notice the <code>@import()</code> call at the first line. We use this built-in function to import functionality from other Zig modules into our current module. This <code>@import()</code> function works similarly to the <code>#include</code> pre-processor in C or C++, or, to the <code>import</code> statement in Python or Javascript code. In this example, we are importing the <code>std</code> module, which gives you access to the Zig Standard Library.</p>
<p>In this <code>root.zig</code> file, we can also see how assignments (i.e., creating new objects) are made in Zig. You can create a new object in Zig by using the syntax <code>(const|var) name = value;</code>. In the example below, we are creating two constant objects (<code>std</code> and <code>testing</code>). In <a href="#sec-assignments" class="quarto-xref"><span>Section 1.4</span></a> we talk more about objects in general.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> testing = std.testing;</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">export</span> <span class="kw">fn</span> add(a: <span class="dt">i32</span>, b: <span class="dt">i32</span>) <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> a + b;</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Functions in Zig are declared using the <code>fn</code> keyword. In this <code>root.zig</code> module, we are declaring a function called <code>add()</code>, which has two arguments named <code>a</code> and <code>b</code>. The function returns an integer of the type <code>i32</code> as result.</p>
<p>Zig is a strongly-typed language. There are some specific situations where you can (if you want to) omit the type of an object in your code, if this type can be inferred by the <code>zig</code> compiler (we talk more about that in <a href="03-structs.html#sec-type-inference" class="quarto-xref"><span>Section 2.4</span></a>). But there are other situations where you do need to be explicit. For example, you do have to explicitly specify the type of each function argument, and also, the return type of every function that you create in Zig.</p>
<p>We specify the type of an object or a function argument in Zig by using a colon character (<code>:</code>) followed by the type after the name of this object/function argument. With the expressions <code>a: i32</code> and <code>b: i32</code>, we know that both <code>a</code> and <code>b</code> arguments have type <code>i32</code>, which is a signed 32 bit integer. In this part, the syntax in Zig is identical to the syntax in Rust, which also specifies types by using the colon character.</p>
<p>Lastly, we have the return type of the function at the end of the line, before we open the curly braces to start writing the function’s body. In the example above, this type is also a signed 32 bit integer (<code>i32</code>) value.</p>
<p>Notice that we also have an <code>export</code> keyword before the function declaration. This keyword is similar to the <code>extern</code> keyword in C. It exposes the function to make it available in the library API. Therefore, if you are writing a library for other people to use, you have to expose the functions you write in the public API of this library by using this <code>export</code> keyword. If we removed the <code>export</code> keyword from the <code>add()</code> function declaration, then, this function would be no longer exposed in the library object built by the <code>zig</code> compiler.</p>
</section>
<section id="sec-main-file" class="level3" data-number="1.2.3">
<h3 data-number="1.2.3" class="anchored" data-anchor-id="sec-main-file"><span class="header-section-number">1.2.3</span> The <code>main.zig</code> file</h3>
<p>Now that we have learned a lot about Zig’s syntax from the <code>root.zig</code> file, let’s take a look at the <code>main.zig</code> file. A lot of the elements we saw in <code>root.zig</code> are also present in <code>main.zig</code>. But there are some other elements that we haven’t seen yet, so let’s dive in.</p>
<p>First, look at the return type of the <code>main()</code> function in this file. We can see a small change. The return type of the function (<code>void</code>) is accompanied by an exclamation mark (<code>!</code>). This exclamation mark tells us that this <code>main()</code> function might return an error.</p>
<p>It’s worth noting that, a <code>main()</code> function in Zig is allowed to return nothing (<code>void</code>), or an unsigned 8-bit integer (<code>u8</code>) value<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>, or an error. In other words, you can write your <code>main()</code> function in Zig to return essentially nothing (<code>void</code>), or, if you prefer, you can also write a more C-like <code>main()</code> function, which returns an integer value that usually serves as a “status code” for the process.</p>
<p>In this example, the return type annotation of <code>main()</code> indicates that this function can either return nothing (<code>void</code>), or return an error. This exclamation mark in the return type annotation is an interesting and powerful feature of Zig. In summary, if you write a function and something inside the body of this function might return an error, then, you are forced to:</p>
<ul>
<li>either add the exclamation mark to the return type of the function and make it clear that this function might return an error.</li>
<li>explicitly handle this error inside the function.</li>
</ul>
<p>In most programming languages, we normally handle (or deal with) an error through a <em>try catch</em> pattern. Zig does have both <code>try</code> and <code>catch</code> keywords. But they work a little differently than what you’re probably used to in other languages.</p>
<p>If we look at the <code>main()</code> function below, you can see that we do have a <code>try</code> keyword on the 5th line. But we do not have a <code>catch</code> keyword in this code. In Zig, we use the <code>try</code> keyword to execute an expression that might return an error, which, in this example, is the <code>stdout.print()</code> expression.</p>
<p>In essence, the <code>try</code> keyword executes the expression <code>stdout.print()</code>. If this expression returns a valid value, then, the <code>try</code> keyword does absolutely nothing. It only passes the value forward. It’s like if this <code>try</code> keyword was never there. However, if the expression does return an error, then, the <code>try</code> keyword will unwrap the error value, then, it returns this error from the function and also prints the current stack trace to <code>stderr</code>.</p>
<p>This might sound weird to you if you come from a high-level language. Because in high-level languages, such as Python, if an error occurs somewhere, this error is automatically returned and the execution of your program will automatically stop even if you don’t want to stop the execution. You are obligated to face the error.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> stdout = std.io.getStdOut().writer();</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> stdout.print(<span class="st">"Hello, {s}!</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span><span class="st">"world"</span><span class="op">}</span>);</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Another thing that you might have noticed in this code example, is that the <code>main()</code> function is marked with the <code>pub</code> keyword. It marks the <code>main()</code> function as a <em>public function</em> from this module. Every function in your Zig module is by default private to this Zig module and can only be called from within the module. Unless, you explicitly mark this function as a public function with the <code>pub</code> keyword.</p>
<p>If you think about it, this <code>pub</code> keyword in Zig does essentially the opposite of what the <code>static</code> keyword do in C/C++. By making a function “public” you allow other Zig modules to access and call this function. A calling Zig module imports another module by using the <code>@import()</code> built-in function, which makes all public functions from the imported module visible to the calling Zig module.</p>
</section>
<section id="sec-compile-code" class="level3" data-number="1.2.4">
<h3 data-number="1.2.4" class="anchored" data-anchor-id="sec-compile-code"><span class="header-section-number">1.2.4</span> Compiling your source code</h3>
<p>You can compile your Zig modules into a binary executable by running the <code>build-exe</code> command from the <code>zig</code> compiler. You simply list all the Zig modules that you want to build after the <code>build-exe</code> command, separated by spaces. In the example below, we are compiling the module <code>main.zig</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ex">zig</span> build-exe src/main.zig</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Since we are building an executable, the <code>zig</code> compiler will look for a <code>main()</code> function declared in any of the files that you list after the <code>build-exe</code> command. If the compiler does not find a <code>main()</code> function declared somewhere, a compilation error will be raised, warning about this mistake.</p>
<p>The <code>zig</code> compiler also offers a <code>build-lib</code> and <code>build-obj</code> commands, which work the exact same way as the <code>build-exe</code> command. The only difference is that, they compile your Zig modules into a portable C ABI library, or, into object files, respectively.</p>
<p>In the case of the <code>build-exe</code> command, a binary executable file is created by the <code>zig</code> compiler in the root directory of your project. If we take a look now at the contents of our current directory, with a simple <code>ls</code> command, we can see the binary file called <code>main</code> that was created by the compiler.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ls</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>build.zig  build.zig.zon  main  src</code></pre>
<p>If I execute this binary executable, I get the “Hello World” message in the terminal , as we expected.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ex">./main</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>Hello, world!</code></pre>
</section>
<section id="sec-compile-run-code" class="level3" data-number="1.2.5">
<h3 data-number="1.2.5" class="anchored" data-anchor-id="sec-compile-run-code"><span class="header-section-number">1.2.5</span> Compile and execute at the same time</h3>
<p>In the previous section, I presented the <code>zig build-exe</code> command, which compiles Zig modules into an executable file. However, this means that, in order to execute the executable file, we have to run two different commands. First, the <code>zig build-exe</code> command, and then, we call the executable file created by the compiler.</p>
<p>But what if we wanted to perform these two steps, all at once, in a single command? We can do that by using the <code>zig run</code> command.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ex">zig</span> run src/main.zig</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>Hello, world!</code></pre>
</section>
<section id="important-note-for-windows-users" class="level3" data-number="1.2.6">
<h3 data-number="1.2.6" class="anchored" data-anchor-id="important-note-for-windows-users"><span class="header-section-number">1.2.6</span> Important note for Windows users</h3>
<p>First of all, this is a Windows-specific thing, and, therefore, does not apply to other operating systems, such as Linux and macOS. In summary, if you have a piece of Zig code that includes some global variables whose initialization rely on runtime resources, then, you might have some troubles while trying to compile this Zig code on Windows.</p>
<p>An example of that is accessing the <code>stdout</code> (i.e., the <em>standard output</em> of your system), which is usually done in Zig by using the expression <code>std.io.getStdOut()</code>. If you use this expression to instantiate a global variable in a Zig module, then, the compilation of your Zig code will very likely fail on Windows, with an “unable to evaluate comptime expression” error message.</p>
<p>This failure in the compilation process happens because all global variables in Zig are initialized at <em>compile-time</em>. However, on Windows, operations like accessing the <code>stdout</code> (or opening a file) depend on resources that are available only at <em>runtime</em> (you will learn more about compile-time versus runtime in <a href="01-memory.html#sec-compile-time" class="quarto-xref"><span>Section 3.1.1</span></a>).</p>
<p>For example, if you try to compile this code example on Windows, you will likely get the error message exposed below:</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="co">// ERROR! Compile-time error that emerges from</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="co">// this next line, on the `stdout` object</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> stdout = std.io.getStdOut().writer();</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    _ = <span class="kw">try</span> stdout.write(<span class="st">"Hello</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>t.zig:2107:28: error: unable to evaluate comptime expression
    break :blk asm {
               ^~~</code></pre>
<p>To avoid this problem on Windows, we need to force the <code>zig</code> compiler to instantiate this <code>stdout</code> object only at runtime, instead of instantiating it at compile-time. We can achieve that by simply moving the expression to a function body.</p>
<p>This solves the problem because all expressions that are inside a function body in Zig are evaluated only at runtime, unless you use the <code>comptime</code> keyword explicitly to change this behaviour. You will learn more about this <code>comptime</code> keyword in <a href="10-stack-project.html#sec-comptime" class="quarto-xref"><span>Section 12.1</span></a>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// SUCCESS: Stdout initialized at runtime.</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> stdout = std.io.getStdOut().writer();</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    _ = <span class="kw">try</span> stdout.write(<span class="st">"Hello</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>Hello</code></pre>
<p>You can read more details about this Windows-specific limitation in a couple of GitHub issues opened at the official Zig repository. More specifically, the issues 17186 <a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> and 19864 <a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>.</p>
</section>
<section id="sec-compile-project" class="level3" data-number="1.2.7">
<h3 data-number="1.2.7" class="anchored" data-anchor-id="sec-compile-project"><span class="header-section-number">1.2.7</span> Compiling the entire project</h3>
<p>Just as I described in <a href="#sec-project-files" class="quarto-xref"><span>Section 1.2.1</span></a>, as our project grows in size and complexity, we usually prefer to organize the compilation and build process of the project into a build script, using some sort of “build system”.</p>
<p>In other words, as our project grows in size and complexity, the <code>build-exe</code>, <code>build-lib</code> and <code>build-obj</code> commands become harder to use directly. Because then, we start to list multiple and multiple modules at the same time. We also start to add built-in compilation flags to customize the build process for our needs, etc. It becomes a lot of work to write the necessary commands by hand.</p>
<p>In C/C++ projects, programmers normally opt to use CMake, Ninja, <code>Makefile</code> or <code>configure</code> scripts to organize this process. However, in Zig, we have a native build system in the language itself. So, we can write build scripts in Zig to compile and build Zig projects. Then, all we need to do, is to call the <code>zig build</code> command to build our project.</p>
<p>So, when you execute the <code>zig build</code> command, the <code>zig</code> compiler will search for a Zig module named <code>build.zig</code> inside your current directory, which should be your build script, containing the necessary code to compile and build your project. If the compiler does find this <code>build.zig</code> file in your directory, then, the compiler will essentially execute a <code>zig run</code> command over this <code>build.zig</code> file, to compile and execute this build script, which in turn, will compile and build your entire project.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ex">zig</span> build</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>After you execute this “build project” command, a <code>zig-out</code> directory is created in the root of your project directory, where you can find the binary executables and libraries created from your Zig modules accordingly to the build commands that you specified at <code>build.zig</code>. We will talk more about the build system in Zig later in this book.</p>
<p>In the example below, I’m executing the binary executable named <code>hello_world</code> that was generated by the compiler after the <code>zig build</code> command.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ex">./zig-out/bin/hello_world</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>Hello, world!</code></pre>
</section>
</section>
<section id="how-to-learn-zig" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="how-to-learn-zig"><span class="header-section-number">1.3</span> How to learn Zig?</h2>
<p>What are the best strategies to learn Zig? First of all, of course this book will help you a lot on your journey through Zig. But you will also need some extra resources if you want to be really good at Zig.</p>
<p>As a first tip, you can join a community with Zig programmers to get some help , when you need it:</p>
<ul>
<li>Reddit forum: <a href="https://www.reddit.com/r/Zig/" class="uri">https://www.reddit.com/r/Zig/</a>;</li>
<li>Ziggit community: <a href="https://ziggit.dev/" class="uri">https://ziggit.dev/</a>;</li>
<li>Discord, Slack, Telegram, and others: <a href="https://github.com/ziglang/zig/wiki/Community" class="uri">https://github.com/ziglang/zig/wiki/Community</a>;</li>
</ul>
<p>Now, one of the best ways to learn Zig is to simply read Zig code. Try to read Zig code often, and things will become more clear. A C/C++ programmer would also probably give you this same tip. Because this strategy really works!</p>
<p>Now, where can you find Zig code to read? I personally think that, the best way of reading Zig code is to read the source code of the Zig Standard Library. The Zig Standard Library is available at the <a href="https://github.com/ziglang/zig/tree/master/lib/std"><code>lib/std</code> folder</a><a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> on the official GitHub repository of Zig. Access this folder, and start exploring the Zig modules.</p>
<p>Also, a great alternative is to read code from other large Zig codebases, such as:</p>
<ol type="1">
<li>the <a href="https://github.com/oven-sh/bun">Javascript runtime Bun</a><a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a>.</li>
<li>the <a href="https://github.com/hexops/mach">game engine Mach</a><a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>.</li>
<li>a <a href="https://github.com/cgbur/llama2.zig/tree/main">LLama 2 LLM model implementation in Zig</a><a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a>.</li>
<li>the <a href="https://github.com/tigerbeetle/tigerbeetle">financial transactions database <code>tigerbeetle</code></a><a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a>.</li>
<li>the <a href="https://github.com/Hejsil/zig-clap">command-line arguments parser <code>zig-clap</code></a><a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a>.</li>
<li>the <a href="https://github.com/capy-ui/capy">UI framework <code>capy</code></a><a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a>.</li>
<li>the <a href="https://github.com/zigtools/zls">Language Protocol implementation for Zig, <code>zls</code></a><a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a>.</li>
<li>the <a href="https://github.com/mitchellh/libxev">event-loop library <code>libxev</code></a><a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a>.</li>
</ol>
<p>All these assets are available on GitHub, and this is great, because we can use the GitHub search bar to our advantage, to find Zig code that fits our description. For example, you can always include <code>lang:Zig</code> in the GitHub search bar when you are searching for a particular pattern. This will limit the search to only Zig modules.</p>
<p>Also, a great alternative is to consult online resources and documentation. Here is a quick list of resources that I personally use from time to time to learn more about the language each day:</p>
<ul>
<li>Zig Language Reference: <a href="https://ziglang.org/documentation/master/" class="uri">https://ziglang.org/documentation/master/</a>;</li>
<li>Zig Standard Library Reference: <a href="https://ziglang.org/documentation/master/std/" class="uri">https://ziglang.org/documentation/master/std/</a>;</li>
<li>Zig Guide: <a href="https://zig.guide/" class="uri">https://zig.guide/</a>;</li>
<li>Karl Seguin Blog: <a href="https://www.openmymind.net/" class="uri">https://www.openmymind.net/</a>;</li>
<li>Zig News: <a href="https://zig.news/" class="uri">https://zig.news/</a>;</li>
<li>Read the code written by one of the Zig core team members: <a href="https://github.com/kubkon" class="uri">https://github.com/kubkon</a>;</li>
<li>Some livecoding sessions are transmitted in the Zig Showtime Youtube Channel: <a href="https://www.youtube.com/@ZigSHOWTIME/videos" class="uri">https://www.youtube.com/@ZigSHOWTIME/videos</a>;</li>
</ul>
<p>Another great strategy to learn Zig, or honestly, to learn any language you want, is to practice it by solving exercises. For example, there is a famous repository in the Zig community called <a href="https://ziglings.org">Ziglings</a><a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a> , which contains more than 100 small exercises that you can solve. It’s a repository of tiny programs written in Zig that are currently broken, and your responsibility is to fix these programs, and make them work again.</p>
<p>A famous tech YouTuber known as <em>The Primeagen</em> also posted some videos (on YouTube) where he solves these exercises from Ziglings. The first video is named <a href="https://www.youtube.com/watch?v=OPuztQfM3Fg&amp;t=2524s&amp;ab_channel=TheVimeagen">“Trying Zig Part 1”</a><a href="#fn19" class="footnote-ref" id="fnref19" role="doc-noteref"><sup>19</sup></a>.</p>
<p>Another great alternative, is to solve the <a href="https://adventofcode.com/">Advent of Code exercises</a><a href="#fn20" class="footnote-ref" id="fnref20" role="doc-noteref"><sup>20</sup></a>. There are people that already took the time to learn and solve the exercises, and they posted their solutions on GitHub as well, so, in case you need some resource to compare while solving the exercises, you can look at these two repositories:</p>
<ul>
<li><a href="https://github.com/SpexGuy/Zig-AoC-Template" class="uri">https://github.com/SpexGuy/Zig-AoC-Template</a>;</li>
<li><a href="https://github.com/fjebaker/advent-of-code-2022" class="uri">https://github.com/fjebaker/advent-of-code-2022</a>;</li>
</ul>
</section>
<section id="sec-assignments" class="level2" data-number="1.4">
<h2 data-number="1.4" class="anchored" data-anchor-id="sec-assignments"><span class="header-section-number">1.4</span> Creating new objects in Zig (i.e., identifiers)</h2>
<p>Let’s talk more about objects in Zig. Readers that have past experience with other programming languages might know this concept through a different name, such as: “variable” or “identifier”. In this book, I choose to use the term “object” to refer to this concept.</p>
<p>To create a new object (or a new “identifier”) in Zig, we use the keywords <code>const</code> or <code>var</code>. These keywords specify if the object that you are creating is mutable or not. If you use <code>const</code>, then the object you are creating is a constant (or immutable) object, which means that once you declare this object, you can no longer change the value stored inside this object.</p>
<p>On the other side, if you use <code>var</code>, then, you are creating a variable (or mutable) object. You can change the value of this object as many times you want. Using the keyword <code>var</code> in Zig is similar to using the keywords <code>let mut</code> in Rust.</p>
<section id="constant-objects-vs-variable-objects" class="level3" data-number="1.4.1">
<h3 data-number="1.4.1" class="anchored" data-anchor-id="constant-objects-vs-variable-objects"><span class="header-section-number">1.4.1</span> Constant objects vs variable objects</h3>
<p>In the code example below, we are creating a new constant object called <code>age</code>. This object stores a number representing the age of someone. However, this code example does not compile successfully. Because on the next line of code, we are trying to change the value of the object <code>age</code> to 25.</p>
<p>The <code>zig</code> compiler detects that we are trying to change the value of an object/identifier that is constant, and because of that, the compiler will raise a compilation error, warning us about the mistake.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> age = <span class="dv">24</span>;</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="co">// The line below is not valid!</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>age = <span class="dv">25</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>t.zig:10:5: error: cannot assign to constant
    age = 25;
      ~~^~~</code></pre>
<p>So, if you want to change the value of your object, you need to transform your immutable (or “constant”) object into a mutable (or “variable”) object. You can do that by using the <code>var</code> keyword. This keyword stands for “variable”, and when you apply this keyword to some object, you are telling the Zig compiler that the value associated with this object might change at some point.</p>
<p>Thus, if we come back to the previous example, and change the declaration of the <code>age</code> object to use the <code>var</code> keyword, then, the program gets compiled successfully. Because now, the <code>zig</code> compiler detects that we are changing the value of an object that allows this behaviour, because it’s a “variable object”.</p>
<p>However, if you take a look at the example below, you will notice that we have not only declared the <code>age</code> object with the <code>var</code> keyword, but we also have explicitly annotated the data type of the <code>age</code> object with the <code>u8</code> type this time. The basic idea is, when we use a variable/mutable object, the Zig compiler ask for us to be more explicit with what we want, to be more clear about what our code does. This translates into being more explicit about the data types that we want to use in our objects.</p>
<p>Therefore, if you transform your object into a variable/mutable object, just remember to always annotate the type of the object explicitly in your code. Otherwise, the Zig compiler might raise a compilation error, asking you to transform your object back into a <code>const</code> object, or, to give your object an “explicit type”.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> age: <span class="dt">u8</span> = <span class="dv">24</span>;</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>age = <span class="dv">25</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="declaring-without-an-initial-value" class="level3" data-number="1.4.2">
<h3 data-number="1.4.2" class="anchored" data-anchor-id="declaring-without-an-initial-value"><span class="header-section-number">1.4.2</span> Declaring without an initial value</h3>
<p>By default, when you declare a new object in Zig, you must give it an initial value. In other words, this means that we have to declare, and, at the same time, initialize every object we create in our source code.</p>
<p>On the other hand, you can, in fact, declare a new object in your source code, and not give it an explicit value. But we need to use a special keyword for that, which is the <code>undefined</code> keyword.</p>
<p>It’s important to emphasize that, you should avoid using <code>undefined</code> as much as possible. Because when you use this keyword, you leave your object uninitialized, and, as a consequence, if for some reason, your code uses this object while it’s uninitialized, then, you will definitely have undefined behaviour and major bugs in your program.</p>
<p>In the example below, I’m declaring the <code>age</code> object again. But this time, I do not give it an initial value. The variable is only initialized at the second line of code, where I store the number 25 in this object.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> age: <span class="dt">u8</span> = <span class="cn">undefined</span>;</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>age = <span class="dv">25</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Having these points in mind, just remember that you should avoid as much as possible to use <code>undefined</code> in your code. Always declare and initialize your objects. Because this gives you much more safety in your program. But in case you really need to declare an object without initializing it… the <code>undefined</code> keyword is the way to do it in Zig.</p>
</section>
<section id="there-is-no-such-thing-as-unused-objects" class="level3" data-number="1.4.3">
<h3 data-number="1.4.3" class="anchored" data-anchor-id="there-is-no-such-thing-as-unused-objects"><span class="header-section-number">1.4.3</span> There is no such thing as unused objects</h3>
<p>Every object (being constant or variable) that you declare in Zig <strong>must be used in some way</strong>. You can give this object to a function call, as a function argument, or, you can use it in another expression to calculate the value of another object, or, you can call a method that belongs to this particular object.</p>
<p>It doesn’t matter in which way you use it. As long as you use it. If you try to break this rule, i.e., if your try to declare a object, but not use it, the <code>zig</code> compiler will not compile your Zig source code, and it will issue a error message warning that you have unused objects in your code.</p>
<p>Let’s demonstrate this with an example. In the source code below, we declare a constant object called <code>age</code>. If you try to compile a simple Zig program with this line of code below, the compiler will return an error as demonstrated below:</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> age = <span class="dv">15</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>t.zig:4:11: error: unused local constant
    const age = 15;
          ^~~</code></pre>
<p>Everytime you declare a new object in Zig, you have two choices:</p>
<ol type="1">
<li>you either use the value of this object;</li>
<li>or you explicitly discard the value of the object;</li>
</ol>
<p>To explicitly discard the value of any object (constant or variable), all you need to do is to assign this object to a special character in Zig, which is the underscore (<code>_</code>). When you assign an object to a underscore, like in the example below, the <code>zig</code> compiler will automatically discard the value of this particular object.</p>
<p>You can see in the example below that, this time, the compiler did not complain about any “unused constant”, and successfully compiled our source code.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co">// It compiles!</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> age = <span class="dv">15</span>;</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>_ = age;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Now, remember, everytime you assign a particular object to the underscore, this object is essentially destroyed. It’s discarded by the compiler. This means that you can no longer use this object further in your code. It doesn’t exist anymore.</p>
<p>So if you try to use the constant <code>age</code> in the example below, after we discarded it, you will get a loud error message from the compiler (talking about a “pointless discard”) warning you about this mistake.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co">// It does not compile.</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> age = <span class="dv">15</span>;</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>_ = age;</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Using a discarded value!</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>std.debug.print(<span class="st">"{d}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span>age + <span class="dv">2</span><span class="op">}</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>t.zig:7:5: error: pointless discard
    of local constant</code></pre>
<p>This same rule applies to variable objects. Every variable object must also be used in some way. And if you assign a variable object to the underscore, this object also gets discarded, and you can no longer use this object.</p>
</section>
<section id="you-must-mutate-every-variable-objects" class="level3" data-number="1.4.4">
<h3 data-number="1.4.4" class="anchored" data-anchor-id="you-must-mutate-every-variable-objects"><span class="header-section-number">1.4.4</span> You must mutate every variable objects</h3>
<p>Every variable object that you create in your source code must be mutated at some point. In other words, if you declare an object as a variable object, with the keyword <code>var</code>, and you do not change the value of this object at some point in the future, the <code>zig</code> compiler will detect this, and it will raise an error warning you about this mistake.</p>
<p>The concept behind this is that every object you create in Zig should be preferably a constant object, unless you really need an object whose value will change during the execution of your program.</p>
<p>So, if I try to declare a variable object such as <code>where_i_live</code> below, and I do not change the value of this object in some way, the <code>zig</code> compiler raises an error message with the phrase “variable is never mutated”.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> where_i_live = <span class="st">"Belo Horizonte"</span>;</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>_ = where_i_live;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>t.zig:7:5: error: local variable is never mutated
t.zig:7:5: note: consider using 'const'</code></pre>
</section>
</section>
<section id="sec-primitive-data-types" class="level2" data-number="1.5">
<h2 data-number="1.5" class="anchored" data-anchor-id="sec-primitive-data-types"><span class="header-section-number">1.5</span> Primitive Data Types</h2>
<p>Zig has many different primitive data types available for you to use. You can see the full list of available data types at the official <a href="https://ziglang.org/documentation/master/#Primitive-Types">Language Reference page</a><a href="#fn21" class="footnote-ref" id="fnref21" role="doc-noteref"><sup>21</sup></a>.</p>
<p>But here is a quick list:</p>
<ul>
<li>Unsigned integers: <code>u8</code>, 8-bit integer; <code>u16</code>, 16-bit integer; <code>u32</code>, 32-bit integer; <code>u64</code>, 64-bit integer; <code>u128</code>, 128-bit integer.</li>
<li>Signed integers: <code>i8</code>, 8-bit integer; <code>i16</code>, 16-bit integer; <code>i32</code>, 32-bit integer; <code>i64</code>, 64-bit integer; <code>i128</code>, 128-bit integer.</li>
<li>Float number: <code>f16</code>, 16-bit floating point; <code>f32</code>, 32-bit floating point; <code>f64</code>, 64-bit floating point; <code>f128</code>, 128-bit floating point;</li>
<li>Boolean: <code>bool</code>, represents true or false values.</li>
<li>C ABI compatible types: <code>c_long</code>, <code>c_char</code>, <code>c_short</code>, <code>c_ushort</code>, <code>c_int</code>, <code>c_uint</code>, and many others.</li>
<li>Pointer sized integers: <code>isize</code> and <code>usize</code>.</li>
</ul>
</section>
<section id="sec-arrays" class="level2" data-number="1.6">
<h2 data-number="1.6" class="anchored" data-anchor-id="sec-arrays"><span class="header-section-number">1.6</span> Arrays</h2>
<p>You create arrays in Zig by using a syntax that resembles the C syntax. First, you specify the size of the array (i.e., the number of elements that will be stored in the array) you want to create inside a pair of brackets.</p>
<p>Then, you specify the data type of the elements that will be stored inside this array. All elements present in an array in Zig must have the same data type. For example, you cannot mix elements of type <code>f32</code> with elements of type <code>i32</code> in the same array.</p>
<p>After that, you simply list the values that you want to store in this array inside a pair of curly braces. In the example below, I am creating two constant objects that contain different arrays. The first object contains an array of 4 integer values, while the second object, an array of 3 floating point values.</p>
<p>Now, you should notice that in the object <code>ls</code>, I am not explicitly specifying the size of the array inside of the brackets. Instead of using a literal value (like the value 4 that I used in the <code>ns</code> object), I am using the special character underscore (<code>_</code>). This syntax tells the <code>zig</code> compiler to fill this field with the number of elements listed inside of the curly braces. So, this syntax <code>[_]</code> is for lazy (or smart) programmers who leave the job of counting how many elements there are in the curly braces for the compiler.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> ns = [<span class="dv">4</span>]<span class="dt">u8</span><span class="op">{</span><span class="dv">48</span>, <span class="dv">24</span>, <span class="dv">12</span>, <span class="dv">6</span><span class="op">}</span>;</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> ls = [_]<span class="dt">f64</span><span class="op">{</span><span class="fl">432.1</span>, <span class="fl">87.2</span>, <span class="fl">900.05</span><span class="op">}</span>;</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>_ = ns; _ = ls;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>It’s worth noting that these are static arrays, meaning that they cannot grow in size. Once you declare your array, you cannot change the size of it. This is very common in low level languages. Because low level languages normally wants to give you (the programmer) full control over memory, and the way in which arrays are expanded is tightly related to memory management.</p>
<section id="sec-select-array-elem" class="level3" data-number="1.6.1">
<h3 data-number="1.6.1" class="anchored" data-anchor-id="sec-select-array-elem"><span class="header-section-number">1.6.1</span> Selecting elements of the array</h3>
<p>One very common activity is to select specific portions of an array you have in your source code. In Zig, you can select a specific element from your array, by simply providing the index of this particular element inside brackets after the object name. In the example below, I am selecting the third element from the <code>ns</code> array. Notice that Zig is a “zero-index” based language, like C, C++, Rust, Python, and many other languages.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> ns = [<span class="dv">4</span>]<span class="dt">u8</span><span class="op">{</span><span class="dv">48</span>, <span class="dv">24</span>, <span class="dv">12</span>, <span class="dv">6</span><span class="op">}</span>;</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="kw">try</span> stdout.print(<span class="st">"{d}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span> ns[<span class="dv">2</span>] <span class="op">}</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>12</code></pre>
</div>
</div>
<p>In contrast, you can also select specific slices (or sections) of your array, by using a range selector. Some programmers also call these selectors of “slice selectors”, and they also exist in Rust, and have the exact same syntax as in Zig. Anyway, a range selector is a special expression in Zig that defines a range of indexes, and it has the syntax <code>start..end</code>.</p>
<p>In the example below, at the second line of code, the <code>sl</code> object stores a slice (or a portion) of the <code>ns</code> array. More precisely, the elements at index 1 and 2 in the <code>ns</code> array.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> ns = [<span class="dv">4</span>]<span class="dt">u8</span><span class="op">{</span><span class="dv">48</span>, <span class="dv">24</span>, <span class="dv">12</span>, <span class="dv">6</span><span class="op">}</span>;</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> sl = ns[<span class="dv">1</span>..<span class="dv">3</span>];</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>_ = sl;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>When you use the <code>start..end</code> syntax, the “end tail” of the range selector is non-inclusive, meaning that, the index at the end is not included in the range that is selected from the array. Therefore, the syntax <code>start..end</code> actually means <code>start..end - 1</code> in practice.</p>
<p>You can for example, create a slice that goes from the first to the last elements of the array, by using <code>ar[0..ar.len]</code> syntax In other words, it’s a slice that accesses all elements in the array.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> ar = [<span class="dv">4</span>]<span class="dt">u8</span><span class="op">{</span><span class="dv">48</span>, <span class="dv">24</span>, <span class="dv">12</span>, <span class="dv">6</span><span class="op">}</span>;</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> sl = ar[<span class="dv">0</span>..ar.len];</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>_ = sl;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>You can also use the syntax <code>start..</code> in your range selector. Which tells the <code>zig</code> compiler to select the portion of the array that begins at the <code>start</code> index until the last element of the array. In the example below, we are selecting the range from index 1 until the end of the array.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> ns = [<span class="dv">4</span>]<span class="dt">u8</span><span class="op">{</span><span class="dv">48</span>, <span class="dv">24</span>, <span class="dv">12</span>, <span class="dv">6</span><span class="op">}</span>;</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> sl = ns[<span class="dv">1</span>..];</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>_ = sl;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="more-on-slices" class="level3" data-number="1.6.2">
<h3 data-number="1.6.2" class="anchored" data-anchor-id="more-on-slices"><span class="header-section-number">1.6.2</span> More on slices</h3>
<p>As we discussed before, in Zig, you can select specific portions of an existing array. This is called <em>slicing</em> in Zig <span class="citation" data-cites="zigguide">(<a href="../references.html#ref-zigguide" role="doc-biblioref">Sobeston 2024</a>)</span>, because when you select a portion of an array, you are creating a slice object from that array.</p>
<p>A slice object is essentially a pointer object accompanied by a length number. The pointer object points to the first element in the slice, and the length number tells the <code>zig</code> compiler how many elements there are in this slice.</p>
<blockquote class="blockquote">
<p>Slices can be thought of as a pair of <code>[*]T</code> (the pointer to the data) and a <code>usize</code> (the element count) <span class="citation" data-cites="zigguide">(<a href="../references.html#ref-zigguide" role="doc-biblioref">Sobeston 2024</a>)</span>.</p>
</blockquote>
<p>Through the pointer contained inside the slice you can access the elements (or values) that are inside this range (or portion) that you selected from the original array. But the length number (which you can access through the <code>len</code> property of your slice object) is the really big improvement (over C arrays for example) that Zig brings to the table here.</p>
<p>Because with this length number the <code>zig</code> compiler can easily check if you are trying to access an index that is out of the bounds of this particular slice, or, if you are causing any buffer overflow problems. In the example below, we access the <code>len</code> property of the slice <code>sl</code>, which tells us that this slice has 2 elements in it.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> ns = [<span class="dv">4</span>]<span class="dt">u8</span><span class="op">{</span><span class="dv">48</span>, <span class="dv">24</span>, <span class="dv">12</span>, <span class="dv">6</span><span class="op">}</span>;</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> sl = ns[<span class="dv">1</span>..<span class="dv">3</span>];</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="kw">try</span> stdout.print(<span class="st">"{d}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span>sl.len<span class="op">}</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>2</code></pre>
</div>
</div>
</section>
<section id="array-operators" class="level3" data-number="1.6.3">
<h3 data-number="1.6.3" class="anchored" data-anchor-id="array-operators"><span class="header-section-number">1.6.3</span> Array operators</h3>
<p>There are two array operators available in Zig that are very useful. The array concatenation operator (<code>++</code>), and the array multiplication operator (<code>**</code>). As the name suggests, these are array operators.</p>
<p>One important detail about these two operators is that they work only when both operands have a size (or “length”) that is compile-time known. We are going to talk more about the differences between “compile-time known” and “runtime known” in <a href="01-memory.html#sec-compile-time" class="quarto-xref"><span>Section 3.1.1</span></a>. But for now, keep this information in mind, that you cannot use these operators in every situation.</p>
<p>In summary, the <code>++</code> operator creates a new array that is the concatenation, of both arrays provided as operands. So, the expression <code>a ++ b</code> produces a new array which contains all the elements from arrays <code>a</code> and <code>b</code>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> a = [_]<span class="dt">u8</span><span class="op">{</span><span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span><span class="op">}</span>;</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> b = [_]<span class="dt">u8</span><span class="op">{</span><span class="dv">4</span>,<span class="dv">5</span><span class="op">}</span>;</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> c = a ++ b;</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="kw">try</span> stdout.print(<span class="st">"{any}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span>c<span class="op">}</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>{ 1, 2, 3, 4, 5 }</code></pre>
</div>
</div>
<p>This <code>++</code> operator is particularly useful to concatenate strings together. Strings in Zig are described in depth in <a href="#sec-zig-strings" class="quarto-xref"><span>Section 1.8</span></a>. In summary, a string object in Zig is essentially an arrays of bytes. So, you can use this array concatenation operator to effectively concatenate strings together.</p>
<p>In contrast, the <code>**</code> operator is used to replicate an array multiple times. In other words, the expression <code>a ** 3</code> creates a new array which contains the elements of the array <code>a</code> repeated 3 times.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> a = [_]<span class="dt">u8</span><span class="op">{</span><span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span><span class="op">}</span>;</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> c = a ** <span class="dv">2</span>;</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="kw">try</span> stdout.print(<span class="st">"{any}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span>c<span class="op">}</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>{ 1, 2, 3, 1, 2, 3 }</code></pre>
</div>
</div>
</section>
<section id="runtime-versus-compile-time-known-length-in-slices" class="level3" data-number="1.6.4">
<h3 data-number="1.6.4" class="anchored" data-anchor-id="runtime-versus-compile-time-known-length-in-slices"><span class="header-section-number">1.6.4</span> Runtime versus compile-time known length in slices</h3>
<p>We are going to talk a lot about the differences between compile-time known and runtime known across this book, especially in <a href="01-memory.html#sec-compile-time" class="quarto-xref"><span>Section 3.1.1</span></a>. But the basic idea is that a thing is compile-time known, when we know everything (the value, the attributes and the characteristics) about this thing at compile-time. In contrast, a runtime known thing is when the exact value of a thing is calculated only at runtime. Therefore, we don’t know the value of this thing at compile-time, only at runtime.</p>
<p>We have learned in <a href="#sec-select-array-elem" class="quarto-xref"><span>Section 1.6.1</span></a> that slices are created by using a <em>range selector</em>, which represents a range of indexes. When this “range of indexes” (i.e., both the start and the end of this range) is known at compile-time, the slice object that gets created is actually, under the hood, just a single-item pointer to an array.</p>
<p>You don’t need to precisely understand what that means now. We are going to talk a lot about pointers in <a href="05-pointers.html" class="quarto-xref"><span>Chapter 6</span></a>. For now, just understand that, when the range of indexes is known at compile-time, the slice that gets created is just a pointer to an array, accompanied by a length value that tells the size of the slice.</p>
<p>If you have a slice object like this, i.e., a slice that has a compile-time known range, you can use common pointer operations over this slice object. For example, you can dereference the pointer of this slice, by using the <code>.*</code> method, like you would do on a normal pointer object.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> arr1 = [<span class="dv">10</span>]<span class="dt">u64</span> <span class="op">{</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>,</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>    <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">10</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a><span class="co">// This slice has a compile-time known range.</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Because we know both the start and end of the range.</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> slice = arr1[<span class="dv">1</span>..<span class="dv">4</span>];</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>_ = slice;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>On the other hand, if the range of indexes is not known at compile time, then, the slice object that gets created is not a pointer anymore, and, thus, it does not support pointer operations. For example, maybe the start index is known at compile time, but the end index is not. In such case, the range of the slice becomes runtime known only.</p>
<p>In the example below, we are reading a file, and then, we try to create a slice object that covers the entire buffer that contains the contents of this file. This is obviously an example of a runtime known range, because the end index of the range is not known at compile time.</p>
<p>In other words, the end index of the range is the size of the array <code>file_contents</code>. However, the size of <code>file_contents</code> is not known at compile time. Because we don’t know how many bytes are stored inside this <code>shop-list.txt</code> file. And because this is a file, someone might edit this file tomorrow and add more lines or remove lines from it. Therefore, the size of this file might vary drastically from one execution to another.</p>
<p>Now, if the file size can vary from one run to another, then, we can conclude that the value of the expression <code>file_contents.len</code> exposed in the example below can also vary from one run to another. As consequence, the value of the expression <code>file_contents.len</code> is runtime-known only, and, as a consequence of that, the range <code>0..file_contents.len</code> is also runtime-known only.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> builtin = <span class="bu">@import</span>(<span class="st">"builtin"</span>);</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> read_file(allocator: std.mem.Allocator, path: []<span class="kw">const</span> <span class="dt">u8</span>) ![]<span class="dt">u8</span> <span class="op">{</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> file = <span class="kw">try</span> std.fs.cwd().openFile(path, .<span class="op">{}</span>);</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">defer</span> file.close();</span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="kw">try</span> file.reader().readAllAlloc(</span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>        allocator, std.math.maxInt(<span class="dt">usize</span>)</span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>    );</span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> gpa = std.heap.GeneralPurposeAllocator(.<span class="op">{}</span>)<span class="op">{}</span>;</span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> allocator = gpa.allocator();</span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> path = <span class="st">"../ZigExamples/file-io/shop-list.txt"</span>;</span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> file_contents = <span class="kw">try</span> read_file(allocator, path);</span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> slice = file_contents[<span class="dv">0</span>..file_contents.len];</span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a>    _ = slice;</span>
<span id="cb45-19"><a href="#cb45-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="sec-blocks" class="level2" data-number="1.7">
<h2 data-number="1.7" class="anchored" data-anchor-id="sec-blocks"><span class="header-section-number">1.7</span> Blocks and scopes</h2>
<p>Blocks are created in Zig by a pair of curly braces. A block is just a group of expressions (or statements) contained inside of a pair of curly braces. All of these expressions that are contained inside of this pair of curly braces belongs to the same scope.</p>
<p>In other words, a block just delimits a scope in your code. The objects that you define inside the same block belongs to the same scope, and, therefore, are accessible from within this scope. At the same time, these objects are not accessible outside of this scope. So, you could also say that blocks are used to limit the scope of the objects that you create in your source code. In less technical terms, blocks are used to specify where in your source code you can access whatever object you have in your source code.</p>
<p>So, a block is just a group of expressions contained inside a pair of curly braces. And every block have its own scope separated from the others. The body of a function is a classic example of a block. If statements, for and while loops (and any other structure in the language that uses the pair of curly braces) are also examples of blocks.</p>
<p>This means that, every if statement, or for loop, etc., that you create in your source code has its own separate scope. That is why you can’t access the objects that you defined inside of your for loop (or if statement) in an outer scope, i.e., a scope outside of the for loop. Because you are trying to access an object that belongs to a scope that is different than your current scope.</p>
<p>You can create blocks within blocks, with multiple levels of nesting. You can also (if you want to) give a label to a particular block, with the colon character (<code>:</code>). Just write <code>label:</code> before you open the pair of curly braces that delimits your block. When you label a block in Zig, you can use the <code>break</code> keyword to return a value from this block, like as if it was a function’s body. You just write the <code>break</code> keyword, followed by the block label in the format <code>:label</code>, and the expression that defines the value that you want to return.</p>
<p>Like in the example below, where we are returning the value from the <code>y</code> object from the block <code>add_one</code>, and saving the result inside the <code>x</code> object.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> y: <span class="dt">i32</span> = <span class="dv">123</span>;</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> x = add_one: <span class="op">{</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>    y += <span class="dv">1</span>;</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">break</span> :add_one y;</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> (x == <span class="dv">124</span> <span class="kw">and</span> y == <span class="dv">124</span>) <span class="op">{</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> stdout.print(<span class="st">"Hey!"</span>, .<span class="op">{}</span>);</span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Hey!</code></pre>
</div>
</div>
</section>
<section id="sec-zig-strings" class="level2" data-number="1.8">
<h2 data-number="1.8" class="anchored" data-anchor-id="sec-zig-strings"><span class="header-section-number">1.8</span> How strings work in Zig?</h2>
<p>The first project that we are going to build and discuss in this book is a base64 encoder/decoder (<a href="01-base64.html" class="quarto-xref"><span>Chapter 4</span></a>). But in order for us to build such a thing, we need to get a better understanding on how strings work in Zig. So let’s discuss this specific aspect of Zig.</p>
<p>Strings in Zig work very similarly to strings in C, but they come with some extra caveats which adds more safety and efficiency to them. You could also say that Zig simply uses a more modern and safe approach to manage and use strings.</p>
<p>A string in Zig is essentially an array of arbitrary bytes, or, more specifically, an array of <code>u8</code> values. This very similar to a string in C, which is also interpreted as an array of arbitrary bytes, or, in the case of C, an array of <code>char</code> (which usually represents an unsigned 8-bit integer value in most systems) values.</p>
<p>Now, because a string in Zig is an array, you automatically get the length of the string (i.e.&nbsp;the length of the array) embedded in the value itself. This makes all the difference! Because now, the Zig compiler can use the length value that is embedded in the string to check for “buffer overflow” or “wrong memory access” problems in your code.</p>
<p>To achieve this same kind of safety in C, you have to do a lot of work that kind of seems pointless. So getting this kind of safety is not automatic and much harder to do in C. For example, if you want to track the length of your string throughout your program in C, then, you first need to loop through the array of bytes that represents this string, and find the null element (<code>'\0'</code>) position to discover where exactly the array ends, or, in other words, to find how much elements the array of bytes contain.</p>
<p>To do that, you would need to do something like this in C. In this example, the C string stored in the object <code>array</code> is 25 bytes long:</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span><span class="op">*</span> array <span class="op">=</span> <span class="st">"An example of string in C"</span><span class="op">;</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> index <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>array<span class="op">[</span>index<span class="op">]</span> <span class="op">==</span> <span class="ch">'</span><span class="sc">\0</span><span class="ch">'</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>        index<span class="op">++;</span></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Number of elements in the array: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> index<span class="op">);</span></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>Number of elements in the array: 25</code></pre>
<p>You don’t have this kind of work in Zig. Because the length of the string is always present and accessible in the string value itself. You can easily access the length of the string through the <code>len</code> attribute. As an example, the <code>string_object</code> object below is 43 bytes long:</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> stdout = std.io.getStdOut().writer();</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> string_object = <span class="st">"This is an example of string literal in Zig"</span>;</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> stdout.print(<span class="st">"{d}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span>string_object.len<span class="op">}</span>);</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>43</code></pre>
</div>
</div>
<p>Another point is that Zig always assumes that the sequence of bytes in your string is UTF-8 encoded. This might not be true for every sequence of bytes you’re working with, but is not really Zig’s job to fix the encoding of your strings (you can use <a href="https://www.gnu.org/software/libiconv/"><code>iconv</code></a><a href="#fn22" class="footnote-ref" id="fnref22" role="doc-noteref"><sup>22</sup></a> for that). Today, most of the text in our modern world, especially on the web, should be UTF-8 encoded. So if your string literal is not UTF-8 encoded, then, you will likely have problems in Zig.</p>
<p>Let’s take for example the word “Hello”. In UTF-8, this sequence of characters (H, e, l, l, o) is represented by the sequence of decimal numbers 72, 101, 108, 108, 111. In hexadecimal, this sequence is <code>0x48</code>, <code>0x65</code>, <code>0x6C</code>, <code>0x6C</code>, <code>0x6F</code>. So if I take this sequence of hexadecimal values, and ask Zig to print this sequence of bytes as a sequence of characters (i.e., a string), then, the text “Hello” will be printed into the terminal:</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> stdout = std.io.getStdOut().writer();</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> bytes = [_]<span class="dt">u8</span><span class="op">{</span><span class="bn">0x48</span>, <span class="bn">0x65</span>, <span class="bn">0x6C</span>, <span class="bn">0x6C</span>, <span class="bn">0x6F</span><span class="op">}</span>;</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> stdout.print(<span class="st">"{s}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span>bytes<span class="op">}</span>);</span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Hello</code></pre>
</div>
</div>
<section id="using-a-slice-versus-a-sentinel-terminated-array" class="level3" data-number="1.8.1">
<h3 data-number="1.8.1" class="anchored" data-anchor-id="using-a-slice-versus-a-sentinel-terminated-array"><span class="header-section-number">1.8.1</span> Using a slice versus a sentinel-terminated array</h3>
<p>In memory, all string values in Zig are always stored in the same way. They are simply stored as sequences/arrays of arbitrary bytes. But you can use and access this sequence of bytes in two different ways. You can access this sequence of bytes as:</p>
<ul>
<li>a sentinel-terminated array of <code>u8</code> values.</li>
<li>or as a slice of <code>u8</code> values.</li>
</ul>
<section id="sentinel-terminated-arrays" class="level4" data-number="1.8.1.1">
<h4 data-number="1.8.1.1" class="anchored" data-anchor-id="sentinel-terminated-arrays"><span class="header-section-number">1.8.1.1</span> Sentinel-terminated arrays</h4>
<p>Sentinel-terminated arrays in Zig are described in the Language Reference of Zig<a href="#fn23" class="footnote-ref" id="fnref23" role="doc-noteref"><sup>23</sup></a>. In summary a sentinel-terminated array is just a normal array, but, the difference is that they contain a “sentinel value” at the last index/element of the array. With a sentinel-terminated array you embed both the length of the array, and also, the sentinel value in the type itself of your object.</p>
<p>For example, if you write a string literal value in your code, and ask Zig to print the data type of this value, you usually get a data type in the format <code>*const [n:0]u8</code>. The <code>n</code> in the data type indicates the size of the string (that is the length of the array). The zero after the <code>n:</code> part of the data type is the sentinel value itself.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="co">// This is a string literal value:</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>_ = <span class="st">"A literal value"</span>;</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="kw">try</span> stdout.print(<span class="st">"{any}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span><span class="bu">@TypeOf</span>(<span class="st">"A literal value"</span>)<span class="op">}</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>*const [15:0]u8</code></pre>
</div>
</div>
<p>So, with this data type <code>*const [n:0]u8</code> you are essentially saying that you have an array of <code>u8</code> values of length <code>n</code>, where, the element at the index corresponding to the length <code>n</code> in the array is the number zero. If you really think about this description, you will notice that this is just a fancy way to describe a string in C, which is a null-terminated array of bytes. The <code>NULL</code> value in C is the number zero. So, an array that ends in a null/zero value in C is essentially a sentinel-terminated array in Zig, where the sentinel value of the array is the number zero.</p>
<p>Therefore, a string literal value in Zig is just a pointer to a null-terminated array of bytes (i.e., similar to a C string). But in Zig, a string literal value also embeds the length of the string, and also, the fact that they are “NULL terminated”, into the data type of the value itself.</p>
</section>
<section id="slice" class="level4" data-number="1.8.1.2">
<h4 data-number="1.8.1.2" class="anchored" data-anchor-id="slice"><span class="header-section-number">1.8.1.2</span> Slice</h4>
<p>You can also access and use the arbitrary sequence of bytes that represent your string as a slice of <code>u8</code> values. The majority of functions from the Zig standard library usually receive strings as inputs as slices of <code>u8</code> values (slices were presented in <a href="#sec-arrays" class="quarto-xref"><span>Section 1.6</span></a>).</p>
<p>Thus, you will see a lot of string values with a data type of <code>[]u8</code> or <code>[]const u8</code>, depending if the object where this string is stored is marked as constant with <code>const</code>, or as variable with <code>var</code>. Now, because the string in this case is being interpreted as a slice, this slice is not necessarilly null-terminated, because now, the sentinel value is not mandatory. You can include the null/zero value in the slice if you want to, but there is no need to do it.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="co">// This is a string value being</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="co">// interpreted as a slice.</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> str: []<span class="kw">const</span> <span class="dt">u8</span> = <span class="st">"A string value"</span>;</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a><span class="kw">try</span> stdout.print(<span class="st">"{any}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span><span class="bu">@TypeOf</span>(str)<span class="op">}</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[]const u8</code></pre>
</div>
</div>
</section>
</section>
<section id="iterating-through-the-string" class="level3" data-number="1.8.2">
<h3 data-number="1.8.2" class="anchored" data-anchor-id="iterating-through-the-string"><span class="header-section-number">1.8.2</span> Iterating through the string</h3>
<p>If you want to see the actual bytes that represents a string in Zig, you can use a <code>for</code> loop to iterate through each byte in the string, and ask Zig to print each byte as an hexadecimal value to the terminal. You do that by using a <code>print()</code> statement with the <code>X</code> formatting specifier, like you would normally do with the <a href="https://cplusplus.com/reference/cstdio/printf/"><code>printf()</code> function</a><a href="#fn24" class="footnote-ref" id="fnref24" role="doc-noteref"><sup>24</sup></a> in C.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> stdout = std.io.getStdOut().writer();</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> string_object = <span class="st">"This is an example"</span>;</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> stdout.print(<span class="st">"Bytes that represents the string object: "</span>, .<span class="op">{}</span>);</span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span> (string_object) |byte| <span class="op">{</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">try</span> stdout.print(<span class="st">"{X} "</span>, .<span class="op">{</span>byte<span class="op">}</span>);</span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> stdout.print(<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{}</span>);</span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Bytes that represents the string object: 54 68 69 
   73 20 69 73 20 61 6E 20 65 78 61 6D 70 6C 65 </code></pre>
</div>
</div>
</section>
<section id="a-better-look-at-the-object-type" class="level3" data-number="1.8.3">
<h3 data-number="1.8.3" class="anchored" data-anchor-id="a-better-look-at-the-object-type"><span class="header-section-number">1.8.3</span> A better look at the object type</h3>
<p>Now, we can inspect better the type of objects that Zig create. To check the type of any object in Zig, you can use the <code>@TypeOf()</code> function. If we look at the type of the <code>simple_array</code> object below, you will find that this object is an array of 4 elements. Each element is a signed integer of 32 bits which corresponds to the data type <code>i32</code> in Zig. That is what an object of type <code>[4]i32</code> is.</p>
<p>But if we look closely at the type of the string literal value exposed below, you will find that this object is a constant pointer (hence the <code>*const</code> annotation) to an array of 16 elements (or 16 bytes). Each element is a single byte (more precisely, an unsigned 8 bit integer - <code>u8</code>), that is why we have the <code>[16:0]u8</code> portion of the type below, and also, you can see that this is a null-terminated array, because of the zero value after the <code>:</code> character in the data type. In other words, the string literal value exposed below is 16 bytes long.</p>
<p>Now, if we create an pointer to the <code>simple_array</code> object, then, we get a constant pointer to an array of 4 elements (<code>*const [4]i32</code>), which is very similar to the type of the string literal value. This demonstrates that a string literal value in Zig is already a pointer to a null-terminated array of bytes.</p>
<p>Furthermore, if we take a look at the type of the <code>string_obj</code> object, you will see that it’s a slice object (hence the <code>[]</code> portion of the type) to a sequence of constant <code>u8</code> values (hence the <code>const u8</code> portion of the type).</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> simple_array = [_]<span class="dt">i32</span><span class="op">{</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span><span class="op">}</span>;</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> string_obj: []<span class="kw">const</span> <span class="dt">u8</span> = <span class="st">"A string object"</span>;</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>    std.debug.print(</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Type 1: {}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span><span class="bu">@TypeOf</span>(simple_array)<span class="op">}</span></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>    );</span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>    std.debug.print(</span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Type 2: {}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span><span class="bu">@TypeOf</span>(<span class="st">"A string literal"</span>)<span class="op">}</span></span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a>    );</span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a>    std.debug.print(</span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Type 3: {}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span><span class="bu">@TypeOf</span>(&amp;simple_array)<span class="op">}</span></span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true" tabindex="-1"></a>    );</span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true" tabindex="-1"></a>    std.debug.print(</span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Type 4: {}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span><span class="bu">@TypeOf</span>(string_obj)<span class="op">}</span></span>
<span id="cb60-16"><a href="#cb60-16" aria-hidden="true" tabindex="-1"></a>    );</span>
<span id="cb60-17"><a href="#cb60-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>Type 1: [4]i32
Type 2: *const [16:0]u8
Type 3: *const [4]i32
Type 4: []const u8</code></pre>
</section>
<section id="byte-vs-unicode-points" class="level3" data-number="1.8.4">
<h3 data-number="1.8.4" class="anchored" data-anchor-id="byte-vs-unicode-points"><span class="header-section-number">1.8.4</span> Byte vs unicode points</h3>
<p>It’s important to point out that each byte in the array is not necessarily a single character. This fact arises from the difference between a single byte and a single unicode point.</p>
<p>The encoding UTF-8 works by assigning a number (which is called a unicode point) to each character in the string. For example, the character “H” is stored in UTF-8 as the decimal number 72. This means that the number 72 is the unicode point for the character “H”. Each possible character that can appear in a UTF-8 encoded string have its own unicode point.</p>
<p>For example, the Latin Capital Letter A With Stroke (Ⱥ) is represented by the number (or the unicode point) 570. However, this decimal number (570) is higher than the maximum number stored inside a single byte, which is 255. In other words, the maximum decimal number that can be represented with a single byte is 255. That is why, the unicode point 570 is actually stored inside the computer’s memory as the bytes <code>C8 BA</code>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> stdout = std.io.getStdOut().writer();</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> string_object = <span class="st">"Ⱥ"</span>;</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>    _ = <span class="kw">try</span> stdout.write(</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Bytes that represents the string object: "</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>    );</span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span> (string_object) |char| <span class="op">{</span></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">try</span> stdout.print(<span class="st">"{X} "</span>, .<span class="op">{</span>char<span class="op">}</span>);</span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Bytes that represents the string object: C8 BA </code></pre>
</div>
</div>
<p>This means that to store the character Ⱥ in an UTF-8 encoded string, we need to use two bytes together to represent the number 570. That is why the relationship between bytes and unicode points is not always 1 to 1. Each unicode point is a single character in the string, but not always a single byte corresponds to a single unicode point.</p>
<p>All of this means that if you loop through the elements of a string in Zig, you will be looping through the bytes that represents that string, and not through the characters of that string. In the Ⱥ example above, the for loop needed two iterations (instead of a single iteration) to print the two bytes that represents this Ⱥ letter.</p>
<p>Now, all english letters (or ASCII letters if you prefer) can be represented by a single byte in UTF-8. As a consequence, if your UTF-8 string contains only english letters (or ASCII letters), then, you are lucky. Because the number of bytes will be equal to the number of characters in that string. In other words, in this specific situation, the relationship between bytes and unicode points is 1 to 1.</p>
<p>But on the other side, if your string contains other types of letters… for example, you might be working with text data that contains, chinese, japanese or latin letters, then, the number of bytes necessary to represent your UTF-8 string will likely be much higher than the number of characters in that string.</p>
<p>If you need to iterate through the characters of a string, instead of its bytes, then, you can use the <code>std.unicode.Utf8View</code> struct to create an iterator that iterates through the unicode points of your string.</p>
<p>In the example below, we loop through the japanese characters “アメリカ”. Each of the four characters in this string is represented by three bytes. But the for loop iterates four times, one iteration for each character/unicode point in this string:</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> std = <span class="bu">@import</span>(<span class="st">"std"</span>);</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> stdout = std.io.getStdOut().writer();</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> main() !<span class="dt">void</span> <span class="op">{</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> utf8 = <span class="kw">try</span> std.unicode.Utf8View.init(<span class="st">"アメリカ"</span>);</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> iterator = utf8.iterator();</span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">while</span> (iterator.nextCodepointSlice()) |codepoint| <span class="op">{</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">try</span> stdout.print(</span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>            <span class="st">"got codepoint {}</span><span class="sc">\n</span><span class="st">"</span>,</span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>            .<span class="op">{</span>std.fmt.fmtSliceHexUpper(codepoint)<span class="op">}</span>,</span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a>        );</span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>got codepoint E382A2
got codepoint E383A1
got codepoint E383AA
got codepoint E382AB</code></pre>
</section>
<section id="sec-strings-useful-funs" class="level3" data-number="1.8.5">
<h3 data-number="1.8.5" class="anchored" data-anchor-id="sec-strings-useful-funs"><span class="header-section-number">1.8.5</span> Some useful functions for strings</h3>
<p>In this section, I just want to quickly describe some functions from the Zig Standard Library that are very useful to use when working with strings. Most notably:</p>
<ul>
<li><code>std.mem.eql()</code>: to compare if two strings are equal.</li>
<li><code>std.mem.splitScalar()</code>: to split a string into an array of substrings given a delimiter value.</li>
<li><code>std.mem.splitSequence()</code>: to split a string into an array of substrings given a substring delimiter.</li>
<li><code>std.mem.startsWith()</code>: to check if string starts with substring.</li>
<li><code>std.mem.endsWith()</code>: to check if string ends with substring.</li>
<li><code>std.mem.trim()</code>: to remove specific values from both start and end of the string.</li>
<li><code>std.mem.concat()</code>: to concatenate strings together.</li>
<li><code>std.mem.count()</code>: to count the occurrences of substring in the string.</li>
<li><code>std.mem.replace()</code>: to replace the occurrences of substring in the string.</li>
</ul>
<p>Notice that all of these functions come from the <code>mem</code> module of the Zig Standard Library. This module contains multiple functions and methods that are useful to work with memory and sequences of bytes in general.</p>
<p>The <code>eql()</code> function is used to check if two arrays of data are equal or not. Since strings are just arbitrary arrays of bytes, we can use this function to compare two strings together. This function returns a boolean value indicating if the two strings are equal or not. The first argument of this function is the data type of the elements of the arrays that are being compared.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> name: []<span class="kw">const</span> <span class="dt">u8</span> = <span class="st">"Pedro"</span>;</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="kw">try</span> stdout.print(</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"{any}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span>std.mem.eql(<span class="dt">u8</span>, name, <span class="st">"Pedro"</span>)<span class="op">}</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>true</code></pre>
</div>
</div>
<p>The <code>splitScalar()</code> and <code>splitSequence()</code> functions are useful to split a string into multiple fragments, like the <code>split()</code> method from Python strings. The difference between these two methods is that the <code>splitScalar()</code> uses a single character as the separator to split the string, while <code>splitSequence()</code> uses a sequence of characters (a.k.a. a substring) as the separator. There is a practical example of these functions later in the book.</p>
<p>The <code>startsWith()</code> and <code>endsWith()</code> functions are pretty straightforward. They return a boolean value indicating if the string (or, more precisely, if the array of data) begins (<code>startsWith</code>) or ends (<code>endsWith</code>) with the sequence provided.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> name: []<span class="kw">const</span> <span class="dt">u8</span> = <span class="st">"Pedro"</span>;</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a><span class="kw">try</span> stdout.print(</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"{any}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span>std.mem.startsWith(<span class="dt">u8</span>, name, <span class="st">"Pe"</span>)<span class="op">}</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>true</code></pre>
</div>
</div>
<p>The <code>concat()</code> function, as the name suggests, concatenate two or more strings together. Because the process of concatenating the strings involves allocating enough space to accomodate all the strings together, this <code>concat()</code> function receives an allocator object as input.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> str1 = <span class="st">"Hello"</span>;</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> str2 = <span class="st">" you!"</span>;</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> str3 = <span class="kw">try</span> std.mem.concat(</span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>    allocator, <span class="dt">u8</span>, &amp;[_][]<span class="kw">const</span> <span class="dt">u8</span><span class="op">{</span> str1, str2 <span class="op">}</span></span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a>);</span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a><span class="kw">try</span> stdout.print(<span class="st">"{s}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span>str3<span class="op">}</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>As you can imagine, the <code>replace()</code> function is used to replace substrings in a string by another substring. This function works very similarly to the <code>replace()</code> method from Python strings. Therefore, you provide a substring to search, and every time that the <code>replace()</code> function finds this substring within the input string, it replaces this substring with the “replacement substring” that you provided as input.</p>
<p>In the example below, we are taking the input string “Hello”, and replacing all occurrences of the substring “el” inside this input string with “34”, and saving the results inside the <code>buffer</code> object. As result, the <code>replace()</code> function returns an <code>usize</code> value that indicates how many replacements were performed.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode zig code-with-copy"><code class="sourceCode zig"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> str1 = <span class="st">"Hello"</span>;</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> buffer: [<span class="dv">5</span>]<span class="dt">u8</span> = <span class="cn">undefined</span>;</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> nrep = std.mem.replace(</span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">u8</span>, str1, <span class="st">"el"</span>, <span class="st">"34"</span>, buffer[<span class="dv">0</span>..]</span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>);</span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a><span class="kw">try</span> stdout.print(<span class="st">"New string: {s}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span>buffer<span class="op">}</span>);</span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a><span class="kw">try</span> stdout.print(<span class="st">"N of replacements: {d}</span><span class="sc">\n</span><span class="st">"</span>, .<span class="op">{</span>nrep<span class="op">}</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>New string: H34lo
N of replacements: 1</code></pre>
</section>
</section>
<section id="safety-in-zig" class="level2" data-number="1.9">
<h2 data-number="1.9" class="anchored" data-anchor-id="safety-in-zig"><span class="header-section-number">1.9</span> Safety in Zig</h2>
<p>A general trend in modern low-level programming languages is safety. As our modern world becomes more interconnected with technology and computers, the data produced by all of this technology becomes one of the most important (and also, one of the most dangerous) assets that we have.</p>
<p>This is probably the main reason why modern low-level programming languages have been giving great attention to safety, especially memory safety, because memory corruption is still the main target for hackers to exploit. The reality is that we don’t have an easy solution for this problem. For now, we only have techniques and strategies that mitigates these problems.</p>
<p>As Richard Feldman explains on his <a href="https://www.youtube.com/watch?v=jIZpKpLCOiU&amp;ab_channel=GOTOConferences">most recent GOTO conference talk</a><a href="#fn25" class="footnote-ref" id="fnref25" role="doc-noteref"><sup>25</sup></a> , we haven’t figured it out yet a way to achieve <strong>true safety in technology</strong>. In other words, we haven’t found a way to build software that won’t be exploited with 100% certainty. We can greatly reduce the risks of our software being exploited, by ensuring memory safety for example. But this is not enough to achieve “true safety” territory.</p>
<p>Because even if you write your program in a “safe language”, hackers can still exploit failures in the operating system where your program is running (e.g.&nbsp;maybe the system where your code is running has a “backdoor exploit” that can still affect your code in unexpected ways), or also, they can exploit the features from the architecture of your computer. A recently found exploit that involves memory invalidation through a feature of “memory tags” present in ARM chips is an example of that <span class="citation" data-cites="exploit1">(<a href="../references.html#ref-exploit1" role="doc-biblioref">Kim et al. 2024</a>)</span>.</p>
<p>The question is: what have Zig and other languages been doing to mitigate this problem? If we take Rust as an example, Rust is, for the most part<a href="#fn26" class="footnote-ref" id="fnref26" role="doc-noteref"><sup>26</sup></a>, a memory safe language by enforcing specific rules to the developer. In other words, the key feature of Rust, the <em>borrow checker</em>, forces you to follow a specific logic when you are writing your Rust code, and the Rust compiler will always complain everytime you try to go out of this pattern.</p>
<p>In contrast, the Zig language is not a memory safe language by default. There are some memory safety features that you get for free in Zig, especially in arrays and pointer objects. But there are other tools offered by the language, that are not used by default. In other words, the <code>zig</code> compiler does not obligate you to use such tools.</p>
<p>The tools listed below are related to memory safety. That is, they help you to achieve memory safety in your Zig code:</p>
<ul>
<li><code>defer</code> allows you to keep free operations physically close to allocations. This helps you to avoid memory leaks, “use after free”, and also “double-free” problems. Furthermore, it also keeps free operations logically tied to the end of the current scope, which greatly reduces the mental overhead about object lifetime.</li>
<li><code>errdefer</code> helps you to guarantee that your program frees the allocated memory, even if a runtime error occurs.</li>
<li>pointers and objects are non-nullable by default. This helps you to avoid memory problems that might arise from de-referencing null pointers.</li>
<li>Zig offers some native types of allocators (called “testing allocators”) that can detect memory leaks and double-frees. These types of allocators are widely used on unit tests, so they transform your unit tests into a weapon that you can use to detect memory problems in your code.</li>
<li>arrays and slices in Zig have their lengths embedded in the object itself, which makes the <code>zig</code> compiler very effective on detecting “index out-of-range” type of errors, and avoiding buffer overflows.</li>
</ul>
<p>Despite these features that Zig offers that are related to memory safety issues, the language also has some rules that help you to achieve another type of safety, which is more related to program logic safety. These rules are:</p>
<ul>
<li>pointers and objects are non-nullable by default. Which eliminates an edge case that might break the logic of your program.</li>
<li>switch statements must exaust all possible options.</li>
<li>the <code>zig</code> compiler forces you to handle every possible error in your program.</li>
</ul>
</section>
<section id="other-parts-of-zig" class="level2" data-number="1.10">
<h2 data-number="1.10" class="anchored" data-anchor-id="other-parts-of-zig"><span class="header-section-number">1.10</span> Other parts of Zig</h2>
<p>We already learned a lot about Zig’s syntax, and also, some pretty technical details about it. Just as a quick recap:</p>
<ul>
<li>We talked about how functions are written in Zig in <a href="#sec-root-file" class="quarto-xref"><span>Section 1.2.2</span></a> and <a href="#sec-main-file" class="quarto-xref"><span>Section 1.2.3</span></a>.</li>
<li>How to create new objects/identifiers in <a href="#sec-root-file" class="quarto-xref"><span>Section 1.2.2</span></a> and especially in <a href="#sec-assignments" class="quarto-xref"><span>Section 1.4</span></a>.</li>
<li>How strings work in Zig in <a href="#sec-zig-strings" class="quarto-xref"><span>Section 1.8</span></a>.</li>
<li>How to use arrays and slices in <a href="#sec-arrays" class="quarto-xref"><span>Section 1.6</span></a>.</li>
<li>How to import functionality from other Zig modules in <a href="#sec-root-file" class="quarto-xref"><span>Section 1.2.2</span></a>.</li>
</ul>
<p>But, for now, this amount of knowledge is enough for us to continue with this book. Later, over the next chapters we will still talk more about other parts of Zig’s syntax that are also equally important. Such as:</p>
<ul>
<li>How Object-Oriented programming can be done in Zig through <em>struct declarations</em> in <a href="03-structs.html#sec-structs-and-oop" class="quarto-xref"><span>Section 2.3</span></a>.</li>
<li>Basic control flow syntax in <a href="03-structs.html#sec-zig-control-flow" class="quarto-xref"><span>Section 2.1</span></a>.</li>
<li>Enums in <a href="04-http-server.html#sec-enum" class="quarto-xref"><span>Section 7.6</span></a>;</li>
<li>Pointers and Optionals in <a href="05-pointers.html" class="quarto-xref"><span>Chapter 6</span></a>;</li>
<li>Error handling with <code>try</code> and <code>catch</code> in <a href="09-error-handling.html" class="quarto-xref"><span>Chapter 10</span></a>;</li>
<li>Unit tests in <a href="03-unittests.html" class="quarto-xref"><span>Chapter 8</span></a>;</li>
<li>Vectors in <a href="15-vectors.html" class="quarto-xref"><span>Chapter 17</span></a>;</li>
<li>Build System in <a href="07-build-system.html" class="quarto-xref"><span>Chapter 9</span></a>;</li>
</ul>


<!-- -->

<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-exploit1" class="csl-entry" role="listitem">
Kim, Juhee, Jinbum Park, Sihyeon Roh, Jaeyoung Chung, Youngjoo Lee, Taesoo Kim, and Byoungyoung Lee. 2024. <span>“TikTag: Breaking ARM’s Memory Tagging Extension with Speculative Execution.”</span> <a href="https://arxiv.org/abs/2406.08719">https://arxiv.org/abs/2406.08719</a>.
</div>
<div id="ref-zigguide" class="csl-entry" role="listitem">
Sobeston. 2024. <span>“Zig Guide.”</span> <a href="https://zig.guide/">https://zig.guide/</a>.
</div>
</div>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p><a href="https://ziglang.org/learn/overview/#zig-build-system" class="uri">https://ziglang.org/learn/overview/#zig-build-system</a>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><a href="https://zig.news/edyu/zig-package-manager-wtf-is-zon-558e" class="uri">https://zig.news/edyu/zig-package-manager-wtf-is-zon-558e</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p><a href="https://medium.com/@edlyuu/zig-package-manager-2-wtf-is-build-zig-zon-and-build-zig-0-11-0-update-5bc46e830fc1" class="uri">https://medium.com/@edlyuu/zig-package-manager-2-wtf-is-build-zig-zon-and-build-zig-0-11-0-update-5bc46e830fc1</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p><a href="https://github.com/ziglang/zig/blob/master/doc/build.zig.zon.md" class="uri">https://github.com/ziglang/zig/blob/master/doc/build.zig.zon.md</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p><a href="https://en.wikipedia.org/wiki/List_of_C-family_programming_languages" class="uri">https://en.wikipedia.org/wiki/List_of_C-family_programming_languages</a><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>You can see an example of a <code>main()</code> function that returns an <code>u8</code> value in the <code>return-integer.zig</code> file, <a href="https://github.com/pedropark99/zig-book/blob/main/ZigExamples/zig-basics/return-integer.zig" class="uri">https://github.com/pedropark99/zig-book/blob/main/ZigExamples/zig-basics/return-integer.zig</a><a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p><a href="https://github.com/ziglang/zig/issues/17186" class="uri">https://github.com/ziglang/zig/issues/17186</a><a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p><a href="https://github.com/ziglang/zig/issues/19864" class="uri">https://github.com/ziglang/zig/issues/19864</a><a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p><a href="https://github.com/ziglang/zig/tree/master/lib/std" class="uri">https://github.com/ziglang/zig/tree/master/lib/std</a><a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p><a href="https://github.com/oven-sh/bun" class="uri">https://github.com/oven-sh/bun</a>.<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11"><p><a href="https://github.com/hexops/mach" class="uri">https://github.com/hexops/mach</a><a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12"><p><a href="https://github.com/cgbur/llama2.zig/tree/main" class="uri">https://github.com/cgbur/llama2.zig/tree/main</a><a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13"><p><a href="https://github.com/tigerbeetle/tigerbeetle" class="uri">https://github.com/tigerbeetle/tigerbeetle</a><a href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn14"><p><a href="https://github.com/Hejsil/zig-clap" class="uri">https://github.com/Hejsil/zig-clap</a><a href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn15"><p><a href="https://github.com/capy-ui/capy" class="uri">https://github.com/capy-ui/capy</a><a href="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn16"><p><a href="https://github.com/zigtools/zls" class="uri">https://github.com/zigtools/zls</a><a href="#fnref16" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn17"><p><a href="https://github.com/mitchellh/libxev" class="uri">https://github.com/mitchellh/libxev</a><a href="#fnref17" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn18"><p><a href="https://ziglings.org" class="uri">https://ziglings.org</a>.<a href="#fnref18" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn19"><p><a href="https://www.youtube.com/watch?v=OPuztQfM3Fg&amp;t=2524s&amp;ab_channel=TheVimeagen" class="uri">https://www.youtube.com/watch?v=OPuztQfM3Fg&amp;t=2524s&amp;ab_channel=TheVimeagen</a>.<a href="#fnref19" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn20"><p><a href="https://adventofcode.com/" class="uri">https://adventofcode.com/</a><a href="#fnref20" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn21"><p><a href="https://ziglang.org/documentation/master/#Primitive-Types" class="uri">https://ziglang.org/documentation/master/#Primitive-Types</a>.<a href="#fnref21" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn22"><p><a href="https://www.gnu.org/software/libiconv/" class="uri">https://www.gnu.org/software/libiconv/</a><a href="#fnref22" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn23"><p><a href="https://ziglang.org/documentation/master/#Sentinel-Terminated-Arrays" class="uri">https://ziglang.org/documentation/master/#Sentinel-Terminated-Arrays</a>.<a href="#fnref23" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn24"><p><a href="https://cplusplus.com/reference/cstdio/printf/" class="uri">https://cplusplus.com/reference/cstdio/printf/</a><a href="#fnref24" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn25"><p><a href="https://www.youtube.com/watch?v=jIZpKpLCOiU&amp;ab_channel=GOTOConferences" class="uri">https://www.youtube.com/watch?v=jIZpKpLCOiU&amp;ab_channel=GOTOConferences</a><a href="#fnref25" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn26"><p>Actually, a lot of existing Rust code is still memory unsafe, because they communicate with external libraries through FFI (<em>foreign function interface</em>), which disables the borrow-checker features through the <code>unsafe</code> keyword.<a href="#fnref26" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
<<<<<<< HEAD
=======
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
>>>>>>> origin
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../index.html" class="pagination-link" aria-label="Welcome">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Welcome</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../Chapters/03-structs.html" class="pagination-link" aria-label="Control flow, structs, modules and types">
        <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Control flow, structs, modules and types</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb73" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a><span class="an">engine:</span><span class="co"> knitr</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a><span class="an">knitr:</span><span class="co"> true</span></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a><span class="an">syntax-definition:</span><span class="co"> "../Assets/zig.xml"</span></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a><span class="co">#| include: false</span></span>
<span id="cb73-12"><a href="#cb73-12" aria-hidden="true" tabindex="-1"></a><span class="fu">source</span>(<span class="st">"../zig_engine.R"</span>)</span>
<span id="cb73-13"><a href="#cb73-13" aria-hidden="true" tabindex="-1"></a>knitr<span class="sc">::</span>opts_chunk<span class="sc">$</span><span class="fu">set</span>(</span>
<span id="cb73-14"><a href="#cb73-14" aria-hidden="true" tabindex="-1"></a>    <span class="at">auto_main =</span> <span class="cn">FALSE</span>,</span>
<span id="cb73-15"><a href="#cb73-15" aria-hidden="true" tabindex="-1"></a>    <span class="at">build_type =</span> <span class="st">"lib"</span></span>
<span id="cb73-16"><a href="#cb73-16" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb73-17"><a href="#cb73-17" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-18"><a href="#cb73-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-19"><a href="#cb73-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-20"><a href="#cb73-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-21"><a href="#cb73-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-22"><a href="#cb73-22" aria-hidden="true" tabindex="-1"></a><span class="fu"># Introducing Zig</span></span>
<span id="cb73-23"><a href="#cb73-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-24"><a href="#cb73-24" aria-hidden="true" tabindex="-1"></a>In this chapter, I want to introduce you to the world of Zig.</span>
<span id="cb73-25"><a href="#cb73-25" aria-hidden="true" tabindex="-1"></a>Zig is a very young language that is being actively developed.</span>
<span id="cb73-26"><a href="#cb73-26" aria-hidden="true" tabindex="-1"></a>As a consequence, its world is still very wild and to be explored.</span>
<span id="cb73-27"><a href="#cb73-27" aria-hidden="true" tabindex="-1"></a>This book is my attempt to help you on your personal journey for</span>
<span id="cb73-28"><a href="#cb73-28" aria-hidden="true" tabindex="-1"></a>understanding and exploring the exciting world of Zig.</span>
<span id="cb73-29"><a href="#cb73-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-30"><a href="#cb73-30" aria-hidden="true" tabindex="-1"></a>I assume you have previous experience with some programming</span>
<span id="cb73-31"><a href="#cb73-31" aria-hidden="true" tabindex="-1"></a>language in this book, not necessarily with a low-level one.</span>
<span id="cb73-32"><a href="#cb73-32" aria-hidden="true" tabindex="-1"></a>So, if you have experience with Python, or Javascript, for example, it will be fine.</span>
<span id="cb73-33"><a href="#cb73-33" aria-hidden="true" tabindex="-1"></a>But, if you do have experience with low-level languages, such as C, C++, or</span>
<span id="cb73-34"><a href="#cb73-34" aria-hidden="true" tabindex="-1"></a>Rust, you will probably learn faster throughout this book.</span>
<span id="cb73-35"><a href="#cb73-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-36"><a href="#cb73-36" aria-hidden="true" tabindex="-1"></a><span class="fu">## What is Zig?</span></span>
<span id="cb73-37"><a href="#cb73-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-38"><a href="#cb73-38" aria-hidden="true" tabindex="-1"></a>Zig is a modern, low-level, and general-purpose programming language. Some programmers think of</span>
<span id="cb73-39"><a href="#cb73-39" aria-hidden="true" tabindex="-1"></a>Zig as a modern and better version of C.</span>
<span id="cb73-40"><a href="#cb73-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-41"><a href="#cb73-41" aria-hidden="true" tabindex="-1"></a>In the author's personal interpretation, Zig is tightly connected with "less is more".</span>
<span id="cb73-42"><a href="#cb73-42" aria-hidden="true" tabindex="-1"></a>Instead of trying to become a modern language by adding more and more features,</span>
<span id="cb73-43"><a href="#cb73-43" aria-hidden="true" tabindex="-1"></a>many of the core improvements that Zig brings to the</span>
<span id="cb73-44"><a href="#cb73-44" aria-hidden="true" tabindex="-1"></a>table are actually about removing annoying behaviours/features from C and C++.</span>
<span id="cb73-45"><a href="#cb73-45" aria-hidden="true" tabindex="-1"></a>In other words, Zig tries to be better by simplifying the language, and by having more consistent and robust behaviour.</span>
<span id="cb73-46"><a href="#cb73-46" aria-hidden="true" tabindex="-1"></a>As a result, analyzing, writing and debugging applications become much easier and simpler in Zig, than it is in C or C++.</span>
<span id="cb73-47"><a href="#cb73-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-48"><a href="#cb73-48" aria-hidden="true" tabindex="-1"></a>This philosophy becomes clear with the following phrase from the official website of Zig:</span>
<span id="cb73-49"><a href="#cb73-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-50"><a href="#cb73-50" aria-hidden="true" tabindex="-1"></a><span class="at">&gt; "Focus on debugging your application rather than debugging your programming language knowledge".</span></span>
<span id="cb73-51"><a href="#cb73-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-52"><a href="#cb73-52" aria-hidden="true" tabindex="-1"></a>This phrase is specially true for C++ programmers. Because C++ is a gigantic language,</span>
<span id="cb73-53"><a href="#cb73-53" aria-hidden="true" tabindex="-1"></a>with tons of features, and also, there are lots of different "flavors of C++". These elements</span>
<span id="cb73-54"><a href="#cb73-54" aria-hidden="true" tabindex="-1"></a>are what makes C++ so complex and hard to learn. Zig tries to go in the opposite direction.</span>
<span id="cb73-55"><a href="#cb73-55" aria-hidden="true" tabindex="-1"></a>Zig is a very simple language, more closely related to other simple languages such as C and Go.</span>
<span id="cb73-56"><a href="#cb73-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-57"><a href="#cb73-57" aria-hidden="true" tabindex="-1"></a>The phrase above is still important for C programmers too. Because, even C being a simple</span>
<span id="cb73-58"><a href="#cb73-58" aria-hidden="true" tabindex="-1"></a>language, it's still hard sometimes to read and understand C code. For example, pre-processor macros in</span>
<span id="cb73-59"><a href="#cb73-59" aria-hidden="true" tabindex="-1"></a>C are a frequent source of confusion. Sometimes, they really make it hard to debug</span>
<span id="cb73-60"><a href="#cb73-60" aria-hidden="true" tabindex="-1"></a>C programs. Because macros are essentially a second language embedded in C that obscures</span>
<span id="cb73-61"><a href="#cb73-61" aria-hidden="true" tabindex="-1"></a>your C code. With macros, you are no longer 100% sure about which pieces</span>
<span id="cb73-62"><a href="#cb73-62" aria-hidden="true" tabindex="-1"></a>of the code are being sent to the compiler, i.e.</span>
<span id="cb73-63"><a href="#cb73-63" aria-hidden="true" tabindex="-1"></a>they obscure the actual source code that you wrote.</span>
<span id="cb73-64"><a href="#cb73-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-65"><a href="#cb73-65" aria-hidden="true" tabindex="-1"></a>You don't have macros in Zig. In Zig, the code you write, is the actual code that gets compiled by the compiler.</span>
<span id="cb73-66"><a href="#cb73-66" aria-hidden="true" tabindex="-1"></a>You also don't have a hidden control flow happening behind the scenes. And, you also</span>
<span id="cb73-67"><a href="#cb73-67" aria-hidden="true" tabindex="-1"></a>don't have functions or operators from the standard library that make</span>
<span id="cb73-68"><a href="#cb73-68" aria-hidden="true" tabindex="-1"></a>hidden memory allocations behind your back.</span>
<span id="cb73-69"><a href="#cb73-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-70"><a href="#cb73-70" aria-hidden="true" tabindex="-1"></a>By being a simpler language, Zig becomes much more clear and easier to read/write,</span>
<span id="cb73-71"><a href="#cb73-71" aria-hidden="true" tabindex="-1"></a>but at the same time, it also achieves a much more robust state, with more consistent</span>
<span id="cb73-72"><a href="#cb73-72" aria-hidden="true" tabindex="-1"></a>behaviour in edge situations. Once again, less is more.</span>
<span id="cb73-73"><a href="#cb73-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-74"><a href="#cb73-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-75"><a href="#cb73-75" aria-hidden="true" tabindex="-1"></a><span class="fu">## Hello world in Zig</span></span>
<span id="cb73-76"><a href="#cb73-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-77"><a href="#cb73-77" aria-hidden="true" tabindex="-1"></a>We begin our journey in Zig by creating a small "Hello World" program.</span>
<span id="cb73-78"><a href="#cb73-78" aria-hidden="true" tabindex="-1"></a>To start a new Zig project in your computer, you simply call the <span class="in">`init`</span> command</span>
<span id="cb73-79"><a href="#cb73-79" aria-hidden="true" tabindex="-1"></a>from the <span class="in">`zig`</span> compiler.</span>
<span id="cb73-80"><a href="#cb73-80" aria-hidden="true" tabindex="-1"></a>Just create a new directory in your computer, then, init a new Zig project</span>
<span id="cb73-81"><a href="#cb73-81" aria-hidden="true" tabindex="-1"></a>inside this directory, like this:</span>
<span id="cb73-82"><a href="#cb73-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-83"><a href="#cb73-83" aria-hidden="true" tabindex="-1"></a><span class="in">```bash</span></span>
<span id="cb73-84"><a href="#cb73-84" aria-hidden="true" tabindex="-1"></a><span class="fu">mkdir</span> hello_world</span>
<span id="cb73-85"><a href="#cb73-85" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> hello_world</span>
<span id="cb73-86"><a href="#cb73-86" aria-hidden="true" tabindex="-1"></a><span class="ex">zig</span> init</span>
<span id="cb73-87"><a href="#cb73-87" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-88"><a href="#cb73-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-89"><a href="#cb73-89" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-90"><a href="#cb73-90" aria-hidden="true" tabindex="-1"></a><span class="in">info: created build.zig</span></span>
<span id="cb73-91"><a href="#cb73-91" aria-hidden="true" tabindex="-1"></a><span class="in">info: created build.zig.zon</span></span>
<span id="cb73-92"><a href="#cb73-92" aria-hidden="true" tabindex="-1"></a><span class="in">info: created src/main.zig</span></span>
<span id="cb73-93"><a href="#cb73-93" aria-hidden="true" tabindex="-1"></a><span class="in">info: created src/root.zig</span></span>
<span id="cb73-94"><a href="#cb73-94" aria-hidden="true" tabindex="-1"></a><span class="in">info: see `zig build --help` for a menu of options</span></span>
<span id="cb73-95"><a href="#cb73-95" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-96"><a href="#cb73-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-97"><a href="#cb73-97" aria-hidden="true" tabindex="-1"></a><span class="fu">### Understanding the project files {#sec-project-files}</span></span>
<span id="cb73-98"><a href="#cb73-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-99"><a href="#cb73-99" aria-hidden="true" tabindex="-1"></a>After you run the <span class="in">`init`</span> command from the <span class="in">`zig`</span> compiler, some new files</span>
<span id="cb73-100"><a href="#cb73-100" aria-hidden="true" tabindex="-1"></a>are created inside of your current directory. First, a "source" (<span class="in">`src`</span>) directory</span>
<span id="cb73-101"><a href="#cb73-101" aria-hidden="true" tabindex="-1"></a>is created, containing two files, <span class="in">`main.zig`</span> and <span class="in">`root.zig`</span>. Each <span class="in">`.zig`</span> file</span>
<span id="cb73-102"><a href="#cb73-102" aria-hidden="true" tabindex="-1"></a>is a separate Zig module, which is simply a text file that contains some Zig code.</span>
<span id="cb73-103"><a href="#cb73-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-104"><a href="#cb73-104" aria-hidden="true" tabindex="-1"></a>By convention, the <span class="in">`main.zig`</span> module is where your main function lives. Thus,</span>
<span id="cb73-105"><a href="#cb73-105" aria-hidden="true" tabindex="-1"></a>if you are building an executable program in Zig, you need to declare a <span class="in">`main()`</span> function,</span>
<span id="cb73-106"><a href="#cb73-106" aria-hidden="true" tabindex="-1"></a>which represents the entrypoint of your program, i.e., where the execution of your program begins.</span>
<span id="cb73-107"><a href="#cb73-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-108"><a href="#cb73-108" aria-hidden="true" tabindex="-1"></a>However, if you are building a library (instead of an executable program), then,</span>
<span id="cb73-109"><a href="#cb73-109" aria-hidden="true" tabindex="-1"></a>the normal procedure is to delete this <span class="in">`main.zig`</span> file and start with the <span class="in">`root.zig`</span> module.</span>
<span id="cb73-110"><a href="#cb73-110" aria-hidden="true" tabindex="-1"></a>By convention, the <span class="in">`root.zig`</span> module is the root source file of your library.</span>
<span id="cb73-111"><a href="#cb73-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-112"><a href="#cb73-112" aria-hidden="true" tabindex="-1"></a><span class="in">```bash</span></span>
<span id="cb73-113"><a href="#cb73-113" aria-hidden="true" tabindex="-1"></a><span class="ex">tree</span> .</span>
<span id="cb73-114"><a href="#cb73-114" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-115"><a href="#cb73-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-116"><a href="#cb73-116" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-117"><a href="#cb73-117" aria-hidden="true" tabindex="-1"></a><span class="in">.</span></span>
<span id="cb73-118"><a href="#cb73-118" aria-hidden="true" tabindex="-1"></a><span class="in">├── build.zig</span></span>
<span id="cb73-119"><a href="#cb73-119" aria-hidden="true" tabindex="-1"></a><span class="in">├── build.zig.zon</span></span>
<span id="cb73-120"><a href="#cb73-120" aria-hidden="true" tabindex="-1"></a><span class="in">└── src</span></span>
<span id="cb73-121"><a href="#cb73-121" aria-hidden="true" tabindex="-1"></a><span class="in">    ├── main.zig</span></span>
<span id="cb73-122"><a href="#cb73-122" aria-hidden="true" tabindex="-1"></a><span class="in">    └── root.zig</span></span>
<span id="cb73-123"><a href="#cb73-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-124"><a href="#cb73-124" aria-hidden="true" tabindex="-1"></a><span class="in">1 directory, 4 files</span></span>
<span id="cb73-125"><a href="#cb73-125" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-126"><a href="#cb73-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-127"><a href="#cb73-127" aria-hidden="true" tabindex="-1"></a>The <span class="in">`init`</span> command also creates two additional files in our working directory:</span>
<span id="cb73-128"><a href="#cb73-128" aria-hidden="true" tabindex="-1"></a><span class="in">`build.zig`</span> and <span class="in">`build.zig.zon`</span>. The first file (<span class="in">`build.zig`</span>) represents a build script written in Zig.</span>
<span id="cb73-129"><a href="#cb73-129" aria-hidden="true" tabindex="-1"></a>This script is executed when you call the <span class="in">`build`</span> command from the <span class="in">`zig`</span> compiler.</span>
<span id="cb73-130"><a href="#cb73-130" aria-hidden="true" tabindex="-1"></a>In other words, this file contains Zig code that executes the necessary steps to build the entire project.</span>
<span id="cb73-131"><a href="#cb73-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-132"><a href="#cb73-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-133"><a href="#cb73-133" aria-hidden="true" tabindex="-1"></a>Low-level languages normally use a compiler to build your</span>
<span id="cb73-134"><a href="#cb73-134" aria-hidden="true" tabindex="-1"></a>source code into binary executables or binary libraries.</span>
<span id="cb73-135"><a href="#cb73-135" aria-hidden="true" tabindex="-1"></a>Nevertheless, this process of compiling your source code and building</span>
<span id="cb73-136"><a href="#cb73-136" aria-hidden="true" tabindex="-1"></a>binary executables or binary libraries from it, became a real challenge</span>
<span id="cb73-137"><a href="#cb73-137" aria-hidden="true" tabindex="-1"></a>in the programming world, once the projects became bigger and bigger.</span>
<span id="cb73-138"><a href="#cb73-138" aria-hidden="true" tabindex="-1"></a>As a result, programmers created "build systems", which are a second set of tools designed to make this process</span>
<span id="cb73-139"><a href="#cb73-139" aria-hidden="true" tabindex="-1"></a>of compiling and building complex projects, easier.</span>
<span id="cb73-140"><a href="#cb73-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-141"><a href="#cb73-141" aria-hidden="true" tabindex="-1"></a>Examples of build systems are CMake, GNU Make, GNU Autoconf and Ninja,</span>
<span id="cb73-142"><a href="#cb73-142" aria-hidden="true" tabindex="-1"></a>which are used to build complex C and C++ projects.</span>
<span id="cb73-143"><a href="#cb73-143" aria-hidden="true" tabindex="-1"></a>With these systems, you can write scripts, which are called "build scripts".</span>
<span id="cb73-144"><a href="#cb73-144" aria-hidden="true" tabindex="-1"></a>They simply are scripts that describes the necessary steps to compile/build</span>
<span id="cb73-145"><a href="#cb73-145" aria-hidden="true" tabindex="-1"></a>your project.</span>
<span id="cb73-146"><a href="#cb73-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-147"><a href="#cb73-147" aria-hidden="true" tabindex="-1"></a>However, these are separate tools, that do not</span>
<span id="cb73-148"><a href="#cb73-148" aria-hidden="true" tabindex="-1"></a>belong to C/C++ compilers, like <span class="in">`gcc`</span> or <span class="in">`clang`</span>.</span>
<span id="cb73-149"><a href="#cb73-149" aria-hidden="true" tabindex="-1"></a>As a result, in C/C++ projects, you have not only to install and</span>
<span id="cb73-150"><a href="#cb73-150" aria-hidden="true" tabindex="-1"></a>manage your C/C++ compilers, but you also have to install and manage</span>
<span id="cb73-151"><a href="#cb73-151" aria-hidden="true" tabindex="-1"></a>these build systems separately.</span>
<span id="cb73-152"><a href="#cb73-152" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-153"><a href="#cb73-153" aria-hidden="true" tabindex="-1"></a>In Zig, we don't need to use a separate set of tools to build our projects,</span>
<span id="cb73-154"><a href="#cb73-154" aria-hidden="true" tabindex="-1"></a>because a build system is embedded inside the language itself.</span>
<span id="cb73-155"><a href="#cb73-155" aria-hidden="true" tabindex="-1"></a>We can use this build system to write small scripts in Zig,</span>
<span id="cb73-156"><a href="#cb73-156" aria-hidden="true" tabindex="-1"></a>which describe the necessary steps to build/compile our Zig project<span class="ot">[^zig-build-system]</span>.</span>
<span id="cb73-157"><a href="#cb73-157" aria-hidden="true" tabindex="-1"></a>So, everything you need to build a complex Zig project is the</span>
<span id="cb73-158"><a href="#cb73-158" aria-hidden="true" tabindex="-1"></a><span class="in">`zig`</span> compiler, and nothing more.</span>
<span id="cb73-159"><a href="#cb73-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-160"><a href="#cb73-160" aria-hidden="true" tabindex="-1"></a><span class="ot">[^zig-build-system]: &lt;https://ziglang.org/learn/overview/#zig-build-system&gt;</span>.</span>
<span id="cb73-161"><a href="#cb73-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-162"><a href="#cb73-162" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-163"><a href="#cb73-163" aria-hidden="true" tabindex="-1"></a>The second generated file (<span class="in">`build.zig.zon`</span>) is a JSON-like file, in which you can describe</span>
<span id="cb73-164"><a href="#cb73-164" aria-hidden="true" tabindex="-1"></a>your project, and also, declare a set of dependencies of your project that you want to fetch from the internet.</span>
<span id="cb73-165"><a href="#cb73-165" aria-hidden="true" tabindex="-1"></a>In other words, you can use this <span class="in">`build.zig.zon`</span> file to include a list of external libraries in your project.</span>
<span id="cb73-166"><a href="#cb73-166" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-167"><a href="#cb73-167" aria-hidden="true" tabindex="-1"></a>One possible way to include an external Zig library in your project, is to manually build</span>
<span id="cb73-168"><a href="#cb73-168" aria-hidden="true" tabindex="-1"></a>and install the library in your system, and just link your source code</span>
<span id="cb73-169"><a href="#cb73-169" aria-hidden="true" tabindex="-1"></a>with the library at the build step of your project.</span>
<span id="cb73-170"><a href="#cb73-170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-171"><a href="#cb73-171" aria-hidden="true" tabindex="-1"></a>However, if this external Zig library is available on GitHub for example,</span>
<span id="cb73-172"><a href="#cb73-172" aria-hidden="true" tabindex="-1"></a>and it has a valid <span class="in">`build.zig.zon`</span> file in root folder of the project,</span>
<span id="cb73-173"><a href="#cb73-173" aria-hidden="true" tabindex="-1"></a>which describes the project, you can easily include this library in</span>
<span id="cb73-174"><a href="#cb73-174" aria-hidden="true" tabindex="-1"></a>your project by simply listing this external library in your <span class="in">`build.zig.zon`</span> file.</span>
<span id="cb73-175"><a href="#cb73-175" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-176"><a href="#cb73-176" aria-hidden="true" tabindex="-1"></a>In other words, this <span class="in">`build.zig.zon`</span> file works similarly to the <span class="in">`package.json`</span></span>
<span id="cb73-177"><a href="#cb73-177" aria-hidden="true" tabindex="-1"></a>file in Javascript projects, or the <span class="in">`Pipfile`</span> file in Python projects,</span>
<span id="cb73-178"><a href="#cb73-178" aria-hidden="true" tabindex="-1"></a>or the <span class="in">`Cargo.toml`</span> file in Rust projects. You can read more about this</span>
<span id="cb73-179"><a href="#cb73-179" aria-hidden="true" tabindex="-1"></a>specific file in a couple of articles on the internet<span class="ot">[^zig-zon][^zig-zon2]</span>, and</span>
<span id="cb73-180"><a href="#cb73-180" aria-hidden="true" tabindex="-1"></a>you can also see the expected schema for this <span class="in">`build.zig.zon`</span> file</span>
<span id="cb73-181"><a href="#cb73-181" aria-hidden="true" tabindex="-1"></a>in a documentation file inside the official repository of Zig<span class="ot">[^zig-zon-schema]</span>.</span>
<span id="cb73-182"><a href="#cb73-182" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-183"><a href="#cb73-183" aria-hidden="true" tabindex="-1"></a><span class="ot">[^zig-zon]: &lt;https://zig.news/edyu/zig-package-manager-wtf-is-zon-558e&gt;</span></span>
<span id="cb73-184"><a href="#cb73-184" aria-hidden="true" tabindex="-1"></a><span class="ot">[^zig-zon2]: &lt;https://medium.com/@edlyuu/zig-package-manager-2-wtf-is-build-zig-zon-and-build-zig-0-11-0-update-5bc46e830fc1&gt;</span></span>
<span id="cb73-185"><a href="#cb73-185" aria-hidden="true" tabindex="-1"></a><span class="ot">[^zig-zon-schema]: &lt;https://github.com/ziglang/zig/blob/master/doc/build.zig.zon.md&gt;</span></span>
<span id="cb73-186"><a href="#cb73-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-187"><a href="#cb73-187" aria-hidden="true" tabindex="-1"></a><span class="fu">### The file `root.zig` {#sec-root-file}</span></span>
<span id="cb73-188"><a href="#cb73-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-189"><a href="#cb73-189" aria-hidden="true" tabindex="-1"></a>Let's take a look into the <span class="in">`root.zig`</span> file.</span>
<span id="cb73-190"><a href="#cb73-190" aria-hidden="true" tabindex="-1"></a>You might have noticed that every line of code with an expression ends with a semicolon (<span class="in">`;`</span>).</span>
<span id="cb73-191"><a href="#cb73-191" aria-hidden="true" tabindex="-1"></a>This follows the syntax of a C-family programming language<span class="ot">[^c-family]</span>.</span>
<span id="cb73-192"><a href="#cb73-192" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-193"><a href="#cb73-193" aria-hidden="true" tabindex="-1"></a><span class="ot">[^c-family]: &lt;https://en.wikipedia.org/wiki/List_of_C-family_programming_languages&gt;</span></span>
<span id="cb73-194"><a href="#cb73-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-195"><a href="#cb73-195" aria-hidden="true" tabindex="-1"></a>Also, notice the <span class="in">`@import()`</span> call at the first line. We use this built-in function</span>
<span id="cb73-196"><a href="#cb73-196" aria-hidden="true" tabindex="-1"></a>to import functionality from other Zig modules into our current module.</span>
<span id="cb73-197"><a href="#cb73-197" aria-hidden="true" tabindex="-1"></a>This <span class="in">`@import()`</span> function works similarly to the <span class="in">`#include`</span> pre-processor</span>
<span id="cb73-198"><a href="#cb73-198" aria-hidden="true" tabindex="-1"></a>in C or C++, or, to the <span class="in">`import`</span> statement in Python or Javascript code.</span>
<span id="cb73-199"><a href="#cb73-199" aria-hidden="true" tabindex="-1"></a>In this example, we are importing the <span class="in">`std`</span> module,</span>
<span id="cb73-200"><a href="#cb73-200" aria-hidden="true" tabindex="-1"></a>which gives you access to the Zig Standard Library.</span>
<span id="cb73-201"><a href="#cb73-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-202"><a href="#cb73-202" aria-hidden="true" tabindex="-1"></a>In this <span class="in">`root.zig`</span> file, we can also see how assignments (i.e., creating new objects)</span>
<span id="cb73-203"><a href="#cb73-203" aria-hidden="true" tabindex="-1"></a>are made in Zig. You can create a new object in Zig by using the syntax</span>
<span id="cb73-204"><a href="#cb73-204" aria-hidden="true" tabindex="-1"></a><span class="in">`(const|var) name = value;`</span>. In the example below, we are creating two constant</span>
<span id="cb73-205"><a href="#cb73-205" aria-hidden="true" tabindex="-1"></a>objects (<span class="in">`std`</span> and <span class="in">`testing`</span>). In @sec-assignments we talk more about objects in general.</span>
<span id="cb73-206"><a href="#cb73-206" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-207"><a href="#cb73-207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-210"><a href="#cb73-210" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-211"><a href="#cb73-211" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: false</span></span>
<span id="cb73-212"><a href="#cb73-212" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "ast"</span></span>
<span id="cb73-213"><a href="#cb73-213" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb73-214"><a href="#cb73-214" aria-hidden="true" tabindex="-1"></a><span class="in">const testing = std.testing;</span></span>
<span id="cb73-215"><a href="#cb73-215" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-216"><a href="#cb73-216" aria-hidden="true" tabindex="-1"></a><span class="in">export fn add(a: i32, b: i32) i32 {</span></span>
<span id="cb73-217"><a href="#cb73-217" aria-hidden="true" tabindex="-1"></a><span class="in">    return a + b;</span></span>
<span id="cb73-218"><a href="#cb73-218" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb73-219"><a href="#cb73-219" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-220"><a href="#cb73-220" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-221"><a href="#cb73-221" aria-hidden="true" tabindex="-1"></a>Functions in Zig are declared using the <span class="in">`fn`</span> keyword.</span>
<span id="cb73-222"><a href="#cb73-222" aria-hidden="true" tabindex="-1"></a>In this <span class="in">`root.zig`</span> module, we are declaring a function called <span class="in">`add()`</span>, which has two arguments named <span class="in">`a`</span> and <span class="in">`b`</span>.</span>
<span id="cb73-223"><a href="#cb73-223" aria-hidden="true" tabindex="-1"></a>The function returns an integer of the type <span class="in">`i32`</span> as result.</span>
<span id="cb73-224"><a href="#cb73-224" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-225"><a href="#cb73-225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-226"><a href="#cb73-226" aria-hidden="true" tabindex="-1"></a>Zig is a strongly-typed language. There are some specific situations where you can (if you want to) omit</span>
<span id="cb73-227"><a href="#cb73-227" aria-hidden="true" tabindex="-1"></a>the type of an object in your code, if this type can be inferred by the <span class="in">`zig`</span> compiler (we talk more</span>
<span id="cb73-228"><a href="#cb73-228" aria-hidden="true" tabindex="-1"></a>about that in @sec-type-inference). But there are other situations where you do need to be explicit.</span>
<span id="cb73-229"><a href="#cb73-229" aria-hidden="true" tabindex="-1"></a>For example, you do have to explicitly specify the type of each function argument, and also,</span>
<span id="cb73-230"><a href="#cb73-230" aria-hidden="true" tabindex="-1"></a>the return type of every function that you create in Zig.</span>
<span id="cb73-231"><a href="#cb73-231" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-232"><a href="#cb73-232" aria-hidden="true" tabindex="-1"></a>We specify the type of an object or a function argument in Zig by</span>
<span id="cb73-233"><a href="#cb73-233" aria-hidden="true" tabindex="-1"></a>using a colon character (<span class="in">`:`</span>) followed by the type after the name of this object/function argument.</span>
<span id="cb73-234"><a href="#cb73-234" aria-hidden="true" tabindex="-1"></a>With the expressions <span class="in">`a: i32`</span> and <span class="in">`b: i32`</span>, we know that both <span class="in">`a`</span> and <span class="in">`b`</span> arguments have type <span class="in">`i32`</span>,</span>
<span id="cb73-235"><a href="#cb73-235" aria-hidden="true" tabindex="-1"></a>which is a signed 32 bit integer. In this part,</span>
<span id="cb73-236"><a href="#cb73-236" aria-hidden="true" tabindex="-1"></a>the syntax in Zig is identical to the syntax in Rust, which also specifies types by</span>
<span id="cb73-237"><a href="#cb73-237" aria-hidden="true" tabindex="-1"></a>using the colon character.</span>
<span id="cb73-238"><a href="#cb73-238" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-239"><a href="#cb73-239" aria-hidden="true" tabindex="-1"></a>Lastly, we have the return type of the function at the end of the line, before we open</span>
<span id="cb73-240"><a href="#cb73-240" aria-hidden="true" tabindex="-1"></a>the curly braces to start writing the function's body. In the example above, this type is also</span>
<span id="cb73-241"><a href="#cb73-241" aria-hidden="true" tabindex="-1"></a>a signed 32 bit integer (<span class="in">`i32`</span>) value.</span>
<span id="cb73-242"><a href="#cb73-242" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-243"><a href="#cb73-243" aria-hidden="true" tabindex="-1"></a>Notice that we also have an <span class="in">`export`</span> keyword before the function declaration. This keyword</span>
<span id="cb73-244"><a href="#cb73-244" aria-hidden="true" tabindex="-1"></a>is similar to the <span class="in">`extern`</span> keyword in C. It exposes the function</span>
<span id="cb73-245"><a href="#cb73-245" aria-hidden="true" tabindex="-1"></a>to make it available in the library API. Therefore, if you are writing</span>
<span id="cb73-246"><a href="#cb73-246" aria-hidden="true" tabindex="-1"></a>a library for other people to use, you have to expose the functions</span>
<span id="cb73-247"><a href="#cb73-247" aria-hidden="true" tabindex="-1"></a>you write in the public API of this library by using this <span class="in">`export`</span> keyword.</span>
<span id="cb73-248"><a href="#cb73-248" aria-hidden="true" tabindex="-1"></a>If we removed the <span class="in">`export`</span> keyword from the <span class="in">`add()`</span> function declaration,</span>
<span id="cb73-249"><a href="#cb73-249" aria-hidden="true" tabindex="-1"></a>then, this function would be no longer exposed in the library object built</span>
<span id="cb73-250"><a href="#cb73-250" aria-hidden="true" tabindex="-1"></a>by the <span class="in">`zig`</span> compiler.</span>
<span id="cb73-251"><a href="#cb73-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-252"><a href="#cb73-252" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-253"><a href="#cb73-253" aria-hidden="true" tabindex="-1"></a><span class="fu">### The `main.zig` file {#sec-main-file}</span></span>
<span id="cb73-254"><a href="#cb73-254" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-255"><a href="#cb73-255" aria-hidden="true" tabindex="-1"></a>Now that we have learned a lot about Zig's syntax from the <span class="in">`root.zig`</span> file,</span>
<span id="cb73-256"><a href="#cb73-256" aria-hidden="true" tabindex="-1"></a>let's take a look at the <span class="in">`main.zig`</span> file.</span>
<span id="cb73-257"><a href="#cb73-257" aria-hidden="true" tabindex="-1"></a>A lot of the elements we saw in <span class="in">`root.zig`</span> are also present in <span class="in">`main.zig`</span>.</span>
<span id="cb73-258"><a href="#cb73-258" aria-hidden="true" tabindex="-1"></a>But there are some other elements that we haven't seen yet, so let's dive in.</span>
<span id="cb73-259"><a href="#cb73-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-260"><a href="#cb73-260" aria-hidden="true" tabindex="-1"></a>First, look at the return type of the <span class="in">`main()`</span> function in this file.</span>
<span id="cb73-261"><a href="#cb73-261" aria-hidden="true" tabindex="-1"></a>We can see a small change. The return type of the function (<span class="in">`void`</span>) is accompanied by an exclamation mark (<span class="in">`!`</span>).</span>
<span id="cb73-262"><a href="#cb73-262" aria-hidden="true" tabindex="-1"></a>This exclamation mark tells us that this <span class="in">`main()`</span> function might return an error.</span>
<span id="cb73-263"><a href="#cb73-263" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-264"><a href="#cb73-264" aria-hidden="true" tabindex="-1"></a>It's worth noting that, a <span class="in">`main()`</span> function in Zig is allowed to return nothing (<span class="in">`void`</span>),</span>
<span id="cb73-265"><a href="#cb73-265" aria-hidden="true" tabindex="-1"></a>or an unsigned 8-bit integer (<span class="in">`u8`</span>) value<span class="ot">[^u8-example]</span>, or an error. In other words, you can write your <span class="in">`main()`</span> function in Zig</span>
<span id="cb73-266"><a href="#cb73-266" aria-hidden="true" tabindex="-1"></a>to return essentially nothing (<span class="in">`void`</span>), or, if you prefer, you can also write a more C-like <span class="in">`main()`</span> function,</span>
<span id="cb73-267"><a href="#cb73-267" aria-hidden="true" tabindex="-1"></a>which returns an integer value that usually serves as a "status code" for the process.</span>
<span id="cb73-268"><a href="#cb73-268" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-269"><a href="#cb73-269" aria-hidden="true" tabindex="-1"></a><span class="ot">[^u8-example]: </span>You can see an example of a <span class="in">`main()`</span> function that returns an <span class="in">`u8`</span> value in the <span class="in">`return-integer.zig`</span> file, <span class="ot">&lt;https://github.com/pedropark99/zig-book/blob/main/ZigExamples/zig-basics/return-integer.zig&gt;</span></span>
<span id="cb73-270"><a href="#cb73-270" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-271"><a href="#cb73-271" aria-hidden="true" tabindex="-1"></a>In this example, the return type annotation of <span class="in">`main()`</span> indicates that this function can either</span>
<span id="cb73-272"><a href="#cb73-272" aria-hidden="true" tabindex="-1"></a>return nothing (<span class="in">`void`</span>), or return an error. This exclamation mark in the return type annotation</span>
<span id="cb73-273"><a href="#cb73-273" aria-hidden="true" tabindex="-1"></a>is an interesting and powerful feature of Zig. In summary, if you write a function and something inside</span>
<span id="cb73-274"><a href="#cb73-274" aria-hidden="true" tabindex="-1"></a>the body of this function might return an error, then, you are forced to:</span>
<span id="cb73-275"><a href="#cb73-275" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-276"><a href="#cb73-276" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>either add the exclamation mark to the return type of the function and make it clear that</span>
<span id="cb73-277"><a href="#cb73-277" aria-hidden="true" tabindex="-1"></a>this function might return an error.</span>
<span id="cb73-278"><a href="#cb73-278" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>explicitly handle this error inside the function.</span>
<span id="cb73-279"><a href="#cb73-279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-280"><a href="#cb73-280" aria-hidden="true" tabindex="-1"></a>In most programming languages, we normally handle (or deal with) an error through</span>
<span id="cb73-281"><a href="#cb73-281" aria-hidden="true" tabindex="-1"></a>a *try catch* pattern. Zig does have both <span class="in">`try`</span> and <span class="in">`catch`</span> keywords. But they work</span>
<span id="cb73-282"><a href="#cb73-282" aria-hidden="true" tabindex="-1"></a>a little differently than what you're probably used to in other languages.</span>
<span id="cb73-283"><a href="#cb73-283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-284"><a href="#cb73-284" aria-hidden="true" tabindex="-1"></a>If we look at the <span class="in">`main()`</span> function below, you can see that we do have a <span class="in">`try`</span> keyword</span>
<span id="cb73-285"><a href="#cb73-285" aria-hidden="true" tabindex="-1"></a>on the 5th line. But we do not have a <span class="in">`catch`</span> keyword in this code.</span>
<span id="cb73-286"><a href="#cb73-286" aria-hidden="true" tabindex="-1"></a>In Zig, we use the <span class="in">`try`</span> keyword to execute an expression that might return an error,</span>
<span id="cb73-287"><a href="#cb73-287" aria-hidden="true" tabindex="-1"></a>which, in this example, is the <span class="in">`stdout.print()`</span> expression.</span>
<span id="cb73-288"><a href="#cb73-288" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-289"><a href="#cb73-289" aria-hidden="true" tabindex="-1"></a>In essence, the <span class="in">`try`</span> keyword executes the expression <span class="in">`stdout.print()`</span>. If this expression</span>
<span id="cb73-290"><a href="#cb73-290" aria-hidden="true" tabindex="-1"></a>returns a valid value, then, the <span class="in">`try`</span> keyword does absolutely nothing. It only passes the value forward.</span>
<span id="cb73-291"><a href="#cb73-291" aria-hidden="true" tabindex="-1"></a>It's like if this <span class="in">`try`</span> keyword was never there. However, if the expression does return an error, then,</span>
<span id="cb73-292"><a href="#cb73-292" aria-hidden="true" tabindex="-1"></a>the <span class="in">`try`</span> keyword will unwrap the error value, then, it returns this error from the function</span>
<span id="cb73-293"><a href="#cb73-293" aria-hidden="true" tabindex="-1"></a>and also prints the current stack trace to <span class="in">`stderr`</span>.</span>
<span id="cb73-294"><a href="#cb73-294" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-295"><a href="#cb73-295" aria-hidden="true" tabindex="-1"></a>This might sound weird to you if you come from a high-level language. Because in</span>
<span id="cb73-296"><a href="#cb73-296" aria-hidden="true" tabindex="-1"></a>high-level languages, such as Python, if an error occurs somewhere, this error is automatically</span>
<span id="cb73-297"><a href="#cb73-297" aria-hidden="true" tabindex="-1"></a>returned and the execution of your program will automatically stop even if you don't want</span>
<span id="cb73-298"><a href="#cb73-298" aria-hidden="true" tabindex="-1"></a>to stop the execution. You are obligated to face the error.</span>
<span id="cb73-299"><a href="#cb73-299" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-300"><a href="#cb73-300" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-303"><a href="#cb73-303" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-304"><a href="#cb73-304" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: false</span></span>
<span id="cb73-305"><a href="#cb73-305" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "ast"</span></span>
<span id="cb73-306"><a href="#cb73-306" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb73-307"><a href="#cb73-307" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-308"><a href="#cb73-308" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb73-309"><a href="#cb73-309" aria-hidden="true" tabindex="-1"></a><span class="in">    const stdout = std.io.getStdOut().writer();</span></span>
<span id="cb73-310"><a href="#cb73-310" aria-hidden="true" tabindex="-1"></a><span class="in">    try stdout.print("Hello, {s}!\n", .{"world"});</span></span>
<span id="cb73-311"><a href="#cb73-311" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb73-312"><a href="#cb73-312" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-313"><a href="#cb73-313" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-314"><a href="#cb73-314" aria-hidden="true" tabindex="-1"></a>Another thing that you might have noticed in this code example, is that</span>
<span id="cb73-315"><a href="#cb73-315" aria-hidden="true" tabindex="-1"></a>the <span class="in">`main()`</span> function is marked with the <span class="in">`pub`</span> keyword. It marks the <span class="in">`main()`</span></span>
<span id="cb73-316"><a href="#cb73-316" aria-hidden="true" tabindex="-1"></a>function as a *public function* from this module. Every function in your Zig</span>
<span id="cb73-317"><a href="#cb73-317" aria-hidden="true" tabindex="-1"></a>module is by default private to this Zig module and can only be called from within the module.</span>
<span id="cb73-318"><a href="#cb73-318" aria-hidden="true" tabindex="-1"></a>Unless, you explicitly mark this function as a public function with the <span class="in">`pub`</span> keyword.</span>
<span id="cb73-319"><a href="#cb73-319" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-320"><a href="#cb73-320" aria-hidden="true" tabindex="-1"></a>If you think about it, this <span class="in">`pub`</span> keyword in Zig does essentially the opposite of what the <span class="in">`static`</span> keyword</span>
<span id="cb73-321"><a href="#cb73-321" aria-hidden="true" tabindex="-1"></a>do in C/C++. By making a function "public" you allow other Zig modules to access and call this function.</span>
<span id="cb73-322"><a href="#cb73-322" aria-hidden="true" tabindex="-1"></a>A calling Zig module imports another module by using the <span class="in">`@import()`</span> built-in function, which makes</span>
<span id="cb73-323"><a href="#cb73-323" aria-hidden="true" tabindex="-1"></a>all public functions from the imported module visible to the calling Zig module.</span>
<span id="cb73-324"><a href="#cb73-324" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-325"><a href="#cb73-325" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-326"><a href="#cb73-326" aria-hidden="true" tabindex="-1"></a><span class="fu">### Compiling your source code {#sec-compile-code}</span></span>
<span id="cb73-327"><a href="#cb73-327" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-328"><a href="#cb73-328" aria-hidden="true" tabindex="-1"></a>You can compile your Zig modules into a binary executable by running the <span class="in">`build-exe`</span> command</span>
<span id="cb73-329"><a href="#cb73-329" aria-hidden="true" tabindex="-1"></a>from the <span class="in">`zig`</span> compiler. You simply list all the Zig modules that you want to build after</span>
<span id="cb73-330"><a href="#cb73-330" aria-hidden="true" tabindex="-1"></a>the <span class="in">`build-exe`</span> command, separated by spaces. In the example below, we are compiling the module <span class="in">`main.zig`</span>.</span>
<span id="cb73-331"><a href="#cb73-331" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-332"><a href="#cb73-332" aria-hidden="true" tabindex="-1"></a><span class="in">```bash</span></span>
<span id="cb73-333"><a href="#cb73-333" aria-hidden="true" tabindex="-1"></a><span class="ex">zig</span> build-exe src/main.zig</span>
<span id="cb73-334"><a href="#cb73-334" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-335"><a href="#cb73-335" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-336"><a href="#cb73-336" aria-hidden="true" tabindex="-1"></a>Since we are building an executable, the <span class="in">`zig`</span> compiler will look for a <span class="in">`main()`</span> function</span>
<span id="cb73-337"><a href="#cb73-337" aria-hidden="true" tabindex="-1"></a>declared in any of the files that you list after the <span class="in">`build-exe`</span> command. If</span>
<span id="cb73-338"><a href="#cb73-338" aria-hidden="true" tabindex="-1"></a>the compiler does not find a <span class="in">`main()`</span> function declared somewhere, a</span>
<span id="cb73-339"><a href="#cb73-339" aria-hidden="true" tabindex="-1"></a>compilation error will be raised, warning about this mistake.</span>
<span id="cb73-340"><a href="#cb73-340" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-341"><a href="#cb73-341" aria-hidden="true" tabindex="-1"></a>The <span class="in">`zig`</span> compiler also offers a <span class="in">`build-lib`</span> and <span class="in">`build-obj`</span> commands, which work</span>
<span id="cb73-342"><a href="#cb73-342" aria-hidden="true" tabindex="-1"></a>the exact same way as the <span class="in">`build-exe`</span> command. The only difference is that, they compile your</span>
<span id="cb73-343"><a href="#cb73-343" aria-hidden="true" tabindex="-1"></a>Zig modules into a portable C ABI library, or, into object files, respectively.</span>
<span id="cb73-344"><a href="#cb73-344" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-345"><a href="#cb73-345" aria-hidden="true" tabindex="-1"></a>In the case of the <span class="in">`build-exe`</span> command, a binary executable file is created by the <span class="in">`zig`</span></span>
<span id="cb73-346"><a href="#cb73-346" aria-hidden="true" tabindex="-1"></a>compiler in the root directory of your project.</span>
<span id="cb73-347"><a href="#cb73-347" aria-hidden="true" tabindex="-1"></a>If we take a look now at the contents of our current directory, with a simple <span class="in">`ls`</span> command, we can</span>
<span id="cb73-348"><a href="#cb73-348" aria-hidden="true" tabindex="-1"></a>see the binary file called <span class="in">`main`</span> that was created by the compiler.</span>
<span id="cb73-349"><a href="#cb73-349" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-350"><a href="#cb73-350" aria-hidden="true" tabindex="-1"></a><span class="in">```bash</span></span>
<span id="cb73-351"><a href="#cb73-351" aria-hidden="true" tabindex="-1"></a><span class="fu">ls</span></span>
<span id="cb73-352"><a href="#cb73-352" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-353"><a href="#cb73-353" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-354"><a href="#cb73-354" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-355"><a href="#cb73-355" aria-hidden="true" tabindex="-1"></a><span class="in">build.zig  build.zig.zon  main  src</span></span>
<span id="cb73-356"><a href="#cb73-356" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-357"><a href="#cb73-357" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-358"><a href="#cb73-358" aria-hidden="true" tabindex="-1"></a>If I execute this binary executable, I get the "Hello World" message in the terminal</span>
<span id="cb73-359"><a href="#cb73-359" aria-hidden="true" tabindex="-1"></a>, as we expected.</span>
<span id="cb73-360"><a href="#cb73-360" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-361"><a href="#cb73-361" aria-hidden="true" tabindex="-1"></a><span class="in">```bash</span></span>
<span id="cb73-362"><a href="#cb73-362" aria-hidden="true" tabindex="-1"></a><span class="ex">./main</span></span>
<span id="cb73-363"><a href="#cb73-363" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-364"><a href="#cb73-364" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-365"><a href="#cb73-365" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-366"><a href="#cb73-366" aria-hidden="true" tabindex="-1"></a><span class="in">Hello, world!</span></span>
<span id="cb73-367"><a href="#cb73-367" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-368"><a href="#cb73-368" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-369"><a href="#cb73-369" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-370"><a href="#cb73-370" aria-hidden="true" tabindex="-1"></a><span class="fu">### Compile and execute at the same time {#sec-compile-run-code}</span></span>
<span id="cb73-371"><a href="#cb73-371" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-372"><a href="#cb73-372" aria-hidden="true" tabindex="-1"></a>In the previous section, I presented the <span class="in">`zig build-exe`</span> command, which</span>
<span id="cb73-373"><a href="#cb73-373" aria-hidden="true" tabindex="-1"></a>compiles Zig modules into an executable file. However, this means that,</span>
<span id="cb73-374"><a href="#cb73-374" aria-hidden="true" tabindex="-1"></a>in order to execute the executable file, we have to run two different commands.</span>
<span id="cb73-375"><a href="#cb73-375" aria-hidden="true" tabindex="-1"></a>First, the <span class="in">`zig build-exe`</span> command, and then, we call the executable file</span>
<span id="cb73-376"><a href="#cb73-376" aria-hidden="true" tabindex="-1"></a>created by the compiler.</span>
<span id="cb73-377"><a href="#cb73-377" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-378"><a href="#cb73-378" aria-hidden="true" tabindex="-1"></a>But what if we wanted to perform these two steps,</span>
<span id="cb73-379"><a href="#cb73-379" aria-hidden="true" tabindex="-1"></a>all at once, in a single command? We can do that by using the <span class="in">`zig run`</span></span>
<span id="cb73-380"><a href="#cb73-380" aria-hidden="true" tabindex="-1"></a>command.</span>
<span id="cb73-381"><a href="#cb73-381" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-382"><a href="#cb73-382" aria-hidden="true" tabindex="-1"></a><span class="in">```bash</span></span>
<span id="cb73-383"><a href="#cb73-383" aria-hidden="true" tabindex="-1"></a><span class="ex">zig</span> run src/main.zig</span>
<span id="cb73-384"><a href="#cb73-384" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-385"><a href="#cb73-385" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-386"><a href="#cb73-386" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-387"><a href="#cb73-387" aria-hidden="true" tabindex="-1"></a><span class="in">Hello, world!</span></span>
<span id="cb73-388"><a href="#cb73-388" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-389"><a href="#cb73-389" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-390"><a href="#cb73-390" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-391"><a href="#cb73-391" aria-hidden="true" tabindex="-1"></a><span class="fu">### Important note for Windows users</span></span>
<span id="cb73-392"><a href="#cb73-392" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-393"><a href="#cb73-393" aria-hidden="true" tabindex="-1"></a>First of all, this is a Windows-specific thing, and, therefore, does not apply to other</span>
<span id="cb73-394"><a href="#cb73-394" aria-hidden="true" tabindex="-1"></a>operating systems, such as Linux and macOS. In summary, if you have a piece of Zig code that</span>
<span id="cb73-395"><a href="#cb73-395" aria-hidden="true" tabindex="-1"></a>includes some global variables whose initialization rely on runtime resources, then,</span>
<span id="cb73-396"><a href="#cb73-396" aria-hidden="true" tabindex="-1"></a>you might have some troubles while trying to compile this Zig code on Windows.</span>
<span id="cb73-397"><a href="#cb73-397" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-398"><a href="#cb73-398" aria-hidden="true" tabindex="-1"></a>An example of that is accessing the <span class="in">`stdout`</span> (i.e., the *standard output* of your system), which is usually</span>
<span id="cb73-399"><a href="#cb73-399" aria-hidden="true" tabindex="-1"></a>done in Zig by using the expression <span class="in">`std.io.getStdOut()`</span>. If you use this expression to instantiate</span>
<span id="cb73-400"><a href="#cb73-400" aria-hidden="true" tabindex="-1"></a>a global variable in a Zig module, then, the compilation of your Zig code will very likely fail on Windows,</span>
<span id="cb73-401"><a href="#cb73-401" aria-hidden="true" tabindex="-1"></a>with an "unable to evaluate comptime expression" error message.</span>
<span id="cb73-402"><a href="#cb73-402" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-403"><a href="#cb73-403" aria-hidden="true" tabindex="-1"></a>This failure in the compilation process happens because all global variables in Zig are initialized</span>
<span id="cb73-404"><a href="#cb73-404" aria-hidden="true" tabindex="-1"></a>at *compile-time*. However, on Windows, operations like accessing the <span class="in">`stdout`</span> (or opening a file) depend on</span>
<span id="cb73-405"><a href="#cb73-405" aria-hidden="true" tabindex="-1"></a>resources that are available only at *runtime* (you will learn more about compile-time versus runtime</span>
<span id="cb73-406"><a href="#cb73-406" aria-hidden="true" tabindex="-1"></a>in @sec-compile-time).</span>
<span id="cb73-407"><a href="#cb73-407" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-408"><a href="#cb73-408" aria-hidden="true" tabindex="-1"></a>For example, if you try to compile this code example on Windows, you will likely get the error message</span>
<span id="cb73-409"><a href="#cb73-409" aria-hidden="true" tabindex="-1"></a>exposed below:</span>
<span id="cb73-410"><a href="#cb73-410" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-413"><a href="#cb73-413" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-414"><a href="#cb73-414" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: false</span></span>
<span id="cb73-415"><a href="#cb73-415" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "ast"</span></span>
<span id="cb73-416"><a href="#cb73-416" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb73-417"><a href="#cb73-417" aria-hidden="true" tabindex="-1"></a><span class="in">// ERROR! Compile-time error that emerges from</span></span>
<span id="cb73-418"><a href="#cb73-418" aria-hidden="true" tabindex="-1"></a><span class="in">// this next line, on the `stdout` object</span></span>
<span id="cb73-419"><a href="#cb73-419" aria-hidden="true" tabindex="-1"></a><span class="in">const stdout = std.io.getStdOut().writer();</span></span>
<span id="cb73-420"><a href="#cb73-420" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-421"><a href="#cb73-421" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb73-422"><a href="#cb73-422" aria-hidden="true" tabindex="-1"></a><span class="in">    _ = try stdout.write("Hello\n");</span></span>
<span id="cb73-423"><a href="#cb73-423" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb73-424"><a href="#cb73-424" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-425"><a href="#cb73-425" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-426"><a href="#cb73-426" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-427"><a href="#cb73-427" aria-hidden="true" tabindex="-1"></a><span class="in">t.zig:2107:28: error: unable to evaluate comptime expression</span></span>
<span id="cb73-428"><a href="#cb73-428" aria-hidden="true" tabindex="-1"></a><span class="in">    break :blk asm {</span></span>
<span id="cb73-429"><a href="#cb73-429" aria-hidden="true" tabindex="-1"></a><span class="in">               ^~~</span></span>
<span id="cb73-430"><a href="#cb73-430" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-431"><a href="#cb73-431" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-432"><a href="#cb73-432" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-433"><a href="#cb73-433" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-434"><a href="#cb73-434" aria-hidden="true" tabindex="-1"></a>To avoid this problem on Windows, we need to force the <span class="in">`zig`</span> compiler to instantiate this</span>
<span id="cb73-435"><a href="#cb73-435" aria-hidden="true" tabindex="-1"></a><span class="in">`stdout`</span> object only at runtime, instead of instantiating it at compile-time. We can achieve</span>
<span id="cb73-436"><a href="#cb73-436" aria-hidden="true" tabindex="-1"></a>that by simply moving the expression to a function body.</span>
<span id="cb73-437"><a href="#cb73-437" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-438"><a href="#cb73-438" aria-hidden="true" tabindex="-1"></a>This solves the problem because all expressions that are inside a function body in Zig</span>
<span id="cb73-439"><a href="#cb73-439" aria-hidden="true" tabindex="-1"></a>are evaluated only at runtime, unless you use the <span class="in">`comptime`</span> keyword explicitly to change this behaviour.</span>
<span id="cb73-440"><a href="#cb73-440" aria-hidden="true" tabindex="-1"></a>You will learn more about this <span class="in">`comptime`</span> keyword in @sec-comptime.</span>
<span id="cb73-441"><a href="#cb73-441" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-442"><a href="#cb73-442" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-445"><a href="#cb73-445" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-446"><a href="#cb73-446" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "ast"</span></span>
<span id="cb73-447"><a href="#cb73-447" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: false</span></span>
<span id="cb73-448"><a href="#cb73-448" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb73-449"><a href="#cb73-449" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb73-450"><a href="#cb73-450" aria-hidden="true" tabindex="-1"></a><span class="in">    // SUCCESS: Stdout initialized at runtime.</span></span>
<span id="cb73-451"><a href="#cb73-451" aria-hidden="true" tabindex="-1"></a><span class="in">    const stdout = std.io.getStdOut().writer();</span></span>
<span id="cb73-452"><a href="#cb73-452" aria-hidden="true" tabindex="-1"></a><span class="in">    _ = try stdout.write("Hello\n");</span></span>
<span id="cb73-453"><a href="#cb73-453" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb73-454"><a href="#cb73-454" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-455"><a href="#cb73-455" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-456"><a href="#cb73-456" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-457"><a href="#cb73-457" aria-hidden="true" tabindex="-1"></a><span class="in">Hello</span></span>
<span id="cb73-458"><a href="#cb73-458" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-459"><a href="#cb73-459" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-460"><a href="#cb73-460" aria-hidden="true" tabindex="-1"></a>You can read more details about this Windows-specific limitation in a couple of</span>
<span id="cb73-461"><a href="#cb73-461" aria-hidden="true" tabindex="-1"></a>GitHub issues opened at the official Zig repository. More specifically, the issues</span>
<span id="cb73-462"><a href="#cb73-462" aria-hidden="true" tabindex="-1"></a>17186 <span class="ot">[^cissue1]</span> and 19864 <span class="ot">[^cissue2]</span>.</span>
<span id="cb73-463"><a href="#cb73-463" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-464"><a href="#cb73-464" aria-hidden="true" tabindex="-1"></a><span class="ot">[^cissue1]: &lt;https://github.com/ziglang/zig/issues/17186&gt;</span></span>
<span id="cb73-465"><a href="#cb73-465" aria-hidden="true" tabindex="-1"></a><span class="ot">[^cissue2]: &lt;https://github.com/ziglang/zig/issues/19864&gt;</span></span>
<span id="cb73-466"><a href="#cb73-466" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-467"><a href="#cb73-467" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-468"><a href="#cb73-468" aria-hidden="true" tabindex="-1"></a><span class="fu">### Compiling the entire project {#sec-compile-project}</span></span>
<span id="cb73-469"><a href="#cb73-469" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-470"><a href="#cb73-470" aria-hidden="true" tabindex="-1"></a>Just as I described in @sec-project-files, as our project grows in size and</span>
<span id="cb73-471"><a href="#cb73-471" aria-hidden="true" tabindex="-1"></a>complexity, we usually prefer to organize the compilation and build process</span>
<span id="cb73-472"><a href="#cb73-472" aria-hidden="true" tabindex="-1"></a>of the project into a build script, using some sort of "build system".</span>
<span id="cb73-473"><a href="#cb73-473" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-474"><a href="#cb73-474" aria-hidden="true" tabindex="-1"></a>In other words, as our project grows in size and complexity,</span>
<span id="cb73-475"><a href="#cb73-475" aria-hidden="true" tabindex="-1"></a>the <span class="in">`build-exe`</span>, <span class="in">`build-lib`</span> and <span class="in">`build-obj`</span> commands become</span>
<span id="cb73-476"><a href="#cb73-476" aria-hidden="true" tabindex="-1"></a>harder to use directly. Because then, we start to list</span>
<span id="cb73-477"><a href="#cb73-477" aria-hidden="true" tabindex="-1"></a>multiple and multiple modules at the same time. We also</span>
<span id="cb73-478"><a href="#cb73-478" aria-hidden="true" tabindex="-1"></a>start to add built-in compilation flags to customize the</span>
<span id="cb73-479"><a href="#cb73-479" aria-hidden="true" tabindex="-1"></a>build process for our needs, etc. It becomes a lot of work</span>
<span id="cb73-480"><a href="#cb73-480" aria-hidden="true" tabindex="-1"></a>to write the necessary commands by hand.</span>
<span id="cb73-481"><a href="#cb73-481" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-482"><a href="#cb73-482" aria-hidden="true" tabindex="-1"></a>In C/C++ projects, programmers normally opt to use CMake, Ninja, <span class="in">`Makefile`</span> or <span class="in">`configure`</span> scripts</span>
<span id="cb73-483"><a href="#cb73-483" aria-hidden="true" tabindex="-1"></a>to organize this process. However, in Zig, we have a native build system in the language itself.</span>
<span id="cb73-484"><a href="#cb73-484" aria-hidden="true" tabindex="-1"></a>So, we can write build scripts in Zig to compile and build Zig projects. Then, all we</span>
<span id="cb73-485"><a href="#cb73-485" aria-hidden="true" tabindex="-1"></a>need to do, is to call the <span class="in">`zig build`</span> command to build our project.</span>
<span id="cb73-486"><a href="#cb73-486" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-487"><a href="#cb73-487" aria-hidden="true" tabindex="-1"></a>So, when you execute the <span class="in">`zig build`</span> command, the <span class="in">`zig`</span> compiler will search</span>
<span id="cb73-488"><a href="#cb73-488" aria-hidden="true" tabindex="-1"></a>for a Zig module named <span class="in">`build.zig`</span> inside your current directory, which</span>
<span id="cb73-489"><a href="#cb73-489" aria-hidden="true" tabindex="-1"></a>should be your build script, containing the necessary code to compile and</span>
<span id="cb73-490"><a href="#cb73-490" aria-hidden="true" tabindex="-1"></a>build your project. If the compiler does find this <span class="in">`build.zig`</span> file in your directory,</span>
<span id="cb73-491"><a href="#cb73-491" aria-hidden="true" tabindex="-1"></a>then, the compiler will essentially execute a <span class="in">`zig run`</span> command</span>
<span id="cb73-492"><a href="#cb73-492" aria-hidden="true" tabindex="-1"></a>over this <span class="in">`build.zig`</span> file, to compile and execute this build</span>
<span id="cb73-493"><a href="#cb73-493" aria-hidden="true" tabindex="-1"></a>script, which in turn, will compile and build your entire project.</span>
<span id="cb73-494"><a href="#cb73-494" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-495"><a href="#cb73-495" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-496"><a href="#cb73-496" aria-hidden="true" tabindex="-1"></a><span class="in">```bash</span></span>
<span id="cb73-497"><a href="#cb73-497" aria-hidden="true" tabindex="-1"></a><span class="ex">zig</span> build</span>
<span id="cb73-498"><a href="#cb73-498" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-499"><a href="#cb73-499" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-500"><a href="#cb73-500" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-501"><a href="#cb73-501" aria-hidden="true" tabindex="-1"></a>After you execute this "build project" command, a <span class="in">`zig-out`</span> directory</span>
<span id="cb73-502"><a href="#cb73-502" aria-hidden="true" tabindex="-1"></a>is created in the root of your project directory, where you can find</span>
<span id="cb73-503"><a href="#cb73-503" aria-hidden="true" tabindex="-1"></a>the binary executables and libraries created from your Zig modules</span>
<span id="cb73-504"><a href="#cb73-504" aria-hidden="true" tabindex="-1"></a>accordingly to the build commands that you specified at <span class="in">`build.zig`</span>.</span>
<span id="cb73-505"><a href="#cb73-505" aria-hidden="true" tabindex="-1"></a>We will talk more about the build system in Zig later in this book.</span>
<span id="cb73-506"><a href="#cb73-506" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-507"><a href="#cb73-507" aria-hidden="true" tabindex="-1"></a>In the example below, I'm executing the binary executable</span>
<span id="cb73-508"><a href="#cb73-508" aria-hidden="true" tabindex="-1"></a>named <span class="in">`hello_world`</span> that was generated by the compiler after the</span>
<span id="cb73-509"><a href="#cb73-509" aria-hidden="true" tabindex="-1"></a><span class="in">`zig build`</span> command.</span>
<span id="cb73-510"><a href="#cb73-510" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-511"><a href="#cb73-511" aria-hidden="true" tabindex="-1"></a><span class="in">```bash</span></span>
<span id="cb73-512"><a href="#cb73-512" aria-hidden="true" tabindex="-1"></a><span class="ex">./zig-out/bin/hello_world</span></span>
<span id="cb73-513"><a href="#cb73-513" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-514"><a href="#cb73-514" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-515"><a href="#cb73-515" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-516"><a href="#cb73-516" aria-hidden="true" tabindex="-1"></a><span class="in">Hello, world!</span></span>
<span id="cb73-517"><a href="#cb73-517" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-518"><a href="#cb73-518" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-519"><a href="#cb73-519" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-520"><a href="#cb73-520" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-521"><a href="#cb73-521" aria-hidden="true" tabindex="-1"></a><span class="fu">## How to learn Zig?</span></span>
<span id="cb73-522"><a href="#cb73-522" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-523"><a href="#cb73-523" aria-hidden="true" tabindex="-1"></a>What are the best strategies to learn Zig?</span>
<span id="cb73-524"><a href="#cb73-524" aria-hidden="true" tabindex="-1"></a>First of all, of course this book will help you a lot on your journey through Zig.</span>
<span id="cb73-525"><a href="#cb73-525" aria-hidden="true" tabindex="-1"></a>But you will also need some extra resources if you want to be really good at Zig.</span>
<span id="cb73-526"><a href="#cb73-526" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-527"><a href="#cb73-527" aria-hidden="true" tabindex="-1"></a>As a first tip, you can join a community with Zig programmers to get some help</span>
<span id="cb73-528"><a href="#cb73-528" aria-hidden="true" tabindex="-1"></a>, when you need it:</span>
<span id="cb73-529"><a href="#cb73-529" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-530"><a href="#cb73-530" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Reddit forum: <span class="ot">&lt;https://www.reddit.com/r/Zig/&gt;</span>;</span>
<span id="cb73-531"><a href="#cb73-531" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Ziggit community: <span class="ot">&lt;https://ziggit.dev/&gt;</span>;</span>
<span id="cb73-532"><a href="#cb73-532" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Discord, Slack, Telegram, and others: <span class="ot">&lt;https://github.com/ziglang/zig/wiki/Community&gt;</span>;</span>
<span id="cb73-533"><a href="#cb73-533" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-534"><a href="#cb73-534" aria-hidden="true" tabindex="-1"></a>Now, one of the best ways to learn Zig is to simply read Zig code. Try</span>
<span id="cb73-535"><a href="#cb73-535" aria-hidden="true" tabindex="-1"></a>to read Zig code often, and things will become more clear.</span>
<span id="cb73-536"><a href="#cb73-536" aria-hidden="true" tabindex="-1"></a>A C/C++ programmer would also probably give you this same tip.</span>
<span id="cb73-537"><a href="#cb73-537" aria-hidden="true" tabindex="-1"></a>Because this strategy really works!</span>
<span id="cb73-538"><a href="#cb73-538" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-539"><a href="#cb73-539" aria-hidden="true" tabindex="-1"></a>Now, where can you find Zig code to read?</span>
<span id="cb73-540"><a href="#cb73-540" aria-hidden="true" tabindex="-1"></a>I personally think that, the best way of reading Zig code is to read the source code of the</span>
<span id="cb73-541"><a href="#cb73-541" aria-hidden="true" tabindex="-1"></a>Zig Standard Library. The Zig Standard Library is available at the <span class="co">[</span><span class="ot">`lib/std` folder</span><span class="co">](https://github.com/ziglang/zig/tree/master/lib/std)</span><span class="ot">[^zig-lib-std]</span> on</span>
<span id="cb73-542"><a href="#cb73-542" aria-hidden="true" tabindex="-1"></a>the official GitHub repository of Zig. Access this folder, and start exploring the Zig modules.</span>
<span id="cb73-543"><a href="#cb73-543" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-544"><a href="#cb73-544" aria-hidden="true" tabindex="-1"></a>Also, a great alternative is to read code from other large Zig</span>
<span id="cb73-545"><a href="#cb73-545" aria-hidden="true" tabindex="-1"></a>codebases, such as:</span>
<span id="cb73-546"><a href="#cb73-546" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-547"><a href="#cb73-547" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>the <span class="co">[</span><span class="ot">Javascript runtime Bun</span><span class="co">](https://github.com/oven-sh/bun)</span><span class="ot">[^bunjs]</span>.</span>
<span id="cb73-548"><a href="#cb73-548" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>the <span class="co">[</span><span class="ot">game engine Mach</span><span class="co">](https://github.com/hexops/mach)</span><span class="ot">[^mach]</span>.</span>
<span id="cb73-549"><a href="#cb73-549" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>a <span class="co">[</span><span class="ot">LLama 2 LLM model implementation in Zig</span><span class="co">](https://github.com/cgbur/llama2.zig/tree/main)</span><span class="ot">[^ll2]</span>.</span>
<span id="cb73-550"><a href="#cb73-550" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>the <span class="co">[</span><span class="ot">financial transactions database `tigerbeetle`</span><span class="co">](https://github.com/tigerbeetle/tigerbeetle)</span><span class="ot">[^tiger]</span>.</span>
<span id="cb73-551"><a href="#cb73-551" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>the <span class="co">[</span><span class="ot">command-line arguments parser `zig-clap`</span><span class="co">](https://github.com/Hejsil/zig-clap)</span><span class="ot">[^clap]</span>.</span>
<span id="cb73-552"><a href="#cb73-552" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>the <span class="co">[</span><span class="ot">UI framework `capy`</span><span class="co">](https://github.com/capy-ui/capy)</span><span class="ot">[^capy]</span>.</span>
<span id="cb73-553"><a href="#cb73-553" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>the <span class="co">[</span><span class="ot">Language Protocol implementation for Zig, `zls`</span><span class="co">](https://github.com/zigtools/zls)</span><span class="ot">[^zls]</span>.</span>
<span id="cb73-554"><a href="#cb73-554" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>the <span class="co">[</span><span class="ot">event-loop library `libxev`</span><span class="co">](https://github.com/mitchellh/libxev)</span><span class="ot">[^xev]</span>.</span>
<span id="cb73-555"><a href="#cb73-555" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-556"><a href="#cb73-556" aria-hidden="true" tabindex="-1"></a><span class="ot">[^xev]: &lt;https://github.com/mitchellh/libxev&gt;</span></span>
<span id="cb73-557"><a href="#cb73-557" aria-hidden="true" tabindex="-1"></a><span class="ot">[^zls]: &lt;https://github.com/zigtools/zls&gt;</span></span>
<span id="cb73-558"><a href="#cb73-558" aria-hidden="true" tabindex="-1"></a><span class="ot">[^capy]: &lt;https://github.com/capy-ui/capy&gt;</span></span>
<span id="cb73-559"><a href="#cb73-559" aria-hidden="true" tabindex="-1"></a><span class="ot">[^clap]: &lt;https://github.com/Hejsil/zig-clap&gt;</span></span>
<span id="cb73-560"><a href="#cb73-560" aria-hidden="true" tabindex="-1"></a><span class="ot">[^tiger]: &lt;https://github.com/tigerbeetle/tigerbeetle&gt;</span></span>
<span id="cb73-561"><a href="#cb73-561" aria-hidden="true" tabindex="-1"></a><span class="ot">[^ll2]: &lt;https://github.com/cgbur/llama2.zig/tree/main&gt;</span></span>
<span id="cb73-562"><a href="#cb73-562" aria-hidden="true" tabindex="-1"></a><span class="ot">[^mach]: &lt;https://github.com/hexops/mach&gt;</span></span>
<span id="cb73-563"><a href="#cb73-563" aria-hidden="true" tabindex="-1"></a><span class="ot">[^bunjs]: &lt;https://github.com/oven-sh/bun&gt;</span>.</span>
<span id="cb73-564"><a href="#cb73-564" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-565"><a href="#cb73-565" aria-hidden="true" tabindex="-1"></a>All these assets are available on GitHub,</span>
<span id="cb73-566"><a href="#cb73-566" aria-hidden="true" tabindex="-1"></a>and this is great, because we can use the GitHub search bar to our advantage,</span>
<span id="cb73-567"><a href="#cb73-567" aria-hidden="true" tabindex="-1"></a>to find Zig code that fits our description.</span>
<span id="cb73-568"><a href="#cb73-568" aria-hidden="true" tabindex="-1"></a>For example, you can always include <span class="in">`lang:Zig`</span> in the GitHub search bar when you</span>
<span id="cb73-569"><a href="#cb73-569" aria-hidden="true" tabindex="-1"></a>are searching for a particular pattern. This will limit the search to only Zig modules.</span>
<span id="cb73-570"><a href="#cb73-570" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-571"><a href="#cb73-571" aria-hidden="true" tabindex="-1"></a><span class="ot">[^zig-lib-std]: &lt;https://github.com/ziglang/zig/tree/master/lib/std&gt;</span></span>
<span id="cb73-572"><a href="#cb73-572" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-573"><a href="#cb73-573" aria-hidden="true" tabindex="-1"></a>Also, a great alternative is to consult online resources and documentation.</span>
<span id="cb73-574"><a href="#cb73-574" aria-hidden="true" tabindex="-1"></a>Here is a quick list of resources that I personally use from time to time to learn</span>
<span id="cb73-575"><a href="#cb73-575" aria-hidden="true" tabindex="-1"></a>more about the language each day:</span>
<span id="cb73-576"><a href="#cb73-576" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-577"><a href="#cb73-577" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Zig Language Reference: <span class="ot">&lt;https://ziglang.org/documentation/master/&gt;</span>;</span>
<span id="cb73-578"><a href="#cb73-578" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Zig Standard Library Reference: <span class="ot">&lt;https://ziglang.org/documentation/master/std/&gt;</span>;</span>
<span id="cb73-579"><a href="#cb73-579" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Zig Guide: <span class="ot">&lt;https://zig.guide/&gt;</span>;</span>
<span id="cb73-580"><a href="#cb73-580" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Karl Seguin Blog: <span class="ot">&lt;https://www.openmymind.net/&gt;</span>;</span>
<span id="cb73-581"><a href="#cb73-581" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Zig News: <span class="ot">&lt;https://zig.news/&gt;</span>;</span>
<span id="cb73-582"><a href="#cb73-582" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Read the code written by one of the Zig core team members: <span class="ot">&lt;https://github.com/kubkon&gt;</span>;</span>
<span id="cb73-583"><a href="#cb73-583" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Some livecoding sessions are transmitted in the Zig Showtime Youtube Channel: <span class="ot">&lt;https://www.youtube.com/@ZigSHOWTIME/videos&gt;</span>;</span>
<span id="cb73-584"><a href="#cb73-584" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-585"><a href="#cb73-585" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-586"><a href="#cb73-586" aria-hidden="true" tabindex="-1"></a>Another great strategy to learn Zig, or honestly, to learn any language you want,</span>
<span id="cb73-587"><a href="#cb73-587" aria-hidden="true" tabindex="-1"></a>is to practice it by solving exercises. For example, there is a famous repository</span>
<span id="cb73-588"><a href="#cb73-588" aria-hidden="true" tabindex="-1"></a>in the Zig community called <span class="co">[</span><span class="ot">Ziglings</span><span class="co">](https://ziglings.org)</span><span class="ot">[^ziglings]</span></span>
<span id="cb73-589"><a href="#cb73-589" aria-hidden="true" tabindex="-1"></a>, which contains more than 100 small exercises that you can solve. It's a repository of</span>
<span id="cb73-590"><a href="#cb73-590" aria-hidden="true" tabindex="-1"></a>tiny programs written in Zig that are currently broken, and your responsibility is to</span>
<span id="cb73-591"><a href="#cb73-591" aria-hidden="true" tabindex="-1"></a>fix these programs, and make them work again.</span>
<span id="cb73-592"><a href="#cb73-592" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-593"><a href="#cb73-593" aria-hidden="true" tabindex="-1"></a><span class="ot">[^ziglings]: &lt;https://ziglings.org&gt;</span>.</span>
<span id="cb73-594"><a href="#cb73-594" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-595"><a href="#cb73-595" aria-hidden="true" tabindex="-1"></a>A famous tech YouTuber known as *The Primeagen* also posted some videos (on YouTube)</span>
<span id="cb73-596"><a href="#cb73-596" aria-hidden="true" tabindex="-1"></a>where he solves these exercises from Ziglings. The first video is named</span>
<span id="cb73-597"><a href="#cb73-597" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">"Trying Zig Part 1"</span><span class="co">](https://www.youtube.com/watch?v=OPuztQfM3Fg&amp;t=2524s&amp;ab_channel=TheVimeagen)</span><span class="ot">[^prime1]</span>.</span>
<span id="cb73-598"><a href="#cb73-598" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-599"><a href="#cb73-599" aria-hidden="true" tabindex="-1"></a><span class="ot">[^prime1]: &lt;https://www.youtube.com/watch?v=OPuztQfM3Fg&amp;t=2524s&amp;ab_channel=TheVimeagen&gt;</span>.</span>
<span id="cb73-600"><a href="#cb73-600" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-601"><a href="#cb73-601" aria-hidden="true" tabindex="-1"></a>Another great alternative, is to solve the <span class="co">[</span><span class="ot">Advent of Code exercises</span><span class="co">](https://adventofcode.com/)</span><span class="ot">[^advent-code]</span>.</span>
<span id="cb73-602"><a href="#cb73-602" aria-hidden="true" tabindex="-1"></a>There are people that already took the time to learn and solve the exercises, and they posted</span>
<span id="cb73-603"><a href="#cb73-603" aria-hidden="true" tabindex="-1"></a>their solutions on GitHub as well, so, in case you need some resource to compare while solving</span>
<span id="cb73-604"><a href="#cb73-604" aria-hidden="true" tabindex="-1"></a>the exercises, you can look at these two repositories:</span>
<span id="cb73-605"><a href="#cb73-605" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-606"><a href="#cb73-606" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="ot">&lt;https://github.com/SpexGuy/Zig-AoC-Template&gt;</span>;</span>
<span id="cb73-607"><a href="#cb73-607" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="ot">&lt;https://github.com/fjebaker/advent-of-code-2022&gt;</span>;</span>
<span id="cb73-608"><a href="#cb73-608" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-609"><a href="#cb73-609" aria-hidden="true" tabindex="-1"></a><span class="ot">[^advent-code]: &lt;https://adventofcode.com/&gt;</span></span>
<span id="cb73-610"><a href="#cb73-610" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-611"><a href="#cb73-611" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-612"><a href="#cb73-612" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-613"><a href="#cb73-613" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-614"><a href="#cb73-614" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-615"><a href="#cb73-615" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-616"><a href="#cb73-616" aria-hidden="true" tabindex="-1"></a><span class="fu">## Creating new objects in Zig (i.e., identifiers) {#sec-assignments}</span></span>
<span id="cb73-617"><a href="#cb73-617" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-618"><a href="#cb73-618" aria-hidden="true" tabindex="-1"></a>Let's talk more about objects in Zig. Readers that have past experience</span>
<span id="cb73-619"><a href="#cb73-619" aria-hidden="true" tabindex="-1"></a>with other programming languages might know this concept through</span>
<span id="cb73-620"><a href="#cb73-620" aria-hidden="true" tabindex="-1"></a>a different name, such as: "variable" or "identifier". In this book, I choose</span>
<span id="cb73-621"><a href="#cb73-621" aria-hidden="true" tabindex="-1"></a>to use the term "object" to refer to this concept.</span>
<span id="cb73-622"><a href="#cb73-622" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-623"><a href="#cb73-623" aria-hidden="true" tabindex="-1"></a>To create a new object (or a new "identifier") in Zig, we use</span>
<span id="cb73-624"><a href="#cb73-624" aria-hidden="true" tabindex="-1"></a>the keywords <span class="in">`const`</span> or <span class="in">`var`</span>. These keywords specify if the object</span>
<span id="cb73-625"><a href="#cb73-625" aria-hidden="true" tabindex="-1"></a>that you are creating is mutable or not.</span>
<span id="cb73-626"><a href="#cb73-626" aria-hidden="true" tabindex="-1"></a>If you use <span class="in">`const`</span>, then the object you are</span>
<span id="cb73-627"><a href="#cb73-627" aria-hidden="true" tabindex="-1"></a>creating is a constant (or immutable) object, which means that once you declare this object, you</span>
<span id="cb73-628"><a href="#cb73-628" aria-hidden="true" tabindex="-1"></a>can no longer change the value stored inside this object.</span>
<span id="cb73-629"><a href="#cb73-629" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-630"><a href="#cb73-630" aria-hidden="true" tabindex="-1"></a>On the other side, if you use <span class="in">`var`</span>, then, you are creating a variable (or mutable) object.</span>
<span id="cb73-631"><a href="#cb73-631" aria-hidden="true" tabindex="-1"></a>You can change the value of this object as many times you want. Using the</span>
<span id="cb73-632"><a href="#cb73-632" aria-hidden="true" tabindex="-1"></a>keyword <span class="in">`var`</span> in Zig is similar to using the keywords <span class="in">`let mut`</span> in Rust.</span>
<span id="cb73-633"><a href="#cb73-633" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-634"><a href="#cb73-634" aria-hidden="true" tabindex="-1"></a><span class="fu">### Constant objects vs variable objects</span></span>
<span id="cb73-635"><a href="#cb73-635" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-636"><a href="#cb73-636" aria-hidden="true" tabindex="-1"></a>In the code example below, we are creating a new constant object called <span class="in">`age`</span>.</span>
<span id="cb73-637"><a href="#cb73-637" aria-hidden="true" tabindex="-1"></a>This object stores a number representing the age of someone. However, this code example</span>
<span id="cb73-638"><a href="#cb73-638" aria-hidden="true" tabindex="-1"></a>does not compile successfully. Because on the next line of code, we are trying to change the value</span>
<span id="cb73-639"><a href="#cb73-639" aria-hidden="true" tabindex="-1"></a>of the object <span class="in">`age`</span> to 25.</span>
<span id="cb73-640"><a href="#cb73-640" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-641"><a href="#cb73-641" aria-hidden="true" tabindex="-1"></a>The <span class="in">`zig`</span> compiler detects that we are trying to change</span>
<span id="cb73-642"><a href="#cb73-642" aria-hidden="true" tabindex="-1"></a>the value of an object/identifier that is constant, and because of that,</span>
<span id="cb73-643"><a href="#cb73-643" aria-hidden="true" tabindex="-1"></a>the compiler will raise a compilation error, warning us about the mistake.</span>
<span id="cb73-644"><a href="#cb73-644" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-647"><a href="#cb73-647" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-648"><a href="#cb73-648" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb73-649"><a href="#cb73-649" aria-hidden="true" tabindex="-1"></a><span class="in">const age = 24;</span></span>
<span id="cb73-650"><a href="#cb73-650" aria-hidden="true" tabindex="-1"></a><span class="in">// The line below is not valid!</span></span>
<span id="cb73-651"><a href="#cb73-651" aria-hidden="true" tabindex="-1"></a><span class="in">age = 25;</span></span>
<span id="cb73-652"><a href="#cb73-652" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-653"><a href="#cb73-653" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-654"><a href="#cb73-654" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-655"><a href="#cb73-655" aria-hidden="true" tabindex="-1"></a><span class="in">t.zig:10:5: error: cannot assign to constant</span></span>
<span id="cb73-656"><a href="#cb73-656" aria-hidden="true" tabindex="-1"></a><span class="in">    age = 25;</span></span>
<span id="cb73-657"><a href="#cb73-657" aria-hidden="true" tabindex="-1"></a><span class="in">      ~~^~~</span></span>
<span id="cb73-658"><a href="#cb73-658" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-659"><a href="#cb73-659" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-660"><a href="#cb73-660" aria-hidden="true" tabindex="-1"></a>So, if you want to change the value of your object, you need to transform your immutable (or "constant")</span>
<span id="cb73-661"><a href="#cb73-661" aria-hidden="true" tabindex="-1"></a>object into a mutable (or "variable") object. You can do that by using the <span class="in">`var`</span> keyword.</span>
<span id="cb73-662"><a href="#cb73-662" aria-hidden="true" tabindex="-1"></a>This keyword stands for "variable", and when you apply this keyword to some object, you are</span>
<span id="cb73-663"><a href="#cb73-663" aria-hidden="true" tabindex="-1"></a>telling the Zig compiler that the value associated with this object might change at some point.</span>
<span id="cb73-664"><a href="#cb73-664" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-665"><a href="#cb73-665" aria-hidden="true" tabindex="-1"></a>Thus, if we come back to the previous example, and change the declaration of the</span>
<span id="cb73-666"><a href="#cb73-666" aria-hidden="true" tabindex="-1"></a><span class="in">`age`</span> object to use the <span class="in">`var`</span> keyword, then, the program gets compiled successfully.</span>
<span id="cb73-667"><a href="#cb73-667" aria-hidden="true" tabindex="-1"></a>Because now, the <span class="in">`zig`</span> compiler detects that we are changing the value of an</span>
<span id="cb73-668"><a href="#cb73-668" aria-hidden="true" tabindex="-1"></a>object that allows this behaviour, because it's a "variable object".</span>
<span id="cb73-669"><a href="#cb73-669" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-670"><a href="#cb73-670" aria-hidden="true" tabindex="-1"></a>However, if you take a look at the example below, you will notice that we have not only declared the</span>
<span id="cb73-671"><a href="#cb73-671" aria-hidden="true" tabindex="-1"></a><span class="in">`age`</span> object with the <span class="in">`var`</span> keyword, but we also have explicitly annotated the data type</span>
<span id="cb73-672"><a href="#cb73-672" aria-hidden="true" tabindex="-1"></a>of the <span class="in">`age`</span> object with the <span class="in">`u8`</span> type this time. The basic idea is, when we use a variable/mutable object,</span>
<span id="cb73-673"><a href="#cb73-673" aria-hidden="true" tabindex="-1"></a>the Zig compiler ask for us to be more explicit with what we want, to be more clear</span>
<span id="cb73-674"><a href="#cb73-674" aria-hidden="true" tabindex="-1"></a>about what our code does. This translates into being more explicit about the data types that we want</span>
<span id="cb73-675"><a href="#cb73-675" aria-hidden="true" tabindex="-1"></a>to use in our objects.</span>
<span id="cb73-676"><a href="#cb73-676" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-677"><a href="#cb73-677" aria-hidden="true" tabindex="-1"></a>Therefore, if you transform your object into a variable/mutable object, just remember to always</span>
<span id="cb73-678"><a href="#cb73-678" aria-hidden="true" tabindex="-1"></a>annotate the type of the object explicitly in your code. Otherwise, the Zig compiler might raise</span>
<span id="cb73-679"><a href="#cb73-679" aria-hidden="true" tabindex="-1"></a>a compilation error, asking you to transform your object back into a <span class="in">`const`</span> object, or,</span>
<span id="cb73-680"><a href="#cb73-680" aria-hidden="true" tabindex="-1"></a>to give your object an "explicit type".</span>
<span id="cb73-681"><a href="#cb73-681" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-682"><a href="#cb73-682" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-685"><a href="#cb73-685" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-686"><a href="#cb73-686" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb73-687"><a href="#cb73-687" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb73-688"><a href="#cb73-688" aria-hidden="true" tabindex="-1"></a><span class="in">var age: u8 = 24;</span></span>
<span id="cb73-689"><a href="#cb73-689" aria-hidden="true" tabindex="-1"></a><span class="in">age = 25;</span></span>
<span id="cb73-690"><a href="#cb73-690" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-691"><a href="#cb73-691" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-692"><a href="#cb73-692" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-693"><a href="#cb73-693" aria-hidden="true" tabindex="-1"></a><span class="fu">### Declaring without an initial value</span></span>
<span id="cb73-694"><a href="#cb73-694" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-695"><a href="#cb73-695" aria-hidden="true" tabindex="-1"></a>By default, when you declare a new object in Zig, you must give it</span>
<span id="cb73-696"><a href="#cb73-696" aria-hidden="true" tabindex="-1"></a>an initial value. In other words, this means</span>
<span id="cb73-697"><a href="#cb73-697" aria-hidden="true" tabindex="-1"></a>that we have to declare, and, at the same time, initialize every object we</span>
<span id="cb73-698"><a href="#cb73-698" aria-hidden="true" tabindex="-1"></a>create in our source code.</span>
<span id="cb73-699"><a href="#cb73-699" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-700"><a href="#cb73-700" aria-hidden="true" tabindex="-1"></a>On the other hand, you can, in fact, declare a new object in your source code,</span>
<span id="cb73-701"><a href="#cb73-701" aria-hidden="true" tabindex="-1"></a>and not give it an explicit value. But we need to use a special keyword for that,</span>
<span id="cb73-702"><a href="#cb73-702" aria-hidden="true" tabindex="-1"></a>which is the <span class="in">`undefined`</span> keyword.</span>
<span id="cb73-703"><a href="#cb73-703" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-704"><a href="#cb73-704" aria-hidden="true" tabindex="-1"></a>It's important to emphasize that, you should avoid using <span class="in">`undefined`</span> as much as possible.</span>
<span id="cb73-705"><a href="#cb73-705" aria-hidden="true" tabindex="-1"></a>Because when you use this keyword, you leave your object uninitialized, and, as a consequence,</span>
<span id="cb73-706"><a href="#cb73-706" aria-hidden="true" tabindex="-1"></a>if for some reason, your code uses this object while it's uninitialized, then, you will definitely</span>
<span id="cb73-707"><a href="#cb73-707" aria-hidden="true" tabindex="-1"></a>have undefined behaviour and major bugs in your program.</span>
<span id="cb73-708"><a href="#cb73-708" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-709"><a href="#cb73-709" aria-hidden="true" tabindex="-1"></a>In the example below, I'm declaring the <span class="in">`age`</span> object again. But this time,</span>
<span id="cb73-710"><a href="#cb73-710" aria-hidden="true" tabindex="-1"></a>I do not give it an initial value. The variable is only initialized at</span>
<span id="cb73-711"><a href="#cb73-711" aria-hidden="true" tabindex="-1"></a>the second line of code, where I store the number 25 in this object.</span>
<span id="cb73-712"><a href="#cb73-712" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-715"><a href="#cb73-715" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-716"><a href="#cb73-716" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb73-717"><a href="#cb73-717" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb73-718"><a href="#cb73-718" aria-hidden="true" tabindex="-1"></a><span class="in">var age: u8 = undefined;</span></span>
<span id="cb73-719"><a href="#cb73-719" aria-hidden="true" tabindex="-1"></a><span class="in">age = 25;</span></span>
<span id="cb73-720"><a href="#cb73-720" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-721"><a href="#cb73-721" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-722"><a href="#cb73-722" aria-hidden="true" tabindex="-1"></a>Having these points in mind, just remember that you should avoid as much as possible to use <span class="in">`undefined`</span> in your code.</span>
<span id="cb73-723"><a href="#cb73-723" aria-hidden="true" tabindex="-1"></a>Always declare and initialize your objects. Because this gives you much more safety in your program.</span>
<span id="cb73-724"><a href="#cb73-724" aria-hidden="true" tabindex="-1"></a>But in case you really need to declare an object without initializing it... the</span>
<span id="cb73-725"><a href="#cb73-725" aria-hidden="true" tabindex="-1"></a><span class="in">`undefined`</span> keyword is the way to do it in Zig.</span>
<span id="cb73-726"><a href="#cb73-726" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-727"><a href="#cb73-727" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-728"><a href="#cb73-728" aria-hidden="true" tabindex="-1"></a><span class="fu">### There is no such thing as unused objects</span></span>
<span id="cb73-729"><a href="#cb73-729" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-730"><a href="#cb73-730" aria-hidden="true" tabindex="-1"></a>Every object (being constant or variable) that you declare in Zig **must be used in some way**. You can give this object</span>
<span id="cb73-731"><a href="#cb73-731" aria-hidden="true" tabindex="-1"></a>to a function call, as a function argument, or, you can use it in another expression</span>
<span id="cb73-732"><a href="#cb73-732" aria-hidden="true" tabindex="-1"></a>to calculate the value of another object, or, you can call a method that belongs to this</span>
<span id="cb73-733"><a href="#cb73-733" aria-hidden="true" tabindex="-1"></a>particular object.</span>
<span id="cb73-734"><a href="#cb73-734" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-735"><a href="#cb73-735" aria-hidden="true" tabindex="-1"></a>It doesn't matter in which way you use it. As long as you use it.</span>
<span id="cb73-736"><a href="#cb73-736" aria-hidden="true" tabindex="-1"></a>If you try to break this rule, i.e., if your try to declare a object, but not use it,</span>
<span id="cb73-737"><a href="#cb73-737" aria-hidden="true" tabindex="-1"></a>the <span class="in">`zig`</span> compiler will not compile your Zig source code, and it will issue a error</span>
<span id="cb73-738"><a href="#cb73-738" aria-hidden="true" tabindex="-1"></a>message warning that you have unused objects in your code.</span>
<span id="cb73-739"><a href="#cb73-739" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-740"><a href="#cb73-740" aria-hidden="true" tabindex="-1"></a>Let's demonstrate this with an example. In the source code below, we declare a constant object</span>
<span id="cb73-741"><a href="#cb73-741" aria-hidden="true" tabindex="-1"></a>called <span class="in">`age`</span>. If you try to compile a simple Zig program with this line of code below,</span>
<span id="cb73-742"><a href="#cb73-742" aria-hidden="true" tabindex="-1"></a>the compiler will return an error as demonstrated below:</span>
<span id="cb73-743"><a href="#cb73-743" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-746"><a href="#cb73-746" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-747"><a href="#cb73-747" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "ast"</span></span>
<span id="cb73-748"><a href="#cb73-748" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: false</span></span>
<span id="cb73-749"><a href="#cb73-749" aria-hidden="true" tabindex="-1"></a><span class="in">const age = 15;</span></span>
<span id="cb73-750"><a href="#cb73-750" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-751"><a href="#cb73-751" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-752"><a href="#cb73-752" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-753"><a href="#cb73-753" aria-hidden="true" tabindex="-1"></a><span class="in">t.zig:4:11: error: unused local constant</span></span>
<span id="cb73-754"><a href="#cb73-754" aria-hidden="true" tabindex="-1"></a><span class="in">    const age = 15;</span></span>
<span id="cb73-755"><a href="#cb73-755" aria-hidden="true" tabindex="-1"></a><span class="in">          ^~~</span></span>
<span id="cb73-756"><a href="#cb73-756" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-757"><a href="#cb73-757" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-758"><a href="#cb73-758" aria-hidden="true" tabindex="-1"></a>Everytime you declare a new object in Zig, you have two choices:</span>
<span id="cb73-759"><a href="#cb73-759" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-760"><a href="#cb73-760" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>you either use the value of this object;</span>
<span id="cb73-761"><a href="#cb73-761" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>or you explicitly discard the value of the object;</span>
<span id="cb73-762"><a href="#cb73-762" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-763"><a href="#cb73-763" aria-hidden="true" tabindex="-1"></a>To explicitly discard the value of any object (constant or variable), all you need to do is to assign</span>
<span id="cb73-764"><a href="#cb73-764" aria-hidden="true" tabindex="-1"></a>this object to a special character in Zig, which is the underscore (<span class="in">`_`</span>).</span>
<span id="cb73-765"><a href="#cb73-765" aria-hidden="true" tabindex="-1"></a>When you assign an object to a underscore, like in the example below, the <span class="in">`zig`</span> compiler will automatically</span>
<span id="cb73-766"><a href="#cb73-766" aria-hidden="true" tabindex="-1"></a>discard the value of this particular object.</span>
<span id="cb73-767"><a href="#cb73-767" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-768"><a href="#cb73-768" aria-hidden="true" tabindex="-1"></a>You can see in the example below that, this time, the compiler did not</span>
<span id="cb73-769"><a href="#cb73-769" aria-hidden="true" tabindex="-1"></a>complain about any "unused constant", and successfully compiled our source code.</span>
<span id="cb73-770"><a href="#cb73-770" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-773"><a href="#cb73-773" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-774"><a href="#cb73-774" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb73-775"><a href="#cb73-775" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb73-776"><a href="#cb73-776" aria-hidden="true" tabindex="-1"></a><span class="in">// It compiles!</span></span>
<span id="cb73-777"><a href="#cb73-777" aria-hidden="true" tabindex="-1"></a><span class="in">const age = 15;</span></span>
<span id="cb73-778"><a href="#cb73-778" aria-hidden="true" tabindex="-1"></a><span class="in">_ = age;</span></span>
<span id="cb73-779"><a href="#cb73-779" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-780"><a href="#cb73-780" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-781"><a href="#cb73-781" aria-hidden="true" tabindex="-1"></a>Now, remember, everytime you assign a particular object to the underscore, this object</span>
<span id="cb73-782"><a href="#cb73-782" aria-hidden="true" tabindex="-1"></a>is essentially destroyed. It's discarded by the compiler. This means that you can no longer</span>
<span id="cb73-783"><a href="#cb73-783" aria-hidden="true" tabindex="-1"></a>use this object further in your code. It doesn't exist anymore.</span>
<span id="cb73-784"><a href="#cb73-784" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-785"><a href="#cb73-785" aria-hidden="true" tabindex="-1"></a>So if you try to use the constant <span class="in">`age`</span> in the example below, after we discarded it, you</span>
<span id="cb73-786"><a href="#cb73-786" aria-hidden="true" tabindex="-1"></a>will get a loud error message from the compiler (talking about a "pointless discard")</span>
<span id="cb73-787"><a href="#cb73-787" aria-hidden="true" tabindex="-1"></a>warning you about this mistake.</span>
<span id="cb73-788"><a href="#cb73-788" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-791"><a href="#cb73-791" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-792"><a href="#cb73-792" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb73-793"><a href="#cb73-793" aria-hidden="true" tabindex="-1"></a><span class="in">// It does not compile.</span></span>
<span id="cb73-794"><a href="#cb73-794" aria-hidden="true" tabindex="-1"></a><span class="in">const age = 15;</span></span>
<span id="cb73-795"><a href="#cb73-795" aria-hidden="true" tabindex="-1"></a><span class="in">_ = age;</span></span>
<span id="cb73-796"><a href="#cb73-796" aria-hidden="true" tabindex="-1"></a><span class="in">// Using a discarded value!</span></span>
<span id="cb73-797"><a href="#cb73-797" aria-hidden="true" tabindex="-1"></a><span class="in">std.debug.print("{d}\n", .{age + 2});</span></span>
<span id="cb73-798"><a href="#cb73-798" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-799"><a href="#cb73-799" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-800"><a href="#cb73-800" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-801"><a href="#cb73-801" aria-hidden="true" tabindex="-1"></a><span class="in">t.zig:7:5: error: pointless discard</span></span>
<span id="cb73-802"><a href="#cb73-802" aria-hidden="true" tabindex="-1"></a><span class="in">    of local constant</span></span>
<span id="cb73-803"><a href="#cb73-803" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-804"><a href="#cb73-804" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-805"><a href="#cb73-805" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-806"><a href="#cb73-806" aria-hidden="true" tabindex="-1"></a>This same rule applies to variable objects. Every variable object must also be used in</span>
<span id="cb73-807"><a href="#cb73-807" aria-hidden="true" tabindex="-1"></a>some way. And if you assign a variable object to the underscore,</span>
<span id="cb73-808"><a href="#cb73-808" aria-hidden="true" tabindex="-1"></a>this object also gets discarded, and you can no longer use this object.</span>
<span id="cb73-809"><a href="#cb73-809" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-810"><a href="#cb73-810" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-811"><a href="#cb73-811" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-812"><a href="#cb73-812" aria-hidden="true" tabindex="-1"></a><span class="fu">### You must mutate every variable objects</span></span>
<span id="cb73-813"><a href="#cb73-813" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-814"><a href="#cb73-814" aria-hidden="true" tabindex="-1"></a>Every variable object that you create in your source code must be mutated at some point.</span>
<span id="cb73-815"><a href="#cb73-815" aria-hidden="true" tabindex="-1"></a>In other words, if you declare an object as a variable</span>
<span id="cb73-816"><a href="#cb73-816" aria-hidden="true" tabindex="-1"></a>object, with the keyword <span class="in">`var`</span>, and you do not change the value of this object</span>
<span id="cb73-817"><a href="#cb73-817" aria-hidden="true" tabindex="-1"></a>at some point in the future, the <span class="in">`zig`</span> compiler will detect this,</span>
<span id="cb73-818"><a href="#cb73-818" aria-hidden="true" tabindex="-1"></a>and it will raise an error warning you about this mistake.</span>
<span id="cb73-819"><a href="#cb73-819" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-820"><a href="#cb73-820" aria-hidden="true" tabindex="-1"></a>The concept behind this is that every object you create in Zig should be preferably a</span>
<span id="cb73-821"><a href="#cb73-821" aria-hidden="true" tabindex="-1"></a>constant object, unless you really need an object whose value will</span>
<span id="cb73-822"><a href="#cb73-822" aria-hidden="true" tabindex="-1"></a>change during the execution of your program.</span>
<span id="cb73-823"><a href="#cb73-823" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-824"><a href="#cb73-824" aria-hidden="true" tabindex="-1"></a>So, if I try to declare a variable object such as <span class="in">`where_i_live`</span> below,</span>
<span id="cb73-825"><a href="#cb73-825" aria-hidden="true" tabindex="-1"></a>and I do not change the value of this object in some way,</span>
<span id="cb73-826"><a href="#cb73-826" aria-hidden="true" tabindex="-1"></a>the <span class="in">`zig`</span> compiler raises an error message with the phrase "variable is never mutated".</span>
<span id="cb73-827"><a href="#cb73-827" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-830"><a href="#cb73-830" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-831"><a href="#cb73-831" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb73-832"><a href="#cb73-832" aria-hidden="true" tabindex="-1"></a><span class="in">var where_i_live = "Belo Horizonte";</span></span>
<span id="cb73-833"><a href="#cb73-833" aria-hidden="true" tabindex="-1"></a><span class="in">_ = where_i_live;</span></span>
<span id="cb73-834"><a href="#cb73-834" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-835"><a href="#cb73-835" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-836"><a href="#cb73-836" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-837"><a href="#cb73-837" aria-hidden="true" tabindex="-1"></a><span class="in">t.zig:7:5: error: local variable is never mutated</span></span>
<span id="cb73-838"><a href="#cb73-838" aria-hidden="true" tabindex="-1"></a><span class="in">t.zig:7:5: note: consider using 'const'</span></span>
<span id="cb73-839"><a href="#cb73-839" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-840"><a href="#cb73-840" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-841"><a href="#cb73-841" aria-hidden="true" tabindex="-1"></a><span class="fu">## Primitive Data Types {#sec-primitive-data-types}</span></span>
<span id="cb73-842"><a href="#cb73-842" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-843"><a href="#cb73-843" aria-hidden="true" tabindex="-1"></a>Zig has many different primitive data types available for you to use.</span>
<span id="cb73-844"><a href="#cb73-844" aria-hidden="true" tabindex="-1"></a>You can see the full list of available data types at the official</span>
<span id="cb73-845"><a href="#cb73-845" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">Language Reference page</span><span class="co">](https://ziglang.org/documentation/master/#Primitive-Types)</span><span class="ot">[^lang-data-types]</span>.</span>
<span id="cb73-846"><a href="#cb73-846" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-847"><a href="#cb73-847" aria-hidden="true" tabindex="-1"></a><span class="ot">[^lang-data-types]: &lt;https://ziglang.org/documentation/master/#Primitive-Types&gt;</span>.</span>
<span id="cb73-848"><a href="#cb73-848" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-849"><a href="#cb73-849" aria-hidden="true" tabindex="-1"></a>But here is a quick list:</span>
<span id="cb73-850"><a href="#cb73-850" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-851"><a href="#cb73-851" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Unsigned integers: <span class="in">`u8`</span>, 8-bit integer; <span class="in">`u16`</span>, 16-bit integer; <span class="in">`u32`</span>, 32-bit integer; <span class="in">`u64`</span>, 64-bit integer; <span class="in">`u128`</span>, 128-bit integer.</span>
<span id="cb73-852"><a href="#cb73-852" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Signed integers: <span class="in">`i8`</span>, 8-bit integer; <span class="in">`i16`</span>, 16-bit integer; <span class="in">`i32`</span>, 32-bit integer; <span class="in">`i64`</span>, 64-bit integer; <span class="in">`i128`</span>, 128-bit integer.</span>
<span id="cb73-853"><a href="#cb73-853" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Float number: <span class="in">`f16`</span>, 16-bit floating point; <span class="in">`f32`</span>, 32-bit floating point; <span class="in">`f64`</span>, 64-bit floating point; <span class="in">`f128`</span>, 128-bit floating point;</span>
<span id="cb73-854"><a href="#cb73-854" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Boolean: <span class="in">`bool`</span>, represents true or false values.</span>
<span id="cb73-855"><a href="#cb73-855" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>C ABI compatible types: <span class="in">`c_long`</span>, <span class="in">`c_char`</span>, <span class="in">`c_short`</span>, <span class="in">`c_ushort`</span>, <span class="in">`c_int`</span>, <span class="in">`c_uint`</span>, and many others.</span>
<span id="cb73-856"><a href="#cb73-856" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Pointer sized integers: <span class="in">`isize`</span> and <span class="in">`usize`</span>.</span>
<span id="cb73-857"><a href="#cb73-857" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-858"><a href="#cb73-858" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-859"><a href="#cb73-859" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-860"><a href="#cb73-860" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-861"><a href="#cb73-861" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-862"><a href="#cb73-862" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-863"><a href="#cb73-863" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-864"><a href="#cb73-864" aria-hidden="true" tabindex="-1"></a><span class="fu">## Arrays {#sec-arrays}</span></span>
<span id="cb73-865"><a href="#cb73-865" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-866"><a href="#cb73-866" aria-hidden="true" tabindex="-1"></a>You create arrays in Zig by using a syntax that resembles the C syntax.</span>
<span id="cb73-867"><a href="#cb73-867" aria-hidden="true" tabindex="-1"></a>First, you specify the size of the array (i.e., the number of elements that will be stored in the array)</span>
<span id="cb73-868"><a href="#cb73-868" aria-hidden="true" tabindex="-1"></a>you want to create inside a pair of brackets.</span>
<span id="cb73-869"><a href="#cb73-869" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-870"><a href="#cb73-870" aria-hidden="true" tabindex="-1"></a>Then, you specify the data type of the elements that will be stored inside this array.</span>
<span id="cb73-871"><a href="#cb73-871" aria-hidden="true" tabindex="-1"></a>All elements present in an array in Zig must have the same data type. For example, you cannot mix elements</span>
<span id="cb73-872"><a href="#cb73-872" aria-hidden="true" tabindex="-1"></a>of type <span class="in">`f32`</span> with elements of type <span class="in">`i32`</span> in the same array.</span>
<span id="cb73-873"><a href="#cb73-873" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-874"><a href="#cb73-874" aria-hidden="true" tabindex="-1"></a>After that, you simply list the values that you want to store in this array inside</span>
<span id="cb73-875"><a href="#cb73-875" aria-hidden="true" tabindex="-1"></a>a pair of curly braces.</span>
<span id="cb73-876"><a href="#cb73-876" aria-hidden="true" tabindex="-1"></a>In the example below, I am creating two constant objects that contain different arrays.</span>
<span id="cb73-877"><a href="#cb73-877" aria-hidden="true" tabindex="-1"></a>The first object contains an array of 4 integer values, while the second object,</span>
<span id="cb73-878"><a href="#cb73-878" aria-hidden="true" tabindex="-1"></a>an array of 3 floating point values.</span>
<span id="cb73-879"><a href="#cb73-879" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-880"><a href="#cb73-880" aria-hidden="true" tabindex="-1"></a>Now, you should notice that in the object <span class="in">`ls`</span>, I am</span>
<span id="cb73-881"><a href="#cb73-881" aria-hidden="true" tabindex="-1"></a>not explicitly specifying the size of the array inside of the brackets. Instead</span>
<span id="cb73-882"><a href="#cb73-882" aria-hidden="true" tabindex="-1"></a>of using a literal value (like the value 4 that I used in the <span class="in">`ns`</span> object), I am</span>
<span id="cb73-883"><a href="#cb73-883" aria-hidden="true" tabindex="-1"></a>using the special character underscore (<span class="in">`_`</span>). This syntax tells the <span class="in">`zig`</span> compiler</span>
<span id="cb73-884"><a href="#cb73-884" aria-hidden="true" tabindex="-1"></a>to fill this field with the number of elements listed inside of the curly braces.</span>
<span id="cb73-885"><a href="#cb73-885" aria-hidden="true" tabindex="-1"></a>So, this syntax <span class="in">`[_]`</span> is for lazy (or smart) programmers who leave the job of</span>
<span id="cb73-886"><a href="#cb73-886" aria-hidden="true" tabindex="-1"></a>counting how many elements there are in the curly braces for the compiler.</span>
<span id="cb73-887"><a href="#cb73-887" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-890"><a href="#cb73-890" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-891"><a href="#cb73-891" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb73-892"><a href="#cb73-892" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb73-893"><a href="#cb73-893" aria-hidden="true" tabindex="-1"></a><span class="in">const ns = [4]u8{48, 24, 12, 6};</span></span>
<span id="cb73-894"><a href="#cb73-894" aria-hidden="true" tabindex="-1"></a><span class="in">const ls = [_]f64{432.1, 87.2, 900.05};</span></span>
<span id="cb73-895"><a href="#cb73-895" aria-hidden="true" tabindex="-1"></a><span class="in">_ = ns; _ = ls;</span></span>
<span id="cb73-896"><a href="#cb73-896" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-897"><a href="#cb73-897" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-898"><a href="#cb73-898" aria-hidden="true" tabindex="-1"></a>It's worth noting that these are static arrays, meaning that</span>
<span id="cb73-899"><a href="#cb73-899" aria-hidden="true" tabindex="-1"></a>they cannot grow in size.</span>
<span id="cb73-900"><a href="#cb73-900" aria-hidden="true" tabindex="-1"></a>Once you declare your array, you cannot change the size of it.</span>
<span id="cb73-901"><a href="#cb73-901" aria-hidden="true" tabindex="-1"></a>This is very common in low level languages.</span>
<span id="cb73-902"><a href="#cb73-902" aria-hidden="true" tabindex="-1"></a>Because low level languages normally wants to give you (the programmer) full control over memory,</span>
<span id="cb73-903"><a href="#cb73-903" aria-hidden="true" tabindex="-1"></a>and the way in which arrays are expanded is tightly related to</span>
<span id="cb73-904"><a href="#cb73-904" aria-hidden="true" tabindex="-1"></a>memory management.</span>
<span id="cb73-905"><a href="#cb73-905" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-906"><a href="#cb73-906" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-907"><a href="#cb73-907" aria-hidden="true" tabindex="-1"></a><span class="fu">### Selecting elements of the array {#sec-select-array-elem}</span></span>
<span id="cb73-908"><a href="#cb73-908" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-909"><a href="#cb73-909" aria-hidden="true" tabindex="-1"></a>One very common activity is to select specific portions of an array</span>
<span id="cb73-910"><a href="#cb73-910" aria-hidden="true" tabindex="-1"></a>you have in your source code.</span>
<span id="cb73-911"><a href="#cb73-911" aria-hidden="true" tabindex="-1"></a>In Zig, you can select a specific element from your</span>
<span id="cb73-912"><a href="#cb73-912" aria-hidden="true" tabindex="-1"></a>array, by simply providing the index of this particular</span>
<span id="cb73-913"><a href="#cb73-913" aria-hidden="true" tabindex="-1"></a>element inside brackets after the object name.</span>
<span id="cb73-914"><a href="#cb73-914" aria-hidden="true" tabindex="-1"></a>In the example below, I am selecting the third element from the</span>
<span id="cb73-915"><a href="#cb73-915" aria-hidden="true" tabindex="-1"></a><span class="in">`ns`</span> array. Notice that Zig is a "zero-index" based language,</span>
<span id="cb73-916"><a href="#cb73-916" aria-hidden="true" tabindex="-1"></a>like C, C++, Rust, Python, and many other languages.</span>
<span id="cb73-917"><a href="#cb73-917" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-920"><a href="#cb73-920" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-921"><a href="#cb73-921" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb73-922"><a href="#cb73-922" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb73-923"><a href="#cb73-923" aria-hidden="true" tabindex="-1"></a><span class="in">const ns = [4]u8{48, 24, 12, 6};</span></span>
<span id="cb73-924"><a href="#cb73-924" aria-hidden="true" tabindex="-1"></a><span class="in">try stdout.print("{d}\n", .{ ns[2] });</span></span>
<span id="cb73-925"><a href="#cb73-925" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-926"><a href="#cb73-926" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-927"><a href="#cb73-927" aria-hidden="true" tabindex="-1"></a>In contrast, you can also select specific slices (or sections) of your array, by using a</span>
<span id="cb73-928"><a href="#cb73-928" aria-hidden="true" tabindex="-1"></a>range selector. Some programmers also call these selectors of "slice selectors",</span>
<span id="cb73-929"><a href="#cb73-929" aria-hidden="true" tabindex="-1"></a>and they also exist in Rust, and have the exact same syntax as in Zig.</span>
<span id="cb73-930"><a href="#cb73-930" aria-hidden="true" tabindex="-1"></a>Anyway, a range selector is a special expression in Zig that defines</span>
<span id="cb73-931"><a href="#cb73-931" aria-hidden="true" tabindex="-1"></a>a range of indexes, and it has the syntax <span class="in">`start..end`</span>.</span>
<span id="cb73-932"><a href="#cb73-932" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-933"><a href="#cb73-933" aria-hidden="true" tabindex="-1"></a>In the example below, at the second line of code,</span>
<span id="cb73-934"><a href="#cb73-934" aria-hidden="true" tabindex="-1"></a>the <span class="in">`sl`</span> object stores a slice (or a portion) of the</span>
<span id="cb73-935"><a href="#cb73-935" aria-hidden="true" tabindex="-1"></a><span class="in">`ns`</span> array. More precisely, the elements at index 1 and 2</span>
<span id="cb73-936"><a href="#cb73-936" aria-hidden="true" tabindex="-1"></a>in the <span class="in">`ns`</span> array.</span>
<span id="cb73-937"><a href="#cb73-937" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-940"><a href="#cb73-940" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-941"><a href="#cb73-941" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb73-942"><a href="#cb73-942" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb73-943"><a href="#cb73-943" aria-hidden="true" tabindex="-1"></a><span class="in">const ns = [4]u8{48, 24, 12, 6};</span></span>
<span id="cb73-944"><a href="#cb73-944" aria-hidden="true" tabindex="-1"></a><span class="in">const sl = ns[1..3];</span></span>
<span id="cb73-945"><a href="#cb73-945" aria-hidden="true" tabindex="-1"></a><span class="in">_ = sl;</span></span>
<span id="cb73-946"><a href="#cb73-946" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-947"><a href="#cb73-947" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-948"><a href="#cb73-948" aria-hidden="true" tabindex="-1"></a>When you use the <span class="in">`start..end`</span> syntax,</span>
<span id="cb73-949"><a href="#cb73-949" aria-hidden="true" tabindex="-1"></a>the "end tail" of the range selector is non-inclusive,</span>
<span id="cb73-950"><a href="#cb73-950" aria-hidden="true" tabindex="-1"></a>meaning that, the index at the end is not included in the range that is</span>
<span id="cb73-951"><a href="#cb73-951" aria-hidden="true" tabindex="-1"></a>selected from the array.</span>
<span id="cb73-952"><a href="#cb73-952" aria-hidden="true" tabindex="-1"></a>Therefore, the syntax <span class="in">`start..end`</span> actually means <span class="in">`start..end - 1`</span> in practice.</span>
<span id="cb73-953"><a href="#cb73-953" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-954"><a href="#cb73-954" aria-hidden="true" tabindex="-1"></a>You can for example, create a slice that goes from the first to the</span>
<span id="cb73-955"><a href="#cb73-955" aria-hidden="true" tabindex="-1"></a>last elements of the array, by using <span class="in">`ar[0..ar.len]`</span> syntax</span>
<span id="cb73-956"><a href="#cb73-956" aria-hidden="true" tabindex="-1"></a>In other words, it's a slice that</span>
<span id="cb73-957"><a href="#cb73-957" aria-hidden="true" tabindex="-1"></a>accesses all elements in the array.</span>
<span id="cb73-958"><a href="#cb73-958" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-961"><a href="#cb73-961" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-962"><a href="#cb73-962" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb73-963"><a href="#cb73-963" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb73-964"><a href="#cb73-964" aria-hidden="true" tabindex="-1"></a><span class="in">const ar = [4]u8{48, 24, 12, 6};</span></span>
<span id="cb73-965"><a href="#cb73-965" aria-hidden="true" tabindex="-1"></a><span class="in">const sl = ar[0..ar.len];</span></span>
<span id="cb73-966"><a href="#cb73-966" aria-hidden="true" tabindex="-1"></a><span class="in">_ = sl;</span></span>
<span id="cb73-967"><a href="#cb73-967" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-968"><a href="#cb73-968" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-969"><a href="#cb73-969" aria-hidden="true" tabindex="-1"></a>You can also use the syntax <span class="in">`start..`</span> in your range selector.</span>
<span id="cb73-970"><a href="#cb73-970" aria-hidden="true" tabindex="-1"></a>Which tells the <span class="in">`zig`</span> compiler to select the portion of the array</span>
<span id="cb73-971"><a href="#cb73-971" aria-hidden="true" tabindex="-1"></a>that begins at the <span class="in">`start`</span> index until the last element of the array.</span>
<span id="cb73-972"><a href="#cb73-972" aria-hidden="true" tabindex="-1"></a>In the example below, we are selecting the range from index 1</span>
<span id="cb73-973"><a href="#cb73-973" aria-hidden="true" tabindex="-1"></a>until the end of the array.</span>
<span id="cb73-974"><a href="#cb73-974" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-977"><a href="#cb73-977" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-978"><a href="#cb73-978" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb73-979"><a href="#cb73-979" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb73-980"><a href="#cb73-980" aria-hidden="true" tabindex="-1"></a><span class="in">const ns = [4]u8{48, 24, 12, 6};</span></span>
<span id="cb73-981"><a href="#cb73-981" aria-hidden="true" tabindex="-1"></a><span class="in">const sl = ns[1..];</span></span>
<span id="cb73-982"><a href="#cb73-982" aria-hidden="true" tabindex="-1"></a><span class="in">_ = sl;</span></span>
<span id="cb73-983"><a href="#cb73-983" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-984"><a href="#cb73-984" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-985"><a href="#cb73-985" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-986"><a href="#cb73-986" aria-hidden="true" tabindex="-1"></a><span class="fu">### More on slices</span></span>
<span id="cb73-987"><a href="#cb73-987" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-988"><a href="#cb73-988" aria-hidden="true" tabindex="-1"></a>As we discussed before, in Zig, you can select specific portions of an existing</span>
<span id="cb73-989"><a href="#cb73-989" aria-hidden="true" tabindex="-1"></a>array. This is called *slicing* in Zig <span class="co">[</span><span class="ot">@zigguide</span><span class="co">]</span>, because when you select a portion</span>
<span id="cb73-990"><a href="#cb73-990" aria-hidden="true" tabindex="-1"></a>of an array, you are creating a slice object from that array.</span>
<span id="cb73-991"><a href="#cb73-991" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-992"><a href="#cb73-992" aria-hidden="true" tabindex="-1"></a>A slice object is essentially a pointer object accompanied by a length number.</span>
<span id="cb73-993"><a href="#cb73-993" aria-hidden="true" tabindex="-1"></a>The pointer object points to the first element in the slice, and the</span>
<span id="cb73-994"><a href="#cb73-994" aria-hidden="true" tabindex="-1"></a>length number tells the <span class="in">`zig`</span> compiler how many elements there are in this slice.</span>
<span id="cb73-995"><a href="#cb73-995" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-996"><a href="#cb73-996" aria-hidden="true" tabindex="-1"></a><span class="at">&gt; Slices can be thought of as a pair of </span><span class="in">`[*]T`</span><span class="at"> (the pointer to the data) and a </span><span class="in">`usize`</span><span class="at"> (the element count) </span><span class="co">[</span><span class="ot">@zigguide</span><span class="co">]</span><span class="at">.</span></span>
<span id="cb73-997"><a href="#cb73-997" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-998"><a href="#cb73-998" aria-hidden="true" tabindex="-1"></a>Through the pointer contained inside the slice you can access the elements (or values)</span>
<span id="cb73-999"><a href="#cb73-999" aria-hidden="true" tabindex="-1"></a>that are inside this range (or portion) that you selected from the original array.</span>
<span id="cb73-1000"><a href="#cb73-1000" aria-hidden="true" tabindex="-1"></a>But the length number (which you can access through the <span class="in">`len`</span> property of your slice object)</span>
<span id="cb73-1001"><a href="#cb73-1001" aria-hidden="true" tabindex="-1"></a>is the really big improvement (over C arrays for example) that Zig brings to the table here.</span>
<span id="cb73-1002"><a href="#cb73-1002" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1003"><a href="#cb73-1003" aria-hidden="true" tabindex="-1"></a>Because with this length number</span>
<span id="cb73-1004"><a href="#cb73-1004" aria-hidden="true" tabindex="-1"></a>the <span class="in">`zig`</span> compiler can easily check if you are trying to access an index that is out of the bounds of this particular slice,</span>
<span id="cb73-1005"><a href="#cb73-1005" aria-hidden="true" tabindex="-1"></a>or, if you are causing any buffer overflow problems. In the example below,</span>
<span id="cb73-1006"><a href="#cb73-1006" aria-hidden="true" tabindex="-1"></a>we access the <span class="in">`len`</span> property of the slice <span class="in">`sl`</span>, which tells us that this slice</span>
<span id="cb73-1007"><a href="#cb73-1007" aria-hidden="true" tabindex="-1"></a>has 2 elements in it.</span>
<span id="cb73-1008"><a href="#cb73-1008" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1011"><a href="#cb73-1011" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-1012"><a href="#cb73-1012" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb73-1013"><a href="#cb73-1013" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb73-1014"><a href="#cb73-1014" aria-hidden="true" tabindex="-1"></a><span class="in">const ns = [4]u8{48, 24, 12, 6};</span></span>
<span id="cb73-1015"><a href="#cb73-1015" aria-hidden="true" tabindex="-1"></a><span class="in">const sl = ns[1..3];</span></span>
<span id="cb73-1016"><a href="#cb73-1016" aria-hidden="true" tabindex="-1"></a><span class="in">try stdout.print("{d}\n", .{sl.len});</span></span>
<span id="cb73-1017"><a href="#cb73-1017" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-1018"><a href="#cb73-1018" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1019"><a href="#cb73-1019" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1020"><a href="#cb73-1020" aria-hidden="true" tabindex="-1"></a><span class="fu">### Array operators</span></span>
<span id="cb73-1021"><a href="#cb73-1021" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1022"><a href="#cb73-1022" aria-hidden="true" tabindex="-1"></a>There are two array operators available in Zig that are very useful.</span>
<span id="cb73-1023"><a href="#cb73-1023" aria-hidden="true" tabindex="-1"></a>The array concatenation operator (<span class="in">`++`</span>), and the array multiplication operator (<span class="in">`**`</span>). As the name suggests,</span>
<span id="cb73-1024"><a href="#cb73-1024" aria-hidden="true" tabindex="-1"></a>these are array operators.</span>
<span id="cb73-1025"><a href="#cb73-1025" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1026"><a href="#cb73-1026" aria-hidden="true" tabindex="-1"></a>One important detail about these two operators is that they work</span>
<span id="cb73-1027"><a href="#cb73-1027" aria-hidden="true" tabindex="-1"></a>only when both operands have a size (or "length") that is compile-time known.</span>
<span id="cb73-1028"><a href="#cb73-1028" aria-hidden="true" tabindex="-1"></a>We are going to talk more about</span>
<span id="cb73-1029"><a href="#cb73-1029" aria-hidden="true" tabindex="-1"></a>the differences between "compile-time known" and "runtime known" in @sec-compile-time.</span>
<span id="cb73-1030"><a href="#cb73-1030" aria-hidden="true" tabindex="-1"></a>But for now, keep this information in mind, that you cannot use these operators in every situation.</span>
<span id="cb73-1031"><a href="#cb73-1031" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1032"><a href="#cb73-1032" aria-hidden="true" tabindex="-1"></a>In summary, the <span class="in">`++`</span> operator creates a new array that is the concatenation,</span>
<span id="cb73-1033"><a href="#cb73-1033" aria-hidden="true" tabindex="-1"></a>of both arrays provided as operands. So, the expression <span class="in">`a ++ b`</span> produces</span>
<span id="cb73-1034"><a href="#cb73-1034" aria-hidden="true" tabindex="-1"></a>a new array which contains all the elements from arrays <span class="in">`a`</span> and <span class="in">`b`</span>.</span>
<span id="cb73-1035"><a href="#cb73-1035" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1038"><a href="#cb73-1038" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-1039"><a href="#cb73-1039" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb73-1040"><a href="#cb73-1040" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb73-1041"><a href="#cb73-1041" aria-hidden="true" tabindex="-1"></a><span class="in">const a = [_]u8{1,2,3};</span></span>
<span id="cb73-1042"><a href="#cb73-1042" aria-hidden="true" tabindex="-1"></a><span class="in">const b = [_]u8{4,5};</span></span>
<span id="cb73-1043"><a href="#cb73-1043" aria-hidden="true" tabindex="-1"></a><span class="in">const c = a ++ b;</span></span>
<span id="cb73-1044"><a href="#cb73-1044" aria-hidden="true" tabindex="-1"></a><span class="in">try stdout.print("{any}\n", .{c});</span></span>
<span id="cb73-1045"><a href="#cb73-1045" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-1046"><a href="#cb73-1046" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1047"><a href="#cb73-1047" aria-hidden="true" tabindex="-1"></a>This <span class="in">`++`</span> operator is particularly useful to concatenate strings together.</span>
<span id="cb73-1048"><a href="#cb73-1048" aria-hidden="true" tabindex="-1"></a>Strings in Zig are described in depth in @sec-zig-strings. In summary, a string object in Zig</span>
<span id="cb73-1049"><a href="#cb73-1049" aria-hidden="true" tabindex="-1"></a>is essentially an arrays of bytes. So, you can use this array concatenation operator</span>
<span id="cb73-1050"><a href="#cb73-1050" aria-hidden="true" tabindex="-1"></a>to effectively concatenate strings together.</span>
<span id="cb73-1051"><a href="#cb73-1051" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1052"><a href="#cb73-1052" aria-hidden="true" tabindex="-1"></a>In contrast, the <span class="in">`**`</span> operator is used to replicate an array multiple</span>
<span id="cb73-1053"><a href="#cb73-1053" aria-hidden="true" tabindex="-1"></a>times. In other words, the expression <span class="in">`a ** 3`</span> creates a new array</span>
<span id="cb73-1054"><a href="#cb73-1054" aria-hidden="true" tabindex="-1"></a>which contains the elements of the array <span class="in">`a`</span> repeated 3 times.</span>
<span id="cb73-1055"><a href="#cb73-1055" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1058"><a href="#cb73-1058" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-1059"><a href="#cb73-1059" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb73-1060"><a href="#cb73-1060" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb73-1061"><a href="#cb73-1061" aria-hidden="true" tabindex="-1"></a><span class="in">const a = [_]u8{1,2,3};</span></span>
<span id="cb73-1062"><a href="#cb73-1062" aria-hidden="true" tabindex="-1"></a><span class="in">const c = a ** 2;</span></span>
<span id="cb73-1063"><a href="#cb73-1063" aria-hidden="true" tabindex="-1"></a><span class="in">try stdout.print("{any}\n", .{c});</span></span>
<span id="cb73-1064"><a href="#cb73-1064" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-1065"><a href="#cb73-1065" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1066"><a href="#cb73-1066" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1067"><a href="#cb73-1067" aria-hidden="true" tabindex="-1"></a><span class="fu">### Runtime versus compile-time known length in slices</span></span>
<span id="cb73-1068"><a href="#cb73-1068" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1069"><a href="#cb73-1069" aria-hidden="true" tabindex="-1"></a>We are going to talk a lot about the differences between compile-time known</span>
<span id="cb73-1070"><a href="#cb73-1070" aria-hidden="true" tabindex="-1"></a>and runtime known across this book, especially in @sec-compile-time.</span>
<span id="cb73-1071"><a href="#cb73-1071" aria-hidden="true" tabindex="-1"></a>But the basic idea is that a thing is compile-time known, when we know</span>
<span id="cb73-1072"><a href="#cb73-1072" aria-hidden="true" tabindex="-1"></a>everything (the value, the attributes and the characteristics) about this thing at compile-time.</span>
<span id="cb73-1073"><a href="#cb73-1073" aria-hidden="true" tabindex="-1"></a>In contrast, a runtime known thing is when the exact value of a thing is calculated only at runtime.</span>
<span id="cb73-1074"><a href="#cb73-1074" aria-hidden="true" tabindex="-1"></a>Therefore, we don't know the value of this thing at compile-time, only at runtime.</span>
<span id="cb73-1075"><a href="#cb73-1075" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1076"><a href="#cb73-1076" aria-hidden="true" tabindex="-1"></a>We have learned in @sec-select-array-elem that slices are created by using a *range selector*,</span>
<span id="cb73-1077"><a href="#cb73-1077" aria-hidden="true" tabindex="-1"></a>which represents a range of indexes. When this "range of indexes" (i.e., both the start and the end of this range)</span>
<span id="cb73-1078"><a href="#cb73-1078" aria-hidden="true" tabindex="-1"></a>is known at compile-time, the slice object that gets created is actually, under the hood, just</span>
<span id="cb73-1079"><a href="#cb73-1079" aria-hidden="true" tabindex="-1"></a>a single-item pointer to an array.</span>
<span id="cb73-1080"><a href="#cb73-1080" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1081"><a href="#cb73-1081" aria-hidden="true" tabindex="-1"></a>You don't need to precisely understand what that means now. We are going to talk a lot about pointers</span>
<span id="cb73-1082"><a href="#cb73-1082" aria-hidden="true" tabindex="-1"></a>in @sec-pointer. For now, just understand that, when the range of indexes is known at compile-time,</span>
<span id="cb73-1083"><a href="#cb73-1083" aria-hidden="true" tabindex="-1"></a>the slice that gets created is just a pointer to an array, accompanied by a length value that</span>
<span id="cb73-1084"><a href="#cb73-1084" aria-hidden="true" tabindex="-1"></a>tells the size of the slice.</span>
<span id="cb73-1085"><a href="#cb73-1085" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1086"><a href="#cb73-1086" aria-hidden="true" tabindex="-1"></a>If you have a slice object like this, i.e., a slice that has a compile-time known range,</span>
<span id="cb73-1087"><a href="#cb73-1087" aria-hidden="true" tabindex="-1"></a>you can use common pointer operations over this slice object. For example, you can</span>
<span id="cb73-1088"><a href="#cb73-1088" aria-hidden="true" tabindex="-1"></a>dereference the pointer of this slice, by using the <span class="in">`.*`</span> method, like you would</span>
<span id="cb73-1089"><a href="#cb73-1089" aria-hidden="true" tabindex="-1"></a>do on a normal pointer object.</span>
<span id="cb73-1090"><a href="#cb73-1090" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1093"><a href="#cb73-1093" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-1094"><a href="#cb73-1094" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb73-1095"><a href="#cb73-1095" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb73-1096"><a href="#cb73-1096" aria-hidden="true" tabindex="-1"></a><span class="in">const arr1 = [10]u64 {</span></span>
<span id="cb73-1097"><a href="#cb73-1097" aria-hidden="true" tabindex="-1"></a><span class="in">    1, 2, 3, 4, 5,</span></span>
<span id="cb73-1098"><a href="#cb73-1098" aria-hidden="true" tabindex="-1"></a><span class="in">    6, 7, 8, 9, 10</span></span>
<span id="cb73-1099"><a href="#cb73-1099" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb73-1100"><a href="#cb73-1100" aria-hidden="true" tabindex="-1"></a><span class="in">// This slice has a compile-time known range.</span></span>
<span id="cb73-1101"><a href="#cb73-1101" aria-hidden="true" tabindex="-1"></a><span class="in">// Because we know both the start and end of the range.</span></span>
<span id="cb73-1102"><a href="#cb73-1102" aria-hidden="true" tabindex="-1"></a><span class="in">const slice = arr1[1..4];</span></span>
<span id="cb73-1103"><a href="#cb73-1103" aria-hidden="true" tabindex="-1"></a><span class="in">_ = slice;</span></span>
<span id="cb73-1104"><a href="#cb73-1104" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-1105"><a href="#cb73-1105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1106"><a href="#cb73-1106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1107"><a href="#cb73-1107" aria-hidden="true" tabindex="-1"></a>On the other hand, if the range of indexes is not known at compile time, then, the slice object</span>
<span id="cb73-1108"><a href="#cb73-1108" aria-hidden="true" tabindex="-1"></a>that gets created is not a pointer anymore, and, thus, it does not support pointer operations.</span>
<span id="cb73-1109"><a href="#cb73-1109" aria-hidden="true" tabindex="-1"></a>For example, maybe the start index is known at compile time, but the end index is not. In such</span>
<span id="cb73-1110"><a href="#cb73-1110" aria-hidden="true" tabindex="-1"></a>case, the range of the slice becomes runtime known only.</span>
<span id="cb73-1111"><a href="#cb73-1111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1112"><a href="#cb73-1112" aria-hidden="true" tabindex="-1"></a>In the example below, we are reading a file, and then, we try to create a slice object</span>
<span id="cb73-1113"><a href="#cb73-1113" aria-hidden="true" tabindex="-1"></a>that covers the entire buffer that contains the contents of this file. This is obviously</span>
<span id="cb73-1114"><a href="#cb73-1114" aria-hidden="true" tabindex="-1"></a>an example of a runtime known range, because the end index of the range</span>
<span id="cb73-1115"><a href="#cb73-1115" aria-hidden="true" tabindex="-1"></a>is not known at compile time.</span>
<span id="cb73-1116"><a href="#cb73-1116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1117"><a href="#cb73-1117" aria-hidden="true" tabindex="-1"></a>In other words, the end index of the range is the size of</span>
<span id="cb73-1118"><a href="#cb73-1118" aria-hidden="true" tabindex="-1"></a>the array <span class="in">`file_contents`</span>. However, the size of <span class="in">`file_contents`</span> is not known at compile time.</span>
<span id="cb73-1119"><a href="#cb73-1119" aria-hidden="true" tabindex="-1"></a>Because we don't know how many bytes are stored inside this <span class="in">`shop-list.txt`</span> file.</span>
<span id="cb73-1120"><a href="#cb73-1120" aria-hidden="true" tabindex="-1"></a>And because this is a file, someone might edit this file tomorrow and add more lines</span>
<span id="cb73-1121"><a href="#cb73-1121" aria-hidden="true" tabindex="-1"></a>or remove lines from it. Therefore, the size of this file might vary drastically from one execution to another.</span>
<span id="cb73-1122"><a href="#cb73-1122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1123"><a href="#cb73-1123" aria-hidden="true" tabindex="-1"></a>Now, if the file size can vary from one run to another, then, we can conclude that the value of the expression</span>
<span id="cb73-1124"><a href="#cb73-1124" aria-hidden="true" tabindex="-1"></a><span class="in">`file_contents.len`</span> exposed in the example below can also vary from one run to another. As consequence,</span>
<span id="cb73-1125"><a href="#cb73-1125" aria-hidden="true" tabindex="-1"></a>the value of the expression <span class="in">`file_contents.len`</span> is runtime-known only, and, as a consequence of that,</span>
<span id="cb73-1126"><a href="#cb73-1126" aria-hidden="true" tabindex="-1"></a>the range <span class="in">`0..file_contents.len`</span> is also runtime-known only.</span>
<span id="cb73-1127"><a href="#cb73-1127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1128"><a href="#cb73-1128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1131"><a href="#cb73-1131" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-1132"><a href="#cb73-1132" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: false</span></span>
<span id="cb73-1133"><a href="#cb73-1133" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb73-1134"><a href="#cb73-1134" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb73-1135"><a href="#cb73-1135" aria-hidden="true" tabindex="-1"></a><span class="in">const builtin = @import("builtin");</span></span>
<span id="cb73-1136"><a href="#cb73-1136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1137"><a href="#cb73-1137" aria-hidden="true" tabindex="-1"></a><span class="in">fn read_file(allocator: std.mem.Allocator, path: []const u8) ![]u8 {</span></span>
<span id="cb73-1138"><a href="#cb73-1138" aria-hidden="true" tabindex="-1"></a><span class="in">    const file = try std.fs.cwd().openFile(path, .{});</span></span>
<span id="cb73-1139"><a href="#cb73-1139" aria-hidden="true" tabindex="-1"></a><span class="in">    defer file.close();</span></span>
<span id="cb73-1140"><a href="#cb73-1140" aria-hidden="true" tabindex="-1"></a><span class="in">    return try file.reader().readAllAlloc(</span></span>
<span id="cb73-1141"><a href="#cb73-1141" aria-hidden="true" tabindex="-1"></a><span class="in">        allocator, std.math.maxInt(usize)</span></span>
<span id="cb73-1142"><a href="#cb73-1142" aria-hidden="true" tabindex="-1"></a><span class="in">    );</span></span>
<span id="cb73-1143"><a href="#cb73-1143" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb73-1144"><a href="#cb73-1144" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1145"><a href="#cb73-1145" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb73-1146"><a href="#cb73-1146" aria-hidden="true" tabindex="-1"></a><span class="in">    var gpa = std.heap.GeneralPurposeAllocator(.{}){};</span></span>
<span id="cb73-1147"><a href="#cb73-1147" aria-hidden="true" tabindex="-1"></a><span class="in">    const allocator = gpa.allocator();</span></span>
<span id="cb73-1148"><a href="#cb73-1148" aria-hidden="true" tabindex="-1"></a><span class="in">    const path = "../ZigExamples/file-io/shop-list.txt";</span></span>
<span id="cb73-1149"><a href="#cb73-1149" aria-hidden="true" tabindex="-1"></a><span class="in">    const file_contents = try read_file(allocator, path);</span></span>
<span id="cb73-1150"><a href="#cb73-1150" aria-hidden="true" tabindex="-1"></a><span class="in">    const slice = file_contents[0..file_contents.len];</span></span>
<span id="cb73-1151"><a href="#cb73-1151" aria-hidden="true" tabindex="-1"></a><span class="in">    _ = slice;</span></span>
<span id="cb73-1152"><a href="#cb73-1152" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb73-1153"><a href="#cb73-1153" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-1154"><a href="#cb73-1154" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1155"><a href="#cb73-1155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1156"><a href="#cb73-1156" aria-hidden="true" tabindex="-1"></a><span class="fu">## Blocks and scopes {#sec-blocks}</span></span>
<span id="cb73-1157"><a href="#cb73-1157" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1158"><a href="#cb73-1158" aria-hidden="true" tabindex="-1"></a>Blocks are created in Zig by a pair of curly braces. A block is just a group of</span>
<span id="cb73-1159"><a href="#cb73-1159" aria-hidden="true" tabindex="-1"></a>expressions (or statements) contained inside of a pair of curly braces. All of these expressions that</span>
<span id="cb73-1160"><a href="#cb73-1160" aria-hidden="true" tabindex="-1"></a>are contained inside of this pair of curly braces belongs to the same scope.</span>
<span id="cb73-1161"><a href="#cb73-1161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1162"><a href="#cb73-1162" aria-hidden="true" tabindex="-1"></a>In other words, a block just delimits a scope in your code.</span>
<span id="cb73-1163"><a href="#cb73-1163" aria-hidden="true" tabindex="-1"></a>The objects that you define inside the same block belongs to the same</span>
<span id="cb73-1164"><a href="#cb73-1164" aria-hidden="true" tabindex="-1"></a>scope, and, therefore, are accessible from within this scope.</span>
<span id="cb73-1165"><a href="#cb73-1165" aria-hidden="true" tabindex="-1"></a>At the same time, these objects are not accessible outside of this scope.</span>
<span id="cb73-1166"><a href="#cb73-1166" aria-hidden="true" tabindex="-1"></a>So, you could also say that blocks are used to limit the scope of the objects that you create in</span>
<span id="cb73-1167"><a href="#cb73-1167" aria-hidden="true" tabindex="-1"></a>your source code. In less technical terms, blocks are used to specify where in your source code</span>
<span id="cb73-1168"><a href="#cb73-1168" aria-hidden="true" tabindex="-1"></a>you can access whatever object you have in your source code.</span>
<span id="cb73-1169"><a href="#cb73-1169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1170"><a href="#cb73-1170" aria-hidden="true" tabindex="-1"></a>So, a block is just a group of expressions contained inside a pair of curly braces.</span>
<span id="cb73-1171"><a href="#cb73-1171" aria-hidden="true" tabindex="-1"></a>And every block have its own scope separated from the others.</span>
<span id="cb73-1172"><a href="#cb73-1172" aria-hidden="true" tabindex="-1"></a>The body of a function is a classic example of a block. If statements, for and while loops</span>
<span id="cb73-1173"><a href="#cb73-1173" aria-hidden="true" tabindex="-1"></a>(and any other structure in the language that uses the pair of curly braces)</span>
<span id="cb73-1174"><a href="#cb73-1174" aria-hidden="true" tabindex="-1"></a>are also examples of blocks.</span>
<span id="cb73-1175"><a href="#cb73-1175" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1176"><a href="#cb73-1176" aria-hidden="true" tabindex="-1"></a>This means that, every if statement, or for loop,</span>
<span id="cb73-1177"><a href="#cb73-1177" aria-hidden="true" tabindex="-1"></a>etc., that you create in your source code has its own separate scope.</span>
<span id="cb73-1178"><a href="#cb73-1178" aria-hidden="true" tabindex="-1"></a>That is why you can't access the objects that you defined inside</span>
<span id="cb73-1179"><a href="#cb73-1179" aria-hidden="true" tabindex="-1"></a>of your for loop (or if statement) in an outer scope, i.e., a scope outside of the for loop.</span>
<span id="cb73-1180"><a href="#cb73-1180" aria-hidden="true" tabindex="-1"></a>Because you are trying to access an object that belongs to a scope that is different</span>
<span id="cb73-1181"><a href="#cb73-1181" aria-hidden="true" tabindex="-1"></a>than your current scope.</span>
<span id="cb73-1182"><a href="#cb73-1182" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1183"><a href="#cb73-1183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1184"><a href="#cb73-1184" aria-hidden="true" tabindex="-1"></a>You can create blocks within blocks, with multiple levels of nesting.</span>
<span id="cb73-1185"><a href="#cb73-1185" aria-hidden="true" tabindex="-1"></a>You can also (if you want to) give a label to a particular block, with the colon character (<span class="in">`:`</span>).</span>
<span id="cb73-1186"><a href="#cb73-1186" aria-hidden="true" tabindex="-1"></a>Just write <span class="in">`label:`</span> before you open the pair of curly braces that delimits your block. When you label a block</span>
<span id="cb73-1187"><a href="#cb73-1187" aria-hidden="true" tabindex="-1"></a>in Zig, you can use the <span class="in">`break`</span> keyword to return a value from this block, like as if it</span>
<span id="cb73-1188"><a href="#cb73-1188" aria-hidden="true" tabindex="-1"></a>was a function's body. You just write the <span class="in">`break`</span> keyword, followed by the block label in the format <span class="in">`:label`</span>,</span>
<span id="cb73-1189"><a href="#cb73-1189" aria-hidden="true" tabindex="-1"></a>and the expression that defines the value that you want to return.</span>
<span id="cb73-1190"><a href="#cb73-1190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1191"><a href="#cb73-1191" aria-hidden="true" tabindex="-1"></a>Like in the example below, where we are returning the value from the <span class="in">`y`</span> object</span>
<span id="cb73-1192"><a href="#cb73-1192" aria-hidden="true" tabindex="-1"></a>from the block <span class="in">`add_one`</span>, and saving the result inside the <span class="in">`x`</span> object.</span>
<span id="cb73-1193"><a href="#cb73-1193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1196"><a href="#cb73-1196" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-1197"><a href="#cb73-1197" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb73-1198"><a href="#cb73-1198" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb73-1199"><a href="#cb73-1199" aria-hidden="true" tabindex="-1"></a><span class="in">var y: i32 = 123;</span></span>
<span id="cb73-1200"><a href="#cb73-1200" aria-hidden="true" tabindex="-1"></a><span class="in">const x = add_one: {</span></span>
<span id="cb73-1201"><a href="#cb73-1201" aria-hidden="true" tabindex="-1"></a><span class="in">    y += 1;</span></span>
<span id="cb73-1202"><a href="#cb73-1202" aria-hidden="true" tabindex="-1"></a><span class="in">    break :add_one y;</span></span>
<span id="cb73-1203"><a href="#cb73-1203" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb73-1204"><a href="#cb73-1204" aria-hidden="true" tabindex="-1"></a><span class="in">if (x == 124 and y == 124) {</span></span>
<span id="cb73-1205"><a href="#cb73-1205" aria-hidden="true" tabindex="-1"></a><span class="in">    try stdout.print("Hey!", .{});</span></span>
<span id="cb73-1206"><a href="#cb73-1206" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb73-1207"><a href="#cb73-1207" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-1208"><a href="#cb73-1208" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1209"><a href="#cb73-1209" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1210"><a href="#cb73-1210" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1211"><a href="#cb73-1211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1212"><a href="#cb73-1212" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1213"><a href="#cb73-1213" aria-hidden="true" tabindex="-1"></a><span class="fu">## How strings work in Zig? {#sec-zig-strings}</span></span>
<span id="cb73-1214"><a href="#cb73-1214" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1215"><a href="#cb73-1215" aria-hidden="true" tabindex="-1"></a>The first project that we are going to build and discuss in this book is a base64 encoder/decoder (@sec-base64).</span>
<span id="cb73-1216"><a href="#cb73-1216" aria-hidden="true" tabindex="-1"></a>But in order for us to build such a thing, we need to get a better understanding on how strings work in Zig.</span>
<span id="cb73-1217"><a href="#cb73-1217" aria-hidden="true" tabindex="-1"></a>So let's discuss this specific aspect of Zig.</span>
<span id="cb73-1218"><a href="#cb73-1218" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1219"><a href="#cb73-1219" aria-hidden="true" tabindex="-1"></a>Strings in Zig work very similarly to strings in C, but they come with some extra caveats which adds more safety</span>
<span id="cb73-1220"><a href="#cb73-1220" aria-hidden="true" tabindex="-1"></a>and efficiency to them. You could also say that Zig simply uses a more modern and safe approach to manage</span>
<span id="cb73-1221"><a href="#cb73-1221" aria-hidden="true" tabindex="-1"></a>and use strings.</span>
<span id="cb73-1222"><a href="#cb73-1222" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1223"><a href="#cb73-1223" aria-hidden="true" tabindex="-1"></a>A string in Zig is essentially an array of arbitrary bytes, or, more specifically, an array of <span class="in">`u8`</span> values.</span>
<span id="cb73-1224"><a href="#cb73-1224" aria-hidden="true" tabindex="-1"></a>This very similar to a string in C, which is also interpreted as an array of arbitrary bytes, or, in the case</span>
<span id="cb73-1225"><a href="#cb73-1225" aria-hidden="true" tabindex="-1"></a>of C, an array of <span class="in">`char`</span> (which usually represents an unsigned 8-bit integer value in most systems) values.</span>
<span id="cb73-1226"><a href="#cb73-1226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1227"><a href="#cb73-1227" aria-hidden="true" tabindex="-1"></a>Now, because a string in Zig is an array, you automatically</span>
<span id="cb73-1228"><a href="#cb73-1228" aria-hidden="true" tabindex="-1"></a>get the length of the string (i.e. the length of the array) embedded in the value itself. This makes</span>
<span id="cb73-1229"><a href="#cb73-1229" aria-hidden="true" tabindex="-1"></a>all the difference! Because now, the Zig compiler can use the length value that is embedded in the string to</span>
<span id="cb73-1230"><a href="#cb73-1230" aria-hidden="true" tabindex="-1"></a>check for "buffer overflow" or "wrong memory access" problems in your code.</span>
<span id="cb73-1231"><a href="#cb73-1231" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1232"><a href="#cb73-1232" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1233"><a href="#cb73-1233" aria-hidden="true" tabindex="-1"></a>To achieve this same kind of safety in C, you have to do a lot of work that kind of seems pointless.</span>
<span id="cb73-1234"><a href="#cb73-1234" aria-hidden="true" tabindex="-1"></a>So getting this kind of safety is not automatic and much harder to do in C. For example, if you want</span>
<span id="cb73-1235"><a href="#cb73-1235" aria-hidden="true" tabindex="-1"></a>to track the length of your string throughout your program in C, then, you first need to loop through</span>
<span id="cb73-1236"><a href="#cb73-1236" aria-hidden="true" tabindex="-1"></a>the array of bytes that represents this string, and find the null element (<span class="in">`'\0'`</span>) position to discover</span>
<span id="cb73-1237"><a href="#cb73-1237" aria-hidden="true" tabindex="-1"></a>where exactly the array ends, or, in other words, to find how much elements the array of bytes contain.</span>
<span id="cb73-1238"><a href="#cb73-1238" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1239"><a href="#cb73-1239" aria-hidden="true" tabindex="-1"></a>To do that, you would need to do something like this in C. In this example, the C string stored in</span>
<span id="cb73-1240"><a href="#cb73-1240" aria-hidden="true" tabindex="-1"></a>the object <span class="in">`array`</span> is 25 bytes long:</span>
<span id="cb73-1241"><a href="#cb73-1241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1244"><a href="#cb73-1244" aria-hidden="true" tabindex="-1"></a><span class="in">```{c}</span></span>
<span id="cb73-1245"><a href="#cb73-1245" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">| eval: false</span></span>
<span id="cb73-1246"><a href="#cb73-1246" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb73-1247"><a href="#cb73-1247" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb73-1248"><a href="#cb73-1248" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span><span class="op">*</span> array <span class="op">=</span> <span class="st">"An example of string in C"</span><span class="op">;</span></span>
<span id="cb73-1249"><a href="#cb73-1249" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> index <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb73-1250"><a href="#cb73-1250" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb73-1251"><a href="#cb73-1251" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>array<span class="op">[</span>index<span class="op">]</span> <span class="op">==</span> <span class="ch">'</span><span class="sc">\0</span><span class="ch">'</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb73-1252"><a href="#cb73-1252" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb73-1253"><a href="#cb73-1253" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb73-1254"><a href="#cb73-1254" aria-hidden="true" tabindex="-1"></a>        index<span class="op">++;</span></span>
<span id="cb73-1255"><a href="#cb73-1255" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb73-1256"><a href="#cb73-1256" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Number of elements in the array: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> index<span class="op">);</span></span>
<span id="cb73-1257"><a href="#cb73-1257" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb73-1258"><a href="#cb73-1258" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-1259"><a href="#cb73-1259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1260"><a href="#cb73-1260" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-1261"><a href="#cb73-1261" aria-hidden="true" tabindex="-1"></a><span class="in">Number of elements in the array: 25</span></span>
<span id="cb73-1262"><a href="#cb73-1262" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-1263"><a href="#cb73-1263" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1264"><a href="#cb73-1264" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1265"><a href="#cb73-1265" aria-hidden="true" tabindex="-1"></a>You don't have this kind of work in Zig. Because the length of the string is always</span>
<span id="cb73-1266"><a href="#cb73-1266" aria-hidden="true" tabindex="-1"></a>present and accessible in the string value itself. You can easily access the length of the string</span>
<span id="cb73-1267"><a href="#cb73-1267" aria-hidden="true" tabindex="-1"></a>through the <span class="in">`len`</span> attribute. As an example, the <span class="in">`string_object`</span> object below is 43 bytes long:</span>
<span id="cb73-1268"><a href="#cb73-1268" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1269"><a href="#cb73-1269" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1272"><a href="#cb73-1272" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-1273"><a href="#cb73-1273" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: false</span></span>
<span id="cb73-1274"><a href="#cb73-1274" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb73-1275"><a href="#cb73-1275" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb73-1276"><a href="#cb73-1276" aria-hidden="true" tabindex="-1"></a><span class="in">const stdout = std.io.getStdOut().writer();</span></span>
<span id="cb73-1277"><a href="#cb73-1277" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb73-1278"><a href="#cb73-1278" aria-hidden="true" tabindex="-1"></a><span class="in">    const string_object = "This is an example of string literal in Zig";</span></span>
<span id="cb73-1279"><a href="#cb73-1279" aria-hidden="true" tabindex="-1"></a><span class="in">    try stdout.print("{d}\n", .{string_object.len});</span></span>
<span id="cb73-1280"><a href="#cb73-1280" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb73-1281"><a href="#cb73-1281" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-1282"><a href="#cb73-1282" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1283"><a href="#cb73-1283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1284"><a href="#cb73-1284" aria-hidden="true" tabindex="-1"></a>Another point is that Zig always assumes that the sequence of bytes in your string is UTF-8 encoded. This might not be true for every</span>
<span id="cb73-1285"><a href="#cb73-1285" aria-hidden="true" tabindex="-1"></a>sequence of bytes you're working with, but is not really Zig's job to fix the encoding of your strings</span>
<span id="cb73-1286"><a href="#cb73-1286" aria-hidden="true" tabindex="-1"></a>(you can use <span class="co">[</span><span class="ot">`iconv`</span><span class="co">](https://www.gnu.org/software/libiconv/)</span><span class="ot">[^libiconv]</span> for that).</span>
<span id="cb73-1287"><a href="#cb73-1287" aria-hidden="true" tabindex="-1"></a>Today, most of the text in our modern world, especially on the web, should be UTF-8 encoded.</span>
<span id="cb73-1288"><a href="#cb73-1288" aria-hidden="true" tabindex="-1"></a>So if your string literal is not UTF-8 encoded, then, you will likely have problems in Zig.</span>
<span id="cb73-1289"><a href="#cb73-1289" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1290"><a href="#cb73-1290" aria-hidden="true" tabindex="-1"></a><span class="ot">[^libiconv]: &lt;https://www.gnu.org/software/libiconv/&gt;</span></span>
<span id="cb73-1291"><a href="#cb73-1291" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1292"><a href="#cb73-1292" aria-hidden="true" tabindex="-1"></a>Let's take for example the word "Hello". In UTF-8, this sequence of characters (H, e, l, l, o)</span>
<span id="cb73-1293"><a href="#cb73-1293" aria-hidden="true" tabindex="-1"></a>is represented by the sequence of decimal numbers 72, 101, 108, 108, 111. In hexadecimal, this</span>
<span id="cb73-1294"><a href="#cb73-1294" aria-hidden="true" tabindex="-1"></a>sequence is <span class="in">`0x48`</span>, <span class="in">`0x65`</span>, <span class="in">`0x6C`</span>, <span class="in">`0x6C`</span>, <span class="in">`0x6F`</span>. So if I take this sequence of hexadecimal values,</span>
<span id="cb73-1295"><a href="#cb73-1295" aria-hidden="true" tabindex="-1"></a>and ask Zig to print this sequence of bytes as a sequence of characters (i.e., a string), then,</span>
<span id="cb73-1296"><a href="#cb73-1296" aria-hidden="true" tabindex="-1"></a>the text "Hello" will be printed into the terminal:</span>
<span id="cb73-1297"><a href="#cb73-1297" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1300"><a href="#cb73-1300" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-1301"><a href="#cb73-1301" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: false</span></span>
<span id="cb73-1302"><a href="#cb73-1302" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb73-1303"><a href="#cb73-1303" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb73-1304"><a href="#cb73-1304" aria-hidden="true" tabindex="-1"></a><span class="in">const stdout = std.io.getStdOut().writer();</span></span>
<span id="cb73-1305"><a href="#cb73-1305" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1306"><a href="#cb73-1306" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb73-1307"><a href="#cb73-1307" aria-hidden="true" tabindex="-1"></a><span class="in">    const bytes = [_]u8{0x48, 0x65, 0x6C, 0x6C, 0x6F};</span></span>
<span id="cb73-1308"><a href="#cb73-1308" aria-hidden="true" tabindex="-1"></a><span class="in">    try stdout.print("{s}\n", .{bytes});</span></span>
<span id="cb73-1309"><a href="#cb73-1309" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb73-1310"><a href="#cb73-1310" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-1311"><a href="#cb73-1311" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1312"><a href="#cb73-1312" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1313"><a href="#cb73-1313" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1314"><a href="#cb73-1314" aria-hidden="true" tabindex="-1"></a><span class="fu">### Using a slice versus a sentinel-terminated array</span></span>
<span id="cb73-1315"><a href="#cb73-1315" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1316"><a href="#cb73-1316" aria-hidden="true" tabindex="-1"></a>In memory, all string values in Zig are always stored in the same way.</span>
<span id="cb73-1317"><a href="#cb73-1317" aria-hidden="true" tabindex="-1"></a>They are simply stored as sequences/arrays of arbitrary bytes. But you can use and access</span>
<span id="cb73-1318"><a href="#cb73-1318" aria-hidden="true" tabindex="-1"></a>this sequence of bytes in two different ways. You can access this sequence of bytes as:</span>
<span id="cb73-1319"><a href="#cb73-1319" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1320"><a href="#cb73-1320" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>a sentinel-terminated array of <span class="in">`u8`</span> values.</span>
<span id="cb73-1321"><a href="#cb73-1321" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>or as a slice of <span class="in">`u8`</span> values.</span>
<span id="cb73-1322"><a href="#cb73-1322" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1323"><a href="#cb73-1323" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1324"><a href="#cb73-1324" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Sentinel-terminated arrays</span></span>
<span id="cb73-1325"><a href="#cb73-1325" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1326"><a href="#cb73-1326" aria-hidden="true" tabindex="-1"></a>Sentinel-terminated arrays in Zig are described in the Language Reference of Zig<span class="ot">[^sentinel]</span>.</span>
<span id="cb73-1327"><a href="#cb73-1327" aria-hidden="true" tabindex="-1"></a>In summary a sentinel-terminated array is just a normal array, but, the difference is that they</span>
<span id="cb73-1328"><a href="#cb73-1328" aria-hidden="true" tabindex="-1"></a>contain a "sentinel value" at the last index/element of the array. With a sentinel-terminated array</span>
<span id="cb73-1329"><a href="#cb73-1329" aria-hidden="true" tabindex="-1"></a>you embed both the length of the array, and also, the sentinel value in the type itself of your object.</span>
<span id="cb73-1330"><a href="#cb73-1330" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1331"><a href="#cb73-1331" aria-hidden="true" tabindex="-1"></a><span class="ot">[^sentinel]: &lt;https://ziglang.org/documentation/master/#Sentinel-Terminated-Arrays&gt;</span>.</span>
<span id="cb73-1332"><a href="#cb73-1332" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1333"><a href="#cb73-1333" aria-hidden="true" tabindex="-1"></a>For example, if you write a string literal value in your code, and ask Zig to print the data type of this value,</span>
<span id="cb73-1334"><a href="#cb73-1334" aria-hidden="true" tabindex="-1"></a>you usually get a data type in the format <span class="in">`*const [n:0]u8`</span>. The <span class="in">`n`</span> in the data type indicates the size of</span>
<span id="cb73-1335"><a href="#cb73-1335" aria-hidden="true" tabindex="-1"></a>the string (that is the length of the array). The zero after the <span class="in">`n:`</span> part of the data type is the sentinel</span>
<span id="cb73-1336"><a href="#cb73-1336" aria-hidden="true" tabindex="-1"></a>value itself.</span>
<span id="cb73-1337"><a href="#cb73-1337" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1340"><a href="#cb73-1340" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-1341"><a href="#cb73-1341" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: true</span></span>
<span id="cb73-1342"><a href="#cb73-1342" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb73-1343"><a href="#cb73-1343" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb73-1344"><a href="#cb73-1344" aria-hidden="true" tabindex="-1"></a><span class="in">// This is a string literal value:</span></span>
<span id="cb73-1345"><a href="#cb73-1345" aria-hidden="true" tabindex="-1"></a><span class="in">_ = "A literal value";</span></span>
<span id="cb73-1346"><a href="#cb73-1346" aria-hidden="true" tabindex="-1"></a><span class="in">try stdout.print("{any}\n", .{@TypeOf("A literal value")});</span></span>
<span id="cb73-1347"><a href="#cb73-1347" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-1348"><a href="#cb73-1348" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1349"><a href="#cb73-1349" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1350"><a href="#cb73-1350" aria-hidden="true" tabindex="-1"></a>So, with this data type <span class="in">`*const [n:0]u8`</span> you are essentially saying that you have an array of <span class="in">`u8`</span> values</span>
<span id="cb73-1351"><a href="#cb73-1351" aria-hidden="true" tabindex="-1"></a>of length <span class="in">`n`</span>, where, the element at the index corresponding to the length <span class="in">`n`</span> in the array is the</span>
<span id="cb73-1352"><a href="#cb73-1352" aria-hidden="true" tabindex="-1"></a>number zero. If you really think about this description, you will notice that this is just a fancy way to</span>
<span id="cb73-1353"><a href="#cb73-1353" aria-hidden="true" tabindex="-1"></a>describe a string in C, which is a null-terminated array of bytes. The <span class="in">`NULL`</span> value in C is the number</span>
<span id="cb73-1354"><a href="#cb73-1354" aria-hidden="true" tabindex="-1"></a>zero. So, an array that ends in a null/zero value in C is essentially a sentinel-terminated array in Zig,</span>
<span id="cb73-1355"><a href="#cb73-1355" aria-hidden="true" tabindex="-1"></a>where the sentinel value of the array is the number zero.</span>
<span id="cb73-1356"><a href="#cb73-1356" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1357"><a href="#cb73-1357" aria-hidden="true" tabindex="-1"></a>Therefore, a string literal value in Zig is just a pointer to a null-terminated array of bytes (i.e., similar to a C string).</span>
<span id="cb73-1358"><a href="#cb73-1358" aria-hidden="true" tabindex="-1"></a>But in Zig, a string literal value also embeds the length of the string, and also, the fact that they are "NULL terminated",</span>
<span id="cb73-1359"><a href="#cb73-1359" aria-hidden="true" tabindex="-1"></a>into the data type of the value itself.</span>
<span id="cb73-1360"><a href="#cb73-1360" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1361"><a href="#cb73-1361" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1362"><a href="#cb73-1362" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1363"><a href="#cb73-1363" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Slice</span></span>
<span id="cb73-1364"><a href="#cb73-1364" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1365"><a href="#cb73-1365" aria-hidden="true" tabindex="-1"></a>You can also access and use the arbitrary sequence of bytes that represent your string as a slice of <span class="in">`u8`</span> values.</span>
<span id="cb73-1366"><a href="#cb73-1366" aria-hidden="true" tabindex="-1"></a>The majority of functions from the Zig standard library usually receive strings as inputs as slices of</span>
<span id="cb73-1367"><a href="#cb73-1367" aria-hidden="true" tabindex="-1"></a><span class="in">`u8`</span> values (slices were presented in @sec-arrays).</span>
<span id="cb73-1368"><a href="#cb73-1368" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1369"><a href="#cb73-1369" aria-hidden="true" tabindex="-1"></a>Thus, you will see a lot of string values with a data type of <span class="in">`[]u8`</span> or <span class="in">`[]const u8`</span>, depending if the object</span>
<span id="cb73-1370"><a href="#cb73-1370" aria-hidden="true" tabindex="-1"></a>where this string is stored is marked as constant with <span class="in">`const`</span>, or as variable with <span class="in">`var`</span>. Now, because</span>
<span id="cb73-1371"><a href="#cb73-1371" aria-hidden="true" tabindex="-1"></a>the string in this case is being interpreted as a slice, this slice is not necessarilly null-terminated,</span>
<span id="cb73-1372"><a href="#cb73-1372" aria-hidden="true" tabindex="-1"></a>because now, the sentinel value is not mandatory. You can include the null/zero value in the slice if you</span>
<span id="cb73-1373"><a href="#cb73-1373" aria-hidden="true" tabindex="-1"></a>want to, but there is no need to do it.</span>
<span id="cb73-1374"><a href="#cb73-1374" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1377"><a href="#cb73-1377" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-1378"><a href="#cb73-1378" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: true</span></span>
<span id="cb73-1379"><a href="#cb73-1379" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb73-1380"><a href="#cb73-1380" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb73-1381"><a href="#cb73-1381" aria-hidden="true" tabindex="-1"></a><span class="in">// This is a string value being</span></span>
<span id="cb73-1382"><a href="#cb73-1382" aria-hidden="true" tabindex="-1"></a><span class="in">// interpreted as a slice.</span></span>
<span id="cb73-1383"><a href="#cb73-1383" aria-hidden="true" tabindex="-1"></a><span class="in">const str: []const u8 = "A string value";</span></span>
<span id="cb73-1384"><a href="#cb73-1384" aria-hidden="true" tabindex="-1"></a><span class="in">try stdout.print("{any}\n", .{@TypeOf(str)});</span></span>
<span id="cb73-1385"><a href="#cb73-1385" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-1386"><a href="#cb73-1386" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1387"><a href="#cb73-1387" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1388"><a href="#cb73-1388" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1389"><a href="#cb73-1389" aria-hidden="true" tabindex="-1"></a><span class="fu">### Iterating through the string</span></span>
<span id="cb73-1390"><a href="#cb73-1390" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1391"><a href="#cb73-1391" aria-hidden="true" tabindex="-1"></a>If you want to see the actual bytes that represents a string in Zig, you can use</span>
<span id="cb73-1392"><a href="#cb73-1392" aria-hidden="true" tabindex="-1"></a>a <span class="in">`for`</span> loop to iterate through each byte in the string, and ask Zig to print each byte as an hexadecimal</span>
<span id="cb73-1393"><a href="#cb73-1393" aria-hidden="true" tabindex="-1"></a>value to the terminal. You do that by using a <span class="in">`print()`</span> statement with the <span class="in">`X`</span> formatting specifier,</span>
<span id="cb73-1394"><a href="#cb73-1394" aria-hidden="true" tabindex="-1"></a>like you would normally do with the <span class="co">[</span><span class="ot">`printf()` function</span><span class="co">](https://cplusplus.com/reference/cstdio/printf/)</span><span class="ot">[^printfs]</span> in C.</span>
<span id="cb73-1395"><a href="#cb73-1395" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1396"><a href="#cb73-1396" aria-hidden="true" tabindex="-1"></a><span class="ot">[^printfs]: &lt;https://cplusplus.com/reference/cstdio/printf/&gt;</span></span>
<span id="cb73-1397"><a href="#cb73-1397" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1400"><a href="#cb73-1400" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-1401"><a href="#cb73-1401" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: false</span></span>
<span id="cb73-1402"><a href="#cb73-1402" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb73-1403"><a href="#cb73-1403" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb73-1404"><a href="#cb73-1404" aria-hidden="true" tabindex="-1"></a><span class="in">const stdout = std.io.getStdOut().writer();</span></span>
<span id="cb73-1405"><a href="#cb73-1405" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb73-1406"><a href="#cb73-1406" aria-hidden="true" tabindex="-1"></a><span class="in">    const string_object = "This is an example";</span></span>
<span id="cb73-1407"><a href="#cb73-1407" aria-hidden="true" tabindex="-1"></a><span class="in">    try stdout.print("Bytes that represents the string object: ", .{});</span></span>
<span id="cb73-1408"><a href="#cb73-1408" aria-hidden="true" tabindex="-1"></a><span class="in">    for (string_object) |byte| {</span></span>
<span id="cb73-1409"><a href="#cb73-1409" aria-hidden="true" tabindex="-1"></a><span class="in">        try stdout.print("{X} ", .{byte});</span></span>
<span id="cb73-1410"><a href="#cb73-1410" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb73-1411"><a href="#cb73-1411" aria-hidden="true" tabindex="-1"></a><span class="in">    try stdout.print("\n", .{});</span></span>
<span id="cb73-1412"><a href="#cb73-1412" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb73-1413"><a href="#cb73-1413" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-1414"><a href="#cb73-1414" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1415"><a href="#cb73-1415" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1416"><a href="#cb73-1416" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1417"><a href="#cb73-1417" aria-hidden="true" tabindex="-1"></a><span class="fu">### A better look at the object type</span></span>
<span id="cb73-1418"><a href="#cb73-1418" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1419"><a href="#cb73-1419" aria-hidden="true" tabindex="-1"></a>Now, we can inspect better the type of objects that Zig create. To check the type of any object in Zig, you can use the</span>
<span id="cb73-1420"><a href="#cb73-1420" aria-hidden="true" tabindex="-1"></a><span class="in">`@TypeOf()`</span> function. If we look at the type of the <span class="in">`simple_array`</span> object below, you will find that this object</span>
<span id="cb73-1421"><a href="#cb73-1421" aria-hidden="true" tabindex="-1"></a>is an array of 4 elements. Each element is a signed integer of 32 bits which corresponds to the data type <span class="in">`i32`</span> in Zig.</span>
<span id="cb73-1422"><a href="#cb73-1422" aria-hidden="true" tabindex="-1"></a>That is what an object of type <span class="in">`[4]i32`</span> is.</span>
<span id="cb73-1423"><a href="#cb73-1423" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1424"><a href="#cb73-1424" aria-hidden="true" tabindex="-1"></a>But if we look closely at the type of the string literal value exposed below, you will find that this object is a</span>
<span id="cb73-1425"><a href="#cb73-1425" aria-hidden="true" tabindex="-1"></a>constant pointer (hence the <span class="in">`*const`</span> annotation) to an array of 16 elements (or 16 bytes). Each element is a</span>
<span id="cb73-1426"><a href="#cb73-1426" aria-hidden="true" tabindex="-1"></a>single byte (more precisely, an unsigned 8 bit integer - <span class="in">`u8`</span>), that is why we have the <span class="in">`[16:0]u8`</span> portion of the type below,</span>
<span id="cb73-1427"><a href="#cb73-1427" aria-hidden="true" tabindex="-1"></a>and also, you can see that this is a null-terminated array, because of the zero value after the <span class="in">`:`</span> character in the data type.</span>
<span id="cb73-1428"><a href="#cb73-1428" aria-hidden="true" tabindex="-1"></a>In other words, the string literal value exposed below is 16 bytes long.</span>
<span id="cb73-1429"><a href="#cb73-1429" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1430"><a href="#cb73-1430" aria-hidden="true" tabindex="-1"></a>Now, if we create an pointer to the <span class="in">`simple_array`</span> object, then, we get a constant pointer to an array of 4 elements (<span class="in">`*const [4]i32`</span>),</span>
<span id="cb73-1431"><a href="#cb73-1431" aria-hidden="true" tabindex="-1"></a>which is very similar to the type of the string literal value. This demonstrates that a string literal value</span>
<span id="cb73-1432"><a href="#cb73-1432" aria-hidden="true" tabindex="-1"></a>in Zig is already a pointer to a null-terminated array of bytes.</span>
<span id="cb73-1433"><a href="#cb73-1433" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1434"><a href="#cb73-1434" aria-hidden="true" tabindex="-1"></a>Furthermore, if we take a look at the type of the <span class="in">`string_obj`</span> object, you will see that it's a</span>
<span id="cb73-1435"><a href="#cb73-1435" aria-hidden="true" tabindex="-1"></a>slice object (hence the <span class="in">`[]`</span> portion of the type) to a sequence of constant <span class="in">`u8`</span> values (hence</span>
<span id="cb73-1436"><a href="#cb73-1436" aria-hidden="true" tabindex="-1"></a>the <span class="in">`const u8`</span> portion of the type).</span>
<span id="cb73-1437"><a href="#cb73-1437" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1438"><a href="#cb73-1438" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1441"><a href="#cb73-1441" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-1442"><a href="#cb73-1442" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb73-1443"><a href="#cb73-1443" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: false</span></span>
<span id="cb73-1444"><a href="#cb73-1444" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: true</span></span>
<span id="cb73-1445"><a href="#cb73-1445" aria-hidden="true" tabindex="-1"></a><span class="in">#| results: "hide"</span></span>
<span id="cb73-1446"><a href="#cb73-1446" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb73-1447"><a href="#cb73-1447" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb73-1448"><a href="#cb73-1448" aria-hidden="true" tabindex="-1"></a><span class="in">    const simple_array = [_]i32{1, 2, 3, 4};</span></span>
<span id="cb73-1449"><a href="#cb73-1449" aria-hidden="true" tabindex="-1"></a><span class="in">    const string_obj: []const u8 = "A string object";</span></span>
<span id="cb73-1450"><a href="#cb73-1450" aria-hidden="true" tabindex="-1"></a><span class="in">    std.debug.print(</span></span>
<span id="cb73-1451"><a href="#cb73-1451" aria-hidden="true" tabindex="-1"></a><span class="in">        "Type 1: {}\n", .{@TypeOf(simple_array)}</span></span>
<span id="cb73-1452"><a href="#cb73-1452" aria-hidden="true" tabindex="-1"></a><span class="in">    );</span></span>
<span id="cb73-1453"><a href="#cb73-1453" aria-hidden="true" tabindex="-1"></a><span class="in">    std.debug.print(</span></span>
<span id="cb73-1454"><a href="#cb73-1454" aria-hidden="true" tabindex="-1"></a><span class="in">        "Type 2: {}\n", .{@TypeOf("A string literal")}</span></span>
<span id="cb73-1455"><a href="#cb73-1455" aria-hidden="true" tabindex="-1"></a><span class="in">    );</span></span>
<span id="cb73-1456"><a href="#cb73-1456" aria-hidden="true" tabindex="-1"></a><span class="in">    std.debug.print(</span></span>
<span id="cb73-1457"><a href="#cb73-1457" aria-hidden="true" tabindex="-1"></a><span class="in">        "Type 3: {}\n", .{@TypeOf(&amp;simple_array)}</span></span>
<span id="cb73-1458"><a href="#cb73-1458" aria-hidden="true" tabindex="-1"></a><span class="in">    );</span></span>
<span id="cb73-1459"><a href="#cb73-1459" aria-hidden="true" tabindex="-1"></a><span class="in">    std.debug.print(</span></span>
<span id="cb73-1460"><a href="#cb73-1460" aria-hidden="true" tabindex="-1"></a><span class="in">        "Type 4: {}\n", .{@TypeOf(string_obj)}</span></span>
<span id="cb73-1461"><a href="#cb73-1461" aria-hidden="true" tabindex="-1"></a><span class="in">    );</span></span>
<span id="cb73-1462"><a href="#cb73-1462" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb73-1463"><a href="#cb73-1463" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-1464"><a href="#cb73-1464" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1465"><a href="#cb73-1465" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-1466"><a href="#cb73-1466" aria-hidden="true" tabindex="-1"></a><span class="in">Type 1: [4]i32</span></span>
<span id="cb73-1467"><a href="#cb73-1467" aria-hidden="true" tabindex="-1"></a><span class="in">Type 2: *const [16:0]u8</span></span>
<span id="cb73-1468"><a href="#cb73-1468" aria-hidden="true" tabindex="-1"></a><span class="in">Type 3: *const [4]i32</span></span>
<span id="cb73-1469"><a href="#cb73-1469" aria-hidden="true" tabindex="-1"></a><span class="in">Type 4: []const u8</span></span>
<span id="cb73-1470"><a href="#cb73-1470" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-1471"><a href="#cb73-1471" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1472"><a href="#cb73-1472" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1473"><a href="#cb73-1473" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1474"><a href="#cb73-1474" aria-hidden="true" tabindex="-1"></a><span class="fu">### Byte vs unicode points</span></span>
<span id="cb73-1475"><a href="#cb73-1475" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1476"><a href="#cb73-1476" aria-hidden="true" tabindex="-1"></a>It's important to point out that each byte in the array is not necessarily a single character.</span>
<span id="cb73-1477"><a href="#cb73-1477" aria-hidden="true" tabindex="-1"></a>This fact arises from the difference between a single byte and a single unicode point.</span>
<span id="cb73-1478"><a href="#cb73-1478" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1479"><a href="#cb73-1479" aria-hidden="true" tabindex="-1"></a>The encoding UTF-8 works by assigning a number (which is called a unicode point) to each character in</span>
<span id="cb73-1480"><a href="#cb73-1480" aria-hidden="true" tabindex="-1"></a>the string. For example, the character "H" is stored in UTF-8 as the decimal number 72. This means that</span>
<span id="cb73-1481"><a href="#cb73-1481" aria-hidden="true" tabindex="-1"></a>the number 72 is the unicode point for the character "H". Each possible character that can appear in a</span>
<span id="cb73-1482"><a href="#cb73-1482" aria-hidden="true" tabindex="-1"></a>UTF-8 encoded string have its own unicode point.</span>
<span id="cb73-1483"><a href="#cb73-1483" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1484"><a href="#cb73-1484" aria-hidden="true" tabindex="-1"></a>For example, the Latin Capital Letter A With Stroke (Ⱥ) is represented by the number (or the unicode point)</span>
<span id="cb73-1485"><a href="#cb73-1485" aria-hidden="true" tabindex="-1"></a><span class="ss">570. </span>However, this decimal number (570) is higher than the maximum number stored inside a single byte, which</span>
<span id="cb73-1486"><a href="#cb73-1486" aria-hidden="true" tabindex="-1"></a>is 255. In other words, the maximum decimal number that can be represented with a single byte is 255. That is why,</span>
<span id="cb73-1487"><a href="#cb73-1487" aria-hidden="true" tabindex="-1"></a>the unicode point 570 is actually stored inside the computer’s memory as the bytes <span class="in">`C8 BA`</span>.</span>
<span id="cb73-1488"><a href="#cb73-1488" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1491"><a href="#cb73-1491" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-1492"><a href="#cb73-1492" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: false</span></span>
<span id="cb73-1493"><a href="#cb73-1493" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb73-1494"><a href="#cb73-1494" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb73-1495"><a href="#cb73-1495" aria-hidden="true" tabindex="-1"></a><span class="in">const stdout = std.io.getStdOut().writer();</span></span>
<span id="cb73-1496"><a href="#cb73-1496" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb73-1497"><a href="#cb73-1497" aria-hidden="true" tabindex="-1"></a><span class="in">    const string_object = "Ⱥ";</span></span>
<span id="cb73-1498"><a href="#cb73-1498" aria-hidden="true" tabindex="-1"></a><span class="in">    _ = try stdout.write(</span></span>
<span id="cb73-1499"><a href="#cb73-1499" aria-hidden="true" tabindex="-1"></a><span class="in">        "Bytes that represents the string object: "</span></span>
<span id="cb73-1500"><a href="#cb73-1500" aria-hidden="true" tabindex="-1"></a><span class="in">    );</span></span>
<span id="cb73-1501"><a href="#cb73-1501" aria-hidden="true" tabindex="-1"></a><span class="in">    for (string_object) |char| {</span></span>
<span id="cb73-1502"><a href="#cb73-1502" aria-hidden="true" tabindex="-1"></a><span class="in">        try stdout.print("{X} ", .{char});</span></span>
<span id="cb73-1503"><a href="#cb73-1503" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb73-1504"><a href="#cb73-1504" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb73-1505"><a href="#cb73-1505" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-1506"><a href="#cb73-1506" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1507"><a href="#cb73-1507" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1508"><a href="#cb73-1508" aria-hidden="true" tabindex="-1"></a>This means that to store the character Ⱥ in an UTF-8 encoded string, we need to use two bytes together</span>
<span id="cb73-1509"><a href="#cb73-1509" aria-hidden="true" tabindex="-1"></a>to represent the number 570. That is why the relationship between bytes and unicode points is not always</span>
<span id="cb73-1510"><a href="#cb73-1510" aria-hidden="true" tabindex="-1"></a>1 to 1. Each unicode point is a single character in the string, but not always a single byte corresponds</span>
<span id="cb73-1511"><a href="#cb73-1511" aria-hidden="true" tabindex="-1"></a>to a single unicode point.</span>
<span id="cb73-1512"><a href="#cb73-1512" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1513"><a href="#cb73-1513" aria-hidden="true" tabindex="-1"></a>All of this means that if you loop through the elements of a string in Zig, you will be looping through the</span>
<span id="cb73-1514"><a href="#cb73-1514" aria-hidden="true" tabindex="-1"></a>bytes that represents that string, and not through the characters of that string. In the Ⱥ example above,</span>
<span id="cb73-1515"><a href="#cb73-1515" aria-hidden="true" tabindex="-1"></a>the for loop needed two iterations (instead of a single iteration) to print the two bytes that represents this Ⱥ letter.</span>
<span id="cb73-1516"><a href="#cb73-1516" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1517"><a href="#cb73-1517" aria-hidden="true" tabindex="-1"></a>Now, all english letters (or ASCII letters if you prefer) can be represented by a single byte in UTF-8. As a</span>
<span id="cb73-1518"><a href="#cb73-1518" aria-hidden="true" tabindex="-1"></a>consequence, if your UTF-8 string contains only english letters (or ASCII letters), then, you are lucky. Because</span>
<span id="cb73-1519"><a href="#cb73-1519" aria-hidden="true" tabindex="-1"></a>the number of bytes will be equal to the number of characters in that string. In other words, in this specific</span>
<span id="cb73-1520"><a href="#cb73-1520" aria-hidden="true" tabindex="-1"></a>situation, the relationship between bytes and unicode points is 1 to 1.</span>
<span id="cb73-1521"><a href="#cb73-1521" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1522"><a href="#cb73-1522" aria-hidden="true" tabindex="-1"></a>But on the other side, if your string contains other types of letters… for example, you might be working with</span>
<span id="cb73-1523"><a href="#cb73-1523" aria-hidden="true" tabindex="-1"></a>text data that contains, chinese, japanese or latin letters, then, the number of bytes necessary to represent</span>
<span id="cb73-1524"><a href="#cb73-1524" aria-hidden="true" tabindex="-1"></a>your UTF-8 string will likely be much higher than the number of characters in that string.</span>
<span id="cb73-1525"><a href="#cb73-1525" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1526"><a href="#cb73-1526" aria-hidden="true" tabindex="-1"></a>If you need to iterate through the characters of a string, instead of its bytes, then, you can use the</span>
<span id="cb73-1527"><a href="#cb73-1527" aria-hidden="true" tabindex="-1"></a><span class="in">`std.unicode.Utf8View`</span> struct to create an iterator that iterates through the unicode points of your string.</span>
<span id="cb73-1528"><a href="#cb73-1528" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1529"><a href="#cb73-1529" aria-hidden="true" tabindex="-1"></a>In the example below, we loop through the japanese characters “アメリカ”. Each of the four characters in</span>
<span id="cb73-1530"><a href="#cb73-1530" aria-hidden="true" tabindex="-1"></a>this string is represented by three bytes. But the for loop iterates four times, one iteration for each</span>
<span id="cb73-1531"><a href="#cb73-1531" aria-hidden="true" tabindex="-1"></a>character/unicode point in this string:</span>
<span id="cb73-1532"><a href="#cb73-1532" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1535"><a href="#cb73-1535" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-1536"><a href="#cb73-1536" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: false</span></span>
<span id="cb73-1537"><a href="#cb73-1537" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "lib"</span></span>
<span id="cb73-1538"><a href="#cb73-1538" aria-hidden="true" tabindex="-1"></a><span class="in">const std = @import("std");</span></span>
<span id="cb73-1539"><a href="#cb73-1539" aria-hidden="true" tabindex="-1"></a><span class="in">const stdout = std.io.getStdOut().writer();</span></span>
<span id="cb73-1540"><a href="#cb73-1540" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1541"><a href="#cb73-1541" aria-hidden="true" tabindex="-1"></a><span class="in">pub fn main() !void {</span></span>
<span id="cb73-1542"><a href="#cb73-1542" aria-hidden="true" tabindex="-1"></a><span class="in">    var utf8 = try std.unicode.Utf8View.init("アメリカ");</span></span>
<span id="cb73-1543"><a href="#cb73-1543" aria-hidden="true" tabindex="-1"></a><span class="in">    var iterator = utf8.iterator();</span></span>
<span id="cb73-1544"><a href="#cb73-1544" aria-hidden="true" tabindex="-1"></a><span class="in">    while (iterator.nextCodepointSlice()) |codepoint| {</span></span>
<span id="cb73-1545"><a href="#cb73-1545" aria-hidden="true" tabindex="-1"></a><span class="in">        try stdout.print(</span></span>
<span id="cb73-1546"><a href="#cb73-1546" aria-hidden="true" tabindex="-1"></a><span class="in">            "got codepoint {}\n",</span></span>
<span id="cb73-1547"><a href="#cb73-1547" aria-hidden="true" tabindex="-1"></a><span class="in">            .{std.fmt.fmtSliceHexUpper(codepoint)},</span></span>
<span id="cb73-1548"><a href="#cb73-1548" aria-hidden="true" tabindex="-1"></a><span class="in">        );</span></span>
<span id="cb73-1549"><a href="#cb73-1549" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb73-1550"><a href="#cb73-1550" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb73-1551"><a href="#cb73-1551" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1552"><a href="#cb73-1552" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-1553"><a href="#cb73-1553" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1554"><a href="#cb73-1554" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-1555"><a href="#cb73-1555" aria-hidden="true" tabindex="-1"></a><span class="in">got codepoint E382A2</span></span>
<span id="cb73-1556"><a href="#cb73-1556" aria-hidden="true" tabindex="-1"></a><span class="in">got codepoint E383A1</span></span>
<span id="cb73-1557"><a href="#cb73-1557" aria-hidden="true" tabindex="-1"></a><span class="in">got codepoint E383AA</span></span>
<span id="cb73-1558"><a href="#cb73-1558" aria-hidden="true" tabindex="-1"></a><span class="in">got codepoint E382AB</span></span>
<span id="cb73-1559"><a href="#cb73-1559" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-1560"><a href="#cb73-1560" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1561"><a href="#cb73-1561" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1562"><a href="#cb73-1562" aria-hidden="true" tabindex="-1"></a><span class="fu">### Some useful functions for strings {#sec-strings-useful-funs}</span></span>
<span id="cb73-1563"><a href="#cb73-1563" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1564"><a href="#cb73-1564" aria-hidden="true" tabindex="-1"></a>In this section, I just want to quickly describe some functions from the Zig Standard Library</span>
<span id="cb73-1565"><a href="#cb73-1565" aria-hidden="true" tabindex="-1"></a>that are very useful to use when working with strings. Most notably:</span>
<span id="cb73-1566"><a href="#cb73-1566" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1567"><a href="#cb73-1567" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`std.mem.eql()`</span>: to compare if two strings are equal.</span>
<span id="cb73-1568"><a href="#cb73-1568" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`std.mem.splitScalar()`</span>: to split a string into an array of substrings given a delimiter value.</span>
<span id="cb73-1569"><a href="#cb73-1569" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`std.mem.splitSequence()`</span>: to split a string into an array of substrings given a substring delimiter.</span>
<span id="cb73-1570"><a href="#cb73-1570" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`std.mem.startsWith()`</span>: to check if string starts with substring.</span>
<span id="cb73-1571"><a href="#cb73-1571" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`std.mem.endsWith()`</span>: to check if string ends with substring.</span>
<span id="cb73-1572"><a href="#cb73-1572" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`std.mem.trim()`</span>: to remove specific values from both start and end of the string.</span>
<span id="cb73-1573"><a href="#cb73-1573" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`std.mem.concat()`</span>: to concatenate strings together.</span>
<span id="cb73-1574"><a href="#cb73-1574" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`std.mem.count()`</span>: to count the occurrences of substring in the string.</span>
<span id="cb73-1575"><a href="#cb73-1575" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`std.mem.replace()`</span>: to replace the occurrences of substring in the string.</span>
<span id="cb73-1576"><a href="#cb73-1576" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1577"><a href="#cb73-1577" aria-hidden="true" tabindex="-1"></a>Notice that all of these functions come from the <span class="in">`mem`</span> module of</span>
<span id="cb73-1578"><a href="#cb73-1578" aria-hidden="true" tabindex="-1"></a>the Zig Standard Library. This module contains multiple functions and methods</span>
<span id="cb73-1579"><a href="#cb73-1579" aria-hidden="true" tabindex="-1"></a>that are useful to work with memory and sequences of bytes in general.</span>
<span id="cb73-1580"><a href="#cb73-1580" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1581"><a href="#cb73-1581" aria-hidden="true" tabindex="-1"></a>The <span class="in">`eql()`</span> function is used to check if two arrays of data are equal or not.</span>
<span id="cb73-1582"><a href="#cb73-1582" aria-hidden="true" tabindex="-1"></a>Since strings are just arbitrary arrays of bytes, we can use this function to compare two strings together.</span>
<span id="cb73-1583"><a href="#cb73-1583" aria-hidden="true" tabindex="-1"></a>This function returns a boolean value indicating if the two strings are equal</span>
<span id="cb73-1584"><a href="#cb73-1584" aria-hidden="true" tabindex="-1"></a>or not. The first argument of this function is the data type of the elements of the arrays</span>
<span id="cb73-1585"><a href="#cb73-1585" aria-hidden="true" tabindex="-1"></a>that are being compared.</span>
<span id="cb73-1586"><a href="#cb73-1586" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1589"><a href="#cb73-1589" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-1590"><a href="#cb73-1590" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb73-1591"><a href="#cb73-1591" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb73-1592"><a href="#cb73-1592" aria-hidden="true" tabindex="-1"></a><span class="in">const name: []const u8 = "Pedro";</span></span>
<span id="cb73-1593"><a href="#cb73-1593" aria-hidden="true" tabindex="-1"></a><span class="in">try stdout.print(</span></span>
<span id="cb73-1594"><a href="#cb73-1594" aria-hidden="true" tabindex="-1"></a><span class="in">    "{any}\n", .{std.mem.eql(u8, name, "Pedro")}</span></span>
<span id="cb73-1595"><a href="#cb73-1595" aria-hidden="true" tabindex="-1"></a><span class="in">);</span></span>
<span id="cb73-1596"><a href="#cb73-1596" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-1597"><a href="#cb73-1597" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1598"><a href="#cb73-1598" aria-hidden="true" tabindex="-1"></a>The <span class="in">`splitScalar()`</span> and <span class="in">`splitSequence()`</span> functions are useful to split</span>
<span id="cb73-1599"><a href="#cb73-1599" aria-hidden="true" tabindex="-1"></a>a string into multiple fragments, like the <span class="in">`split()`</span> method from Python strings. The difference between these two</span>
<span id="cb73-1600"><a href="#cb73-1600" aria-hidden="true" tabindex="-1"></a>methods is that the <span class="in">`splitScalar()`</span> uses a single character as the separator to</span>
<span id="cb73-1601"><a href="#cb73-1601" aria-hidden="true" tabindex="-1"></a>split the string, while <span class="in">`splitSequence()`</span> uses a sequence of characters (a.k.a. a substring)</span>
<span id="cb73-1602"><a href="#cb73-1602" aria-hidden="true" tabindex="-1"></a>as the separator. There is a practical example of these functions later in the book.</span>
<span id="cb73-1603"><a href="#cb73-1603" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1604"><a href="#cb73-1604" aria-hidden="true" tabindex="-1"></a>The <span class="in">`startsWith()`</span> and <span class="in">`endsWith()`</span> functions are pretty straightforward. They</span>
<span id="cb73-1605"><a href="#cb73-1605" aria-hidden="true" tabindex="-1"></a>return a boolean value indicating if the string (or, more precisely, if the array of data)</span>
<span id="cb73-1606"><a href="#cb73-1606" aria-hidden="true" tabindex="-1"></a>begins (<span class="in">`startsWith`</span>) or ends (<span class="in">`endsWith`</span>) with the sequence provided.</span>
<span id="cb73-1607"><a href="#cb73-1607" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1610"><a href="#cb73-1610" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-1611"><a href="#cb73-1611" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb73-1612"><a href="#cb73-1612" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "run"</span></span>
<span id="cb73-1613"><a href="#cb73-1613" aria-hidden="true" tabindex="-1"></a><span class="in">const name: []const u8 = "Pedro";</span></span>
<span id="cb73-1614"><a href="#cb73-1614" aria-hidden="true" tabindex="-1"></a><span class="in">try stdout.print(</span></span>
<span id="cb73-1615"><a href="#cb73-1615" aria-hidden="true" tabindex="-1"></a><span class="in">    "{any}\n", .{std.mem.startsWith(u8, name, "Pe")}</span></span>
<span id="cb73-1616"><a href="#cb73-1616" aria-hidden="true" tabindex="-1"></a><span class="in">);</span></span>
<span id="cb73-1617"><a href="#cb73-1617" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-1618"><a href="#cb73-1618" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1619"><a href="#cb73-1619" aria-hidden="true" tabindex="-1"></a>The <span class="in">`concat()`</span> function, as the name suggests, concatenate two or more strings together.</span>
<span id="cb73-1620"><a href="#cb73-1620" aria-hidden="true" tabindex="-1"></a>Because the process of concatenating the strings involves allocating enough space to</span>
<span id="cb73-1621"><a href="#cb73-1621" aria-hidden="true" tabindex="-1"></a>accomodate all the strings together, this <span class="in">`concat()`</span> function receives an allocator</span>
<span id="cb73-1622"><a href="#cb73-1622" aria-hidden="true" tabindex="-1"></a>object as input.</span>
<span id="cb73-1623"><a href="#cb73-1623" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1626"><a href="#cb73-1626" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-1627"><a href="#cb73-1627" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb73-1628"><a href="#cb73-1628" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb73-1629"><a href="#cb73-1629" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "ast"</span></span>
<span id="cb73-1630"><a href="#cb73-1630" aria-hidden="true" tabindex="-1"></a><span class="in">const str1 = "Hello";</span></span>
<span id="cb73-1631"><a href="#cb73-1631" aria-hidden="true" tabindex="-1"></a><span class="in">const str2 = " you!";</span></span>
<span id="cb73-1632"><a href="#cb73-1632" aria-hidden="true" tabindex="-1"></a><span class="in">const str3 = try std.mem.concat(</span></span>
<span id="cb73-1633"><a href="#cb73-1633" aria-hidden="true" tabindex="-1"></a><span class="in">    allocator, u8, &amp;[_][]const u8{ str1, str2 }</span></span>
<span id="cb73-1634"><a href="#cb73-1634" aria-hidden="true" tabindex="-1"></a><span class="in">);</span></span>
<span id="cb73-1635"><a href="#cb73-1635" aria-hidden="true" tabindex="-1"></a><span class="in">try stdout.print("{s}\n", .{str3});</span></span>
<span id="cb73-1636"><a href="#cb73-1636" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-1637"><a href="#cb73-1637" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1638"><a href="#cb73-1638" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1639"><a href="#cb73-1639" aria-hidden="true" tabindex="-1"></a>As you can imagine, the <span class="in">`replace()`</span> function is used to replace substrings in a string by another substring.</span>
<span id="cb73-1640"><a href="#cb73-1640" aria-hidden="true" tabindex="-1"></a>This function works very similarly to the <span class="in">`replace()`</span> method from Python strings. Therefore, you</span>
<span id="cb73-1641"><a href="#cb73-1641" aria-hidden="true" tabindex="-1"></a>provide a substring to search, and every time that the <span class="in">`replace()`</span> function finds</span>
<span id="cb73-1642"><a href="#cb73-1642" aria-hidden="true" tabindex="-1"></a>this substring within the input string, it replaces this substring with the "replacement substring"</span>
<span id="cb73-1643"><a href="#cb73-1643" aria-hidden="true" tabindex="-1"></a>that you provided as input.</span>
<span id="cb73-1644"><a href="#cb73-1644" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1645"><a href="#cb73-1645" aria-hidden="true" tabindex="-1"></a>In the example below, we are taking the input string "Hello", and replacing all occurrences</span>
<span id="cb73-1646"><a href="#cb73-1646" aria-hidden="true" tabindex="-1"></a>of the substring "el" inside this input string with "34", and saving the results inside the</span>
<span id="cb73-1647"><a href="#cb73-1647" aria-hidden="true" tabindex="-1"></a><span class="in">`buffer`</span> object. As result, the <span class="in">`replace()`</span> function returns an <span class="in">`usize`</span> value that</span>
<span id="cb73-1648"><a href="#cb73-1648" aria-hidden="true" tabindex="-1"></a>indicates how many replacements were performed.</span>
<span id="cb73-1649"><a href="#cb73-1649" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1650"><a href="#cb73-1650" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1653"><a href="#cb73-1653" aria-hidden="true" tabindex="-1"></a><span class="in">```{zig}</span></span>
<span id="cb73-1654"><a href="#cb73-1654" aria-hidden="true" tabindex="-1"></a><span class="in">#| auto_main: true</span></span>
<span id="cb73-1655"><a href="#cb73-1655" aria-hidden="true" tabindex="-1"></a><span class="in">#| build_type: "lib"</span></span>
<span id="cb73-1656"><a href="#cb73-1656" aria-hidden="true" tabindex="-1"></a><span class="in">const str1 = "Hello";</span></span>
<span id="cb73-1657"><a href="#cb73-1657" aria-hidden="true" tabindex="-1"></a><span class="in">var buffer: [5]u8 = undefined;</span></span>
<span id="cb73-1658"><a href="#cb73-1658" aria-hidden="true" tabindex="-1"></a><span class="in">const nrep = std.mem.replace(</span></span>
<span id="cb73-1659"><a href="#cb73-1659" aria-hidden="true" tabindex="-1"></a><span class="in">    u8, str1, "el", "34", buffer[0..]</span></span>
<span id="cb73-1660"><a href="#cb73-1660" aria-hidden="true" tabindex="-1"></a><span class="in">);</span></span>
<span id="cb73-1661"><a href="#cb73-1661" aria-hidden="true" tabindex="-1"></a><span class="in">try stdout.print("New string: {s}\n", .{buffer});</span></span>
<span id="cb73-1662"><a href="#cb73-1662" aria-hidden="true" tabindex="-1"></a><span class="in">try stdout.print("N of replacements: {d}\n", .{nrep});</span></span>
<span id="cb73-1663"><a href="#cb73-1663" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-1664"><a href="#cb73-1664" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1665"><a href="#cb73-1665" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-1666"><a href="#cb73-1666" aria-hidden="true" tabindex="-1"></a><span class="in">New string: H34lo</span></span>
<span id="cb73-1667"><a href="#cb73-1667" aria-hidden="true" tabindex="-1"></a><span class="in">N of replacements: 1</span></span>
<span id="cb73-1668"><a href="#cb73-1668" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb73-1669"><a href="#cb73-1669" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1670"><a href="#cb73-1670" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1671"><a href="#cb73-1671" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1672"><a href="#cb73-1672" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1673"><a href="#cb73-1673" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1674"><a href="#cb73-1674" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1675"><a href="#cb73-1675" aria-hidden="true" tabindex="-1"></a><span class="fu">## Safety in Zig</span></span>
<span id="cb73-1676"><a href="#cb73-1676" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1677"><a href="#cb73-1677" aria-hidden="true" tabindex="-1"></a>A general trend in modern low-level programming languages is safety. As our modern world</span>
<span id="cb73-1678"><a href="#cb73-1678" aria-hidden="true" tabindex="-1"></a>becomes more interconnected with technology and computers,</span>
<span id="cb73-1679"><a href="#cb73-1679" aria-hidden="true" tabindex="-1"></a>the data produced by all of this technology becomes one of the most important</span>
<span id="cb73-1680"><a href="#cb73-1680" aria-hidden="true" tabindex="-1"></a>(and also, one of the most dangerous) assets that we have.</span>
<span id="cb73-1681"><a href="#cb73-1681" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1682"><a href="#cb73-1682" aria-hidden="true" tabindex="-1"></a>This is probably the main reason why modern low-level programming languages</span>
<span id="cb73-1683"><a href="#cb73-1683" aria-hidden="true" tabindex="-1"></a>have been giving great attention to safety, especially memory safety, because</span>
<span id="cb73-1684"><a href="#cb73-1684" aria-hidden="true" tabindex="-1"></a>memory corruption is still the main target for hackers to exploit.</span>
<span id="cb73-1685"><a href="#cb73-1685" aria-hidden="true" tabindex="-1"></a>The reality is that we don't have an easy solution for this problem.</span>
<span id="cb73-1686"><a href="#cb73-1686" aria-hidden="true" tabindex="-1"></a>For now, we only have techniques and strategies that mitigates these</span>
<span id="cb73-1687"><a href="#cb73-1687" aria-hidden="true" tabindex="-1"></a>problems.</span>
<span id="cb73-1688"><a href="#cb73-1688" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1689"><a href="#cb73-1689" aria-hidden="true" tabindex="-1"></a>As Richard Feldman explains on his <span class="co">[</span><span class="ot">most recent GOTO conference talk</span><span class="co">](https://www.youtube.com/watch?v=jIZpKpLCOiU&amp;ab_channel=GOTOConferences)</span><span class="ot">[^gotop]</span></span>
<span id="cb73-1690"><a href="#cb73-1690" aria-hidden="true" tabindex="-1"></a>, we haven't figured it out yet a way to achieve **true safety in technology**.</span>
<span id="cb73-1691"><a href="#cb73-1691" aria-hidden="true" tabindex="-1"></a>In other words, we haven't found a way to build software that won't be exploited</span>
<span id="cb73-1692"><a href="#cb73-1692" aria-hidden="true" tabindex="-1"></a>with 100% certainty. We can greatly reduce the risks of our software being</span>
<span id="cb73-1693"><a href="#cb73-1693" aria-hidden="true" tabindex="-1"></a>exploited, by ensuring memory safety for example. But this is not enough</span>
<span id="cb73-1694"><a href="#cb73-1694" aria-hidden="true" tabindex="-1"></a>to achieve "true safety" territory.</span>
<span id="cb73-1695"><a href="#cb73-1695" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1696"><a href="#cb73-1696" aria-hidden="true" tabindex="-1"></a>Because even if you write your program in a "safe language", hackers can still</span>
<span id="cb73-1697"><a href="#cb73-1697" aria-hidden="true" tabindex="-1"></a>exploit failures in the operating system where your program is running (e.g. maybe the</span>
<span id="cb73-1698"><a href="#cb73-1698" aria-hidden="true" tabindex="-1"></a>system where your code is running has a "backdoor exploit" that can still</span>
<span id="cb73-1699"><a href="#cb73-1699" aria-hidden="true" tabindex="-1"></a>affect your code in unexpected ways), or also, they can exploit the features</span>
<span id="cb73-1700"><a href="#cb73-1700" aria-hidden="true" tabindex="-1"></a>from the architecture of your computer. A recently found exploit</span>
<span id="cb73-1701"><a href="#cb73-1701" aria-hidden="true" tabindex="-1"></a>that involves memory invalidation through a feature of "memory tags"</span>
<span id="cb73-1702"><a href="#cb73-1702" aria-hidden="true" tabindex="-1"></a>present in ARM chips is an example of that <span class="co">[</span><span class="ot">@exploit1</span><span class="co">]</span>.</span>
<span id="cb73-1703"><a href="#cb73-1703" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1704"><a href="#cb73-1704" aria-hidden="true" tabindex="-1"></a><span class="ot">[^gotop]: &lt;https://www.youtube.com/watch?v=jIZpKpLCOiU&amp;ab_channel=GOTOConferences&gt;</span></span>
<span id="cb73-1705"><a href="#cb73-1705" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1706"><a href="#cb73-1706" aria-hidden="true" tabindex="-1"></a>The question is: what have Zig and other languages been doing to mitigate this problem?</span>
<span id="cb73-1707"><a href="#cb73-1707" aria-hidden="true" tabindex="-1"></a>If we take Rust as an example, Rust is, for the most part<span class="ot">[^rust-safe]</span>, a memory safe</span>
<span id="cb73-1708"><a href="#cb73-1708" aria-hidden="true" tabindex="-1"></a>language by enforcing specific rules to the developer. In other words, the key feature</span>
<span id="cb73-1709"><a href="#cb73-1709" aria-hidden="true" tabindex="-1"></a>of Rust, the *borrow checker*, forces you to follow a specific logic when you are writing</span>
<span id="cb73-1710"><a href="#cb73-1710" aria-hidden="true" tabindex="-1"></a>your Rust code, and the Rust compiler will always complain everytime you try to go out of this</span>
<span id="cb73-1711"><a href="#cb73-1711" aria-hidden="true" tabindex="-1"></a>pattern.</span>
<span id="cb73-1712"><a href="#cb73-1712" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1713"><a href="#cb73-1713" aria-hidden="true" tabindex="-1"></a><span class="ot">[^rust-safe]: </span>Actually, a lot of existing Rust code is still memory unsafe, because they communicate with external libraries through FFI (*foreign function interface*), which disables the borrow-checker features through the <span class="in">`unsafe`</span> keyword.</span>
<span id="cb73-1714"><a href="#cb73-1714" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1715"><a href="#cb73-1715" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1716"><a href="#cb73-1716" aria-hidden="true" tabindex="-1"></a>In contrast, the Zig language is not a memory safe language by default.</span>
<span id="cb73-1717"><a href="#cb73-1717" aria-hidden="true" tabindex="-1"></a>There are some memory safety features that you get for free in Zig,</span>
<span id="cb73-1718"><a href="#cb73-1718" aria-hidden="true" tabindex="-1"></a>especially in arrays and pointer objects. But there are other tools</span>
<span id="cb73-1719"><a href="#cb73-1719" aria-hidden="true" tabindex="-1"></a>offered by the language, that are not used by default.</span>
<span id="cb73-1720"><a href="#cb73-1720" aria-hidden="true" tabindex="-1"></a>In other words, the <span class="in">`zig`</span> compiler does not obligate you to use such tools.</span>
<span id="cb73-1721"><a href="#cb73-1721" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1722"><a href="#cb73-1722" aria-hidden="true" tabindex="-1"></a>The tools listed below are related to memory safety. That is, they help you to achieve</span>
<span id="cb73-1723"><a href="#cb73-1723" aria-hidden="true" tabindex="-1"></a>memory safety in your Zig code:</span>
<span id="cb73-1724"><a href="#cb73-1724" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1725"><a href="#cb73-1725" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`defer`</span> allows you to keep free operations physically close to allocations. This helps you to avoid memory leaks, "use after free", and also "double-free" problems. Furthermore, it also keeps free operations logically tied to the end of the current scope, which greatly reduces the mental overhead about object lifetime.</span>
<span id="cb73-1726"><a href="#cb73-1726" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`errdefer`</span> helps you to guarantee that your program frees the allocated memory, even if a runtime error occurs.</span>
<span id="cb73-1727"><a href="#cb73-1727" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>pointers and objects are non-nullable by default. This helps you to avoid memory problems that might arise from de-referencing null pointers.</span>
<span id="cb73-1728"><a href="#cb73-1728" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Zig offers some native types of allocators (called "testing allocators") that can detect memory leaks and double-frees. These types of allocators are widely used on unit tests, so they transform your unit tests into a weapon that you can use to detect memory problems in your code.</span>
<span id="cb73-1729"><a href="#cb73-1729" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>arrays and slices in Zig have their lengths embedded in the object itself, which makes the <span class="in">`zig`</span> compiler very effective on detecting "index out-of-range" type of errors, and avoiding buffer overflows.</span>
<span id="cb73-1730"><a href="#cb73-1730" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1731"><a href="#cb73-1731" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1732"><a href="#cb73-1732" aria-hidden="true" tabindex="-1"></a>Despite these features that Zig offers that are related to memory safety issues, the language</span>
<span id="cb73-1733"><a href="#cb73-1733" aria-hidden="true" tabindex="-1"></a>also has some rules that help you to achieve another type of safety, which is more related to</span>
<span id="cb73-1734"><a href="#cb73-1734" aria-hidden="true" tabindex="-1"></a>program logic safety. These rules are:</span>
<span id="cb73-1735"><a href="#cb73-1735" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1736"><a href="#cb73-1736" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>pointers and objects are non-nullable by default. Which eliminates an edge case that might break the logic of your program.</span>
<span id="cb73-1737"><a href="#cb73-1737" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>switch statements must exaust all possible options.</span>
<span id="cb73-1738"><a href="#cb73-1738" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>the <span class="in">`zig`</span> compiler forces you to handle every possible error in your program.</span>
<span id="cb73-1739"><a href="#cb73-1739" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1740"><a href="#cb73-1740" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1741"><a href="#cb73-1741" aria-hidden="true" tabindex="-1"></a><span class="fu">## Other parts of Zig</span></span>
<span id="cb73-1742"><a href="#cb73-1742" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1743"><a href="#cb73-1743" aria-hidden="true" tabindex="-1"></a>We already learned a lot about Zig's syntax, and also, some pretty technical</span>
<span id="cb73-1744"><a href="#cb73-1744" aria-hidden="true" tabindex="-1"></a>details about it. Just as a quick recap:</span>
<span id="cb73-1745"><a href="#cb73-1745" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1746"><a href="#cb73-1746" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>We talked about how functions are written in Zig in @sec-root-file and @sec-main-file.</span>
<span id="cb73-1747"><a href="#cb73-1747" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>How to create new objects/identifiers in @sec-root-file and especially in @sec-assignments.</span>
<span id="cb73-1748"><a href="#cb73-1748" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>How strings work in Zig in @sec-zig-strings.</span>
<span id="cb73-1749"><a href="#cb73-1749" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>How to use arrays and slices in @sec-arrays.</span>
<span id="cb73-1750"><a href="#cb73-1750" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>How to import functionality from other Zig modules in @sec-root-file.</span>
<span id="cb73-1751"><a href="#cb73-1751" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1752"><a href="#cb73-1752" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1753"><a href="#cb73-1753" aria-hidden="true" tabindex="-1"></a>But, for now, this amount of knowledge is enough for us to continue with this book.</span>
<span id="cb73-1754"><a href="#cb73-1754" aria-hidden="true" tabindex="-1"></a>Later, over the next chapters we will still talk more about other parts of</span>
<span id="cb73-1755"><a href="#cb73-1755" aria-hidden="true" tabindex="-1"></a>Zig's syntax that are also equally important. Such as:</span>
<span id="cb73-1756"><a href="#cb73-1756" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1757"><a href="#cb73-1757" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-1758"><a href="#cb73-1758" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>How Object-Oriented programming can be done in Zig through *struct declarations* in @sec-structs-and-oop.</span>
<span id="cb73-1759"><a href="#cb73-1759" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Basic control flow syntax in @sec-zig-control-flow.</span>
<span id="cb73-1760"><a href="#cb73-1760" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Enums in @sec-enum;</span>
<span id="cb73-1761"><a href="#cb73-1761" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Pointers and Optionals in @sec-pointer;</span>
<span id="cb73-1762"><a href="#cb73-1762" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Error handling with <span class="in">`try`</span> and <span class="in">`catch`</span> in @sec-error-handling;</span>
<span id="cb73-1763"><a href="#cb73-1763" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Unit tests in @sec-unittests;</span>
<span id="cb73-1764"><a href="#cb73-1764" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Vectors in @sec-vectors-simd;</span>
<span id="cb73-1765"><a href="#cb73-1765" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Build System in @sec-build-system;</span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>