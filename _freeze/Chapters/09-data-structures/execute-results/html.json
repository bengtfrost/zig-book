{
  "hash": "0d90c199a3a2c5a7a25c66baac2ca8aa",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\nknitr: true\nsyntax-definition: \"../Assets/zig.xml\"\n---\n\n\n\n\n\n\n\n# Data Structures\n\nIn this chapter, I want to present the most common Data Structures that are available from\nthe Zig Standard Library, especially `ArrayList` and also `HashMap`. These are generic Data Structures\nthat you can use to store and control any type of data that is produced by your application.\n\n## Dynamic Arrays {#sec-dynamic-array}\n\nIn high level languages, arrays are usually dynamic. They can easily grow\nin size when they have to, and you don't need to worry about it.\nIn contrast, arrays in low level languages are usually static by default.\nThis is the reality of C, C++, Rust and also Zig. Static arrays were presented at\n@sec-arrays, but in this section, we are going to talk about dynamic arrays in Zig.\n\nDynamic arrays are simply arrays that can grow in size during the runtime\nof your program. Most low level languages have some implementation of\na dynamic array in their standard library. C++ have `std::vector`, Rust have `Vec`,\nand Zig have `std.ArrayList`.\n\nThe `std.ArrayList` struct provides a contiguous and growable array for you.\nIt works like any other dynamic array, it allocates a contiguous block of memory, and when this block have no space left,\n`ArrayList` allocates another contiguous and bigger block of memory, copies the\nelements to this new location, and erases (or frees) the previous block of memory.\n\n\n### Capacity vs Length\n\nWhen we talk about dynamic arrays, we usually have two similar concepts that\nare very essential to how a dynamic array works behind the hood.\nThese concepts are *capacity* and *length*. In some contexts, especially\nin C++, *length* is also called of *size*.\n\nAlthough they look similar, these concepts represent different things\nin the context of a dynamic array. *Capacity* is the number of items (or elements)\nthat your dynamic array can currently hold without the need to allocate more memory.\n\nIn contrast, the *length* refers to how many elements in the array\nare currently being used, or, in other words, how many elements in this array\nthat you have assigned a value to. Every dynamic array works around\na block of allocated memory, which represents an array with total capacity for $n$ elements.\nHowever, only a portion of these $n$ elements are being used most of the time. This portion\nof $n$ is the *length* of the array. So every time you append a new value\nto the array, you are incrementing its *length* by one.\n\nThis means that a dynamic array usually works with an extra margin, or an extra space\nthat is currently empty, but waiting and ready to be used. This \"extra space\"\nis essentially the difference between *capacity* and *length*. *Capacity* represents\nthe total number of elements that the array can hold without the need to re-allocate\nor re-expand the array, while the *length* represents how much of this capacity\nis currently being used to hold/store values.\n\n@fig-capacity-length presents this idea visually. Notice that, at first,\nthe capacity of the array is greater than the length of the array.\nSo, the dynamic array have extra space that is currently empty, but it\nis ready to receive a value to be stored.\n\n![Difference between capacity and length in a dynamic array](./../Figures/dynamic-array.png){#fig-capacity-length}\n\nWe can also see in @fig-capacity-length that, when *length* and *capacity* are equal, it means that the array have no space left.\nWe have reached the ceiling of our capacity, and because of that, if we want to store more values\nin this array, we need to expand it. We need to get a bigger space that can hold more values\nthan what we currently have.\n\nA dynamic array works by expanding the underlying array, whenever the *length* becomes equal\nto the *capacity* of the array. It basically allocates a new contiguous block of memory that is bigger\nthan the previous one, then, it copies all values that are currently being stored to this new\nlocation (i.e., this new block of memory), then, it frees the previous block of\nmemory. At the end of this process, the new underlying array have a bigger *capacity*, and, therefore,\nthe *length* becomes, once again, smaller than the *capacity* of the array.\n\nThis is the cycle of a dynamic array. Notice that, throughout this cycle, the *capacity* is always\neither equal to or higher than the *length* of the array. If you have an `ArrayList` object (let's suppose\nyou named it `buffer`), you can check the current capacity of your array by accessing the `capacity`\nattribute of your `ArrayList` object, while the current *length* of it is available at the `items.len`\nattribute.\n\n\n\n::: {.cell}\n\n```{.zig .cell-code}\n// Check capacity\nbuffer.capacity;\n// Check length\nbuffer.items.len;\n```\n:::\n\n\n\n### Creating an `ArrayList` object\n\nIn order to use `ArrayList`, you must provide an allocator object to it.\nRemember, Zig does not have a default memory allocator. And as I described in @sec-allocators, all memory\nallocations must be done by an allocator object that you define, that\nyou have control over. In our example here, I'm going to use\na general purpose allocator, but you can use any other allocator\nof your preference.\n\nWhen you initialize an `ArrayList` object, you must provide the data type of the elements of\nthe array. In other words, this defines the type of data that this array (or container) will\nstore. Therefore, if I provide the `u8` type to it, then, I will create a dynamic\narray of `u8` values. However, if I provide a struct that I have defined instead, like the struct `User`\nfrom @sec-structs-and-oop, then, a dynamic array of `User` values\nwill be created. In the example below, with the expression `ArrayList(u8)` we\nare creating a dynamic array of `u8` values.\n\nAfter you provide the data type of the elements of the array, you can initialize\nan `ArrayList` object by either using the `init()` or the `initCapacity()` methods.\nThe former method receives only the allocator object\nas input, while the latter method receives both the allocator object and a capacity number as inputs.\nWith the latter method, you not only initialize the struct, but you\nalso set the starting capacity of the allocated array.\n\nUsing the `initCapacity()` method is the preferred way to initialize your dynamic array.\nBecause reallocations, or, in other words, the process of expanding the capacity of the array,\nis always a high cost operation. You should take any possible opportunity to avoid reallocations in\nyour array. If you know how much space your array needs to occupy at the beginning,\nyou should always use `initCapacity()` to create your dynamic array.\n\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nvar gpa = std.heap.GeneralPurposeAllocator(.{}){};\nconst allocator = gpa.allocator();\nvar buffer = try std.ArrayList(u8)\n    .initCapacity(allocator, 100);\ndefer buffer.deinit();\n```\n:::\n\n\n\nIn the example above, the `buffer` object starts as an array of 100 elements. If this\n`buffer` object needs to create more space to accomodate more elements during the runtime of your program, the `ArrayList`\ninternals will perform the necessary actions for you automatically.\nAlso notice the `deinit()` method being used to destroy the `buffer` object at the\nend of the current scope, by freeing all the memory that was allocated for the dynamic\narray stored in this `buffer` object.\n\n\n### Adding new elements to the array\n\nNow that we have created our dynamic array, we can start to use it. You can append (a.k.a \"add\")\nnew values to this array by using the `append()` method. This method works the same way\nas the `append()` method from a Python list, or, the `emplace_back()` method from `std::vector` of C++.\nYou provide a single value to this method, and the method appends this value to the array.\n\nYou can also use the `appendSlice()` method to append multiple values at once. You provide\na slice (slices were described in @sec-arrays) to this method, and the method adds all values present\nin this slice to your dynamic array.\n\n\n::: {.cell}\n\n```{.zig .cell-code}\ntry buffer.append('H');\ntry buffer.append('e');\ntry buffer.append('l');\ntry buffer.append('l');\ntry buffer.append('o');\ntry buffer.appendSlice(\" World!\");\n```\n:::\n\n\n### Removing elements from the array {#sec-dynamic-array-remove}\n\nYou can use the `pop()` method to \"pop\" or remove\nthe last element in the array. It's worth noting that this method\ndo not change the capacity of the array. It just deletes or erases\nthe last value stored in the array.\n\nAlso, this method returns as result the value that got deleted. That is, you can\nuse this method to both get the last value in the array, and also, remove\nit from the array. It's a \"get and remove value\" type of method.\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst exclamation_mark = buffer.pop();\n```\n:::\n\n\nNow, if you want to remove specific elements from specific positions\nof your array, you can use the `orderedRemove()` method from your\n`ArrayList` object. With this method, you can provide an index as input,\nthen, the method will delete the value that is at this index in the array.\nYou are effectively reducing the *length* of the array everytime you execute\nan `orderedRemove()` operation.\n\nIn the example below, we first create an `ArrayList` object, and we fill it\nwith numbers. Then, we use `orderedRemove()` to remove the value at\nindex 3 in the array, two consecutive times.\n\nAlso, notice that we are assigning the result of `orderedRemove()` to the\nunderscore character. So we are discarding the result value of this method.\nThe `orderedRemove()` method returns the value that got deleted, in a similar\nstyle to the `pop()` method.\n\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nvar gpa = std.heap.GeneralPurposeAllocator(.{}){};\nconst allocator = gpa.allocator();\nvar buffer = try std.ArrayList(u8)\n    .initCapacity(allocator, 100);\ndefer buffer.deinit();\n\nfor (0..10) |i| {\n    const index: u8 = @intCast(i);\n    try buffer.append(index);\n}\n\nstd.debug.print(\n    \"{any}\\n\", .{buffer.items}\n);\n_ = buffer.orderedRemove(3);\n_ = buffer.orderedRemove(3);\n\nstd.debug.print(\"{any}\\n\", .{buffer.items});\nstd.debug.print(\"{any}\\n\", .{buffer.items.len});\n```\n:::\n\n\n```\n{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }\n{ 0, 1, 2, 5, 6, 7, 8, 9 }\n8\n```\n\nOne key characteristic about `orderedRemove()` is that it preserves the order\nof the values in the array. So, it deletes the value that you asked it to\nremove, but it also makes sure that the order of the values that remain in the array\nstay the same as before.\n\nNow, if you don't care about the order of the values, for example, maybe you want to treat\nyour dynamic array as a set of values, like the `std::unordered_set`\nstructure from C++, you can use the `swapRemove()` method instead. This method\nworks similarly to the `orderedRemove()` method. You give an index to this\nmethod, then, it deletes the value that is at this index in the array.\nBut this method does not preserve the original order of the values that remain\nin the array. As a result, `swapRemove()` is, in general, faster than `orderedRemove()`.\n\n\n### Inserting elements at specific indexes\n\nWhen you need to insert values in the middle of your array,\ninstead of just appending them to the end of the array, you need to use\nthe `insert()` and `insertSlice()` methods, instead of\nthe `append()` and `appendSlice()` methods.\n\nThese two methods work very similarly to `insert()` and `insert_range()`\nfrom the C++ `std::vector` class. You provide an index to these methods,\nand they insert the values that you provide at that index in the array.\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nvar gpa = std.heap.GeneralPurposeAllocator(.{}){};\nconst allocator = gpa.allocator();\nvar buffer = try std.ArrayList(u8)\n    .initCapacity(allocator, 10);\ndefer buffer.deinit();\n\ntry buffer.appendSlice(\"My Pedro\");\ntry buffer.insert(4, '3');\ntry buffer.insertSlice(2, \" name\");\nfor (buffer.items) |char| {\n    try stdout.print(\"{c}\", .{char});\n}\n```\n:::\n\n\n```\nMy name P3edro\n```\n\n\n### Conclusion\n\nIf you feel the lack of some other method, I recommend\nyou to read the [official documentation for the `ArrayListAligned`](https://ziglang.org/documentation/master/std/#std.array_list.ArrayListAligned)[^zig-array2]\nstruct, which describes most of the methods available\nthrough the `ArrayList` object.\n\nYou will notice that there is a lot of other methods in this page that\nI did not described here, and I recommend you to explore these methods,\nand understand how they work.\n\n[^zig-array2]: <https://ziglang.org/documentation/master/std/#std.array_list.ArrayListAligned>\n\n\n\n## Maps or HashTables {#sec-maps-hashtables}\n\nSome professionals know this type of data structure by different terms, like \"map\",\n\"hashmap\" or \"associative arrays\". But the most common term used is *hashtable*.\nEvery programming language normally have some implementation of a hashtable in their\nstandard libraries. Python have `dict()`, C++ have `std::map` and `std::unordered_map`, Rust\nhave `HashMap`, Javascript have `Object()` and `Map()`, etc.\n\n\n\n### What is a hashtable?\n\nA hashtable is a data structure based on key-value pairs.\nYou provide a key and a value to this structure, then, the hashtable will store\nthe input value at a location that can be identified by the input\nkey that you provided.\nIt does that by using an underlying array and a hash function.\nThese two components are essential to how a hashtable works.\n\nUnder the hood, the hashtable contains an array. This array is where the values\nare stored, and the elements of this array are usually called of *buckets*.\nSo the values that you provide to the hashtable are stored inside buckets,\nand you access each bucket by using an index.\n\nWhen you provide a key to a hashtable, it passes this key to the\nhash function. This hash function uses some sort of hashing algorithm to transform\nthis key into an index. This index is actually an array index. It's a position\nin the underlying array of the hashtable.\nThis is how a key identifies a specific position (or location) inside the hashtable\nstructure.\n\nTherefore, you provide a key to the hashtable, and this key identifies a specific location\ninside the hashtable, then, the hashtable takes the input value that you provided,\nand stores this value in the location identified by this input key.\nYou could say that the key maps to the value stored in the hashtable. You find\nthe value, by using the key that identifies the location where the value is stored.\nThe @fig-hashtable presents this process visually.\n\n\n![A diagram of a Hashtable. Source: Wikipedia, the free encyclopedia.](./../Figures/hashtable.svg){#fig-hashtable}\n\n\nThe operation described in the previous paragraph is normally called an *insertion* operation.\nBecause you are inserting new values into the hashtable.\nBut there are other types of operations in hashtables such as *delete* and *lookup*.\nDelete is self describing, it's when you delete (or remove) a value from the hashtable.\nWhile lookup corresponds to when you look at a value that is stored in\nthe hashtable, by using the key that identifies the location where this value is stored.\n\nSometimes, instead of storing the values directly, the underlying array of the hashtable might be an array of pointers,\ni.e., the buckets of the array stores pointers that points to the value,\nor also, may be an array of linked lists.\nThese cases are common on hashtables that allows duplicate keys, or, in other words,\non hashtables that effectively handle \"collisions\" that may arise from the hash function.\n\nDuplicate keys, or this \"collision\" thing that I'm talking about, is when you have two different keys\nthat points to the same location (i.e., to the same index)\nin the underlying array of the hashtable. This might happen depending on the characteristics of the hash function\nthat is being used in the hashtable. Some implementations of the hashtable will actively deal with collisions,\nmeaning that, they will handle this case in some way. For example, the hashtable\nmight transform all buckets into linked lists. Because with a linked list you can store\nmultiple values into a single bucket.\n\nThere are different techniques to handle collisions in hashtables, which I will not describe\nin this book, because it's not our main scope here. But you can find a good description of\nsome of the most common techniques at the Wikipedia page of hashtables [@wikipedia_hashtables].\n\n\n### Hashtables in Zig {#sec-hashmap}\n\nThe Zig Standard Library provides different implementations of a hashtable.\nEach implementation have its own cons and pros, which we will\ndiscuss later on, and all of them are available through the `std.hash_map` module.\n\nThe `HashMap` struct is a general-purpose hashtable,\nwhich have very fast operations (lookup, insertion, delete), and also,\nquite high load factors for low memory usage. You can create and provide a context object\nto the `HashMap` constructor. This context object allows you to tailor\nthe behaviour of the hashtable itself, because you can\nprovide a hash function implementation to be used by the hashtable\nthrough this context object.\n\nBut let's not worry about this context object now, because it's meant to be used\nby \"experts in the field of hashtables\". Since we are most likely not\nexperts in this field, we are going to take the easy way to create\na hashtable. Which is by using the `AutoHashMap()` function.\n\n\nThis `AutoHashMap()` function is essentially a \"create a hashtable object that uses the default settings\"\ntype of function. It automatically chooses a context object, and, therefore, a hash function implementation,\nfor you. This function receives two data types as input, the first input is the data type of the keys\nthat will be used in this hashtable, while the second input is the data type of the data that will be\nstored inside the hashtable, that is, the data type of the values to be stored.\n\nIn the example below, we are providing the data type `u32` in the first argument, and `u16` in the second argument of this\nfunction. This means that we are going to use `u32` values as keys in this hashtable, while `u16` values are the actual values\nthat are going to be stored into this hashtable.\nAt the end of this process, the `hash_table` object contains a `HashMap` object\nthat uses the default settings and context.\n\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst std = @import(\"std\");\nconst AutoHashMap = std.hash_map.AutoHashMap;\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n    var hash_table = AutoHashMap(u32, u16).init(allocator);\n    defer hash_table.deinit();\n\n    try hash_table.put(54321, 89);\n    try hash_table.put(50050, 55);\n    try hash_table.put(57709, 41);\n    std.debug.print(\n        \"N of values stored: {d}\\n\",\n        .{hash_table.count()}\n    );\n    std.debug.print(\n        \"Value at key 50050: {d}\\n\",\n        .{hash_table.get(50050).?}\n    );\n\n    if (hash_table.remove(57709)) {\n        std.debug.print(\n            \"Value at key 57709 successfully removed!\\n\",\n            .{}\n        );\n    }\n    std.debug.print(\n        \"N of values stored: {d}\\n\",\n        .{hash_table.count()}\n    );\n}\n```\n:::\n\n\n```\nN of values stored: 3\nValue at key 50050: 55\nValue at key 57709 successfully removed!\nN of values stored: 2\n```\n\nYou can add/put new values into the hashtable by using the `put()` method. The first argument\nis the key to be used, and the second argument is the actual value that you want to store inside\nthe hashtable. In the example below, we first add the value 89 using the key 54321, next, we add\nthe value 55 using the key 50050, etc.\n\nNotice that we have used the method `count()` to see how many values are currently stored in the\nhashtable. After that, we also use the `get()` method to access (or look) at the value stored in\nthe position identified by the key 500050. The output of this `get()` method is an optional value.\nThis is why we use the `?` method at the end to get the actual value.\n\nAlso notice that we can remove (or delete) values from the hashtable by using the `remove()` method.\nYou provide the key that identifies the value that you want to delete, then, the method will\ndelete this value and return a `true` value as output. This `true` value essentially tells us\nthat the method successfully deleted the value.\n\nBut this delete operation might not be always successful. For example, you might provide the wrong\nkey to this method. I mean, maybe you provide\n(either intentionally or unintentionally) a key that points to an empty bucket,\ni.e., a bucket that still doesn't have a value in it.\nIn this case, the `remove()` method would return a `false` value.\n\n\n\n### Iterating through the hashtable\n\nIterating through the keys and values that are currently being stored in\nthe hashtable is a very common necessity.\nYou can do that in Zig by using an iterator object that can iterate\nthrough the elements of your hashtable object.\n\nThis iterator object works like any other iterator object that you would\nfind in languages such as C++ and Rust. It's basically a pointer object\nthat points to some value in the container, and has a `next()` method\nthat you can use to navigate (or iterate) through the values in the\ncontainer.\n\nYou can create such iterator object by using the `iterator()` method of the hashtable object.\nThis method returns an iterator object, from which you can use the `next()` method in conjunction\nwith a while loop to iterate through the elements of your hashtable. The `next()` method returns an optional\n`Entry` value, and therefore, you must unwrap this optional value to get the actual `Entry` value\nfrom which you can access the key and also the value identified by this key.\n\nWith this `Entry` value at hand, you can access the key of this current entry by using the `key_ptr`\nattribute and dereferencing the pointer that lives inside of it, while the value identified by this\nkey is accessed through the `value_ptr` attribute instead, which is also a pointer to be dereferenced.\nThe code example below demonstrates the use of these elements:\n\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst std = @import(\"std\");\nconst AutoHashMap = std.hash_map.AutoHashMap;\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n    var hash_table = AutoHashMap(u32, u16).init(allocator);\n    defer hash_table.deinit();\n\n    try hash_table.put(54321, 89);\n    try hash_table.put(50050, 55);\n    try hash_table.put(57709, 41);\n\n    var it = hash_table.iterator();\n    while (it.next()) |kv| {\n        // Access the current key\n        std.debug.print(\"Key: {d} | \", .{kv.key_ptr.*});\n        // Access the current value\n        std.debug.print(\"Value: {d}\\n\", .{kv.value_ptr.*});\n    }\n}\n```\n:::\n\n\n```\nKey: 54321 | Value: 89\nKey: 50050 | Value: 55\nKey: 57709 | Value: 41\n```\n\n\nIf you want to iterate specifically through the values or the keys of your hashtable,\nyou can create a key iterator or a value iterator object. These are also iterator\nobjects, which have the same `next()` method that you can use to iterate through the\nhashtable.\n\nKey iterators are created from the `keyIterator()` method of your\nhashtable object, while value iterators are created from the `valueIterator()` method.\nAll you have to do is to unwrap the value from the `next()` method and deference it\ndirectly to access the key or the value that you are iterating over.\nThe code example below demonstrates the use of a key iterator,\nbut you can replicate the same logic to a value iterator.\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nvar kit = hash_table.keyIterator();\nwhile (kit.next()) |key| {\n    std.debug.print(\"Key: {d}\\n\", .{key.*});\n}\n```\n:::\n\n\n```\nKey: 54321\nKey: 50050\nKey: 57709\n```\n\n\n### The `ArrayHashMap` hashtable {#sec-array-map}\n\nIf you need to iterate through the elements of your hashtable constantly,\nyou might want to use the `ArrayHashMap` struct for your specific case,\ninstead of going with the usual and general-purpose `HashMap` struct.\n\nThe `ArrayHashMap` struct creates a hashtable that is faster to iterate over.\nThat is why this specific type of hashtable might be valuable to you.\nSome other properties of a `ArrayHashMap` hashtable are:\n\n- the order of insertion is preserved, i.e., the order of the values that you find while iterating through this hashtable is actually the order in which these values were inserted in the hashtable.\n- the key-value pairs are stored sequentially, one after another.\n\n\nYou can create an `ArrayHashMap` object by using, once again, a helper function that\nchooses automatically for you a hash function implementation. This is the\n`AutoArrayHashMap()` function, which works very similarly to the `AutoHashMap()`\nfunction that we presented in @sec-hashmap.\n\nYou provide two data types to this function. The data type of the keys that will be\nused in this hashtable, and the data type of the values that will be stored in\nthis hashtable.\n\nAn `ArrayHashMap` object have essentially the exact same methods from the `HashMap` struct.\nSo you can insert new values into the hashtable by using the `put()` method, and you can look (or get)\na value from the hashtable by using the `get()` method. But the `remove()` method is not available\nin this specific type of hashtable.\n\nIn order to delete values from the hashtable, you would use the same methods that you find in\nan `ArrayList` object, i.e., a dynamic array. I presented these methods in @sec-dynamic-array-remove,\nwhich are the `swapRemove()` and `orderedRemove()` methods. These methods have the same meaning here, or,\nthe same effect that they have in an `ArrayList` object.\n\nThis means that, with `swapRemove()` you remove the value from the hashtable, but you do not preserve\nthe order in which the values were inserted into the structure. While `orderedRemove()` is able\nto retain the order in which these values were inserted.\n\nBut instead of providing an index as input to `swapRemove()` or `orderedRemove()`, like I described\nin @sec-dynamic-array-remove, these methods here in an `ArrayHashMap` take a key as input, like\nthe `remove()` method from a `HashMap` object. If you want to provide an index as input, instead\nof a key, you should use the `swapRemoveAt()` and `orderedRemoveAt()` methods.\n\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nvar hash_table = AutoArrayHashMap(u32, u16)\n    .init(allocator);\ndefer hash_table.deinit();\n```\n:::\n\n\n\n\n### The `StringHashMap` hashtable {#sec-string-hash-map}\n\nOne thing that you will notice in the other two types of hashtables that I have\npresented over the last sections, is that neither of them accepts a slice data type\nin their keys.\nWhat this means is that you cannot use a slice value to represent a key in\nthese types of hashtable.\n\nThe most obvious consequence of this, is that you cannot use strings as keys\nin these hashtables. But it's extremely common to use strings as keys\nin hashtables.\n\nTake this very simple Javascript code snippet as an example. We are creating\na simple hashtable object named `people`. Then, we add a new entry to this\nhashtable, which is identified by the string `'Pedro'`. This string is the\nkey in this case, while the object containing different personal information such as\nage, height and city, is the value to be stored in the hashtable.\n\n```js\nvar people = new Object();\npeople['Pedro'] = {\n    'age': 25,\n    'height': 1.67,\n    'city': 'Belo Horizonte'\n};\n```\n\nThis pattern of using strings as keys is very common in\nall sorts of situations. That is why the Zig Standard Library offers a\nspecific type of hashtable for this purpose, which is created through the `StringHashMap()` function.\nThis function creates a hashtable that uses strings as keys. The only input of this\nfunction is the data type of the values that will be stored into this hashtable.\n\nIn the example below, I'm creating a hashtable to store the ages of different people.\nEach key in this hashtable is represented by the name of each person, while the value stored in the\nhashtable is the age of this person identified by the key.\n\nThat is why I provide the `u8` data type (which is the data type used by the age values) as input to this `StringHashMap()` function.\nAs the result, it creates a hashtable that uses string values as keys, and, that stores\n`u8` values in it. Notice that an allocator object is provided at the `init()` method of the\nresulting object from the `StringHashMap()` function.\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst std = @import(\"std\");\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n    var ages = std.StringHashMap(u8).init(allocator);\n    defer ages.deinit();\n\n    try ages.put(\"Pedro\", 25);\n    try ages.put(\"Matheus\", 21);\n    try ages.put(\"Abgail\", 42);\n\n    var it = ages.iterator();\n    while (it.next()) |kv| {\n        std.debug.print(\"Key: {s} | \", .{kv.key_ptr.*});\n        std.debug.print(\"Age: {d}\\n\", .{kv.value_ptr.*});\n    }\n}\n```\n:::\n\n\n```\nKey: Pedro | Age: 25\nKey: Abgail | Age: 42\nKey: Matheus | Age: 21\n```\n\n\n### The `StringArrayHashMap` hashtable\n\nThe Zig Standard Library also provides a type of hashtable that mix the cons and pros of the\n`StringHashMap` and `ArrayHashMap` together. That is, a hashtable\nthat uses strings as keys, but also have the advantages from `ArrayHashMap`.\nIn other words, you can have a hashtable that is fast to iterate over,\nthat preserves insertion order, and also, that uses strings as keys.\n\nYou can create such type of hashtable by using the `StringArrayHashMap()` function.\nThis function accepts a data type as input, which is the data type of the values that are\ngoing to be stored inside this hashtable, in the same style as the function presented\nin @sec-string-hash-map.\n\nYou can insert new values into this hashtable by using the same `put()` method that\nwe have discussed in @sec-string-hash-map. And you can also get values from the hashtable\nby using the same `get()` method.\nLike its `ArrayHashMap` brother, to delete values from this specific type of hashtable,\nwe also use the `orderedRemove()` and `swapRemove()` methods, with the same effects that\nI have described in @sec-array-map.\n\nIf we take the code example that was exposed in @sec-string-hash-map, we can\nachieve the exact same result with `StringArrayHashMap()`:\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nvar ages = std.StringArrayHashMap(u8).init(allocator);\n```\n:::\n\n\n\n\n\n## Linked lists\n\nThe Zig Standard Library provides an implementation for both singly and doubly linked lists.\nMore specifically, through the structs `SinglyLinkedList` and `DoublyLinkedList`.\n\nIn case you are not familiar with these data structures, a linked list is a linear data structure that looks\nlike a chain, or, a rope. The main advantage of this data structure is that you normally have very fast\ninsertion and deletion operations. But, as a disadvantage, iterating through\nthis data structure is usually not so fast as iterating through an array.\n\nThe idea behind a linked list is to build a structure that consists of a sequence of nodes\nconnected to each other by pointers. This means that linked lists are usually not contiguous\nin memory, because each node might be anywhere in memory. They do not need to be close to\none another.\n\nIn @fig-linked-list we can see a diagram of a singly linked list. We begin at the first node\n(which is usually called \"the head of the linked list\"). Then, from this\nfirst node we uncover the remaining nodes in the structure, by following the locations pointed\nby the pointers found in each node.\n\nEach node has two things in it. It has the value that is stored in the current node\n, and also, a pointer. This pointer points to the next node in the list. If this pointer\nis null, then, it means that we have reached the end of our linked list.\n\n![A diagram of a singly linked list.](./../Figures/linked-list.png){#fig-linked-list}\n\n\nIn @fig-linked-list2 we can see a diagram of a doubly linked list. The only thing that really\nchanges now is that every node in the linked list has both a pointer to the previous node,\nand, a pointer to the next node. So every node in a doubly linked list has two pointers in it. These are\nusually called the `prev` (for \"previous\") and the `next` (for \"next\") pointers of the node.\n\nIn the singly linked list example, we had only one single pointer in each node, and this singular\npointer was always pointing to the next node in the sequence. This means that singly linked lists\nnormally have only the `next` pointer in them.\n\n![A diagram of a doubly linked list.](./../Figures/doubly-linked-list.png){#fig-linked-list2}\n\n\n\n### Recent change in the API\n\nOn previous versions of Zig, the `SinglyLinkedList` and `DoublyLinkedList` structs were initially implemented as \"generics data structures\".\nMeaning that, you would use a generic function to create a singly (or doubly) linked list that could store\nthe specific data type that you wanted to use. We will learn more about generics at @sec-generics, and also,\nhow we can create a \"generic data structure\" at @sec-generic-struct.\n\nHowever, on the latest versions of Zig, the structs `SinglyLinkedList` and `DoublyLinkedList` were altered to use a\n\"less generic API\". This specific change was introduced on April 3, 2025. Therefore, check if your Zig version is one released after this\ndate. Just have in mind that if you don't have a very recent version of the Zig compiler,\nyou might have problems while trying to compile the next examples exposed here.\n\n\n\n### How to use a singly linked list\n\nFor example, consider that you are creating a singly linked list that is going to store `u32` values.\nGiven this scenario, the first thing that we need to do, is to create a \"node type\" that is capable\nof storing a `u32` value. The `NodeU32` type exposed below demonstrates such \"node type\".\n\nNotice that the data type associated with the member named `data` is the most important part of this\ncustom \"node type\". It determines the data type that is going to be stored in each node.\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst std = @import(\"std\");\nconst NodeU32 = struct {\n    data: u32,\n    node: std.SinglyLinkedList.Node = .{},\n};\n```\n:::\n\n\nAfter we created our custom \"node type\" that can store the specific data type that we\nwant, we can just create a new and empty singly linked list, which will store our nodes.\nTo do that, we just create a new object with the type `SinglyLinkedList`, like this:\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nvar list: std.SinglyLinkedList = .{};\n```\n:::\n\n\nNow, we have our linked list... But how can we insert nodes in it? Well, first of all,\nwe need to create our nodes. So let's focus on that first. The snippet exposed below demonstrates\nhow we could use our `NodeU32` struct to create such nodes.\n\nNotice in this snippet that we are just setting the `data` member of the struct for now.\nWe don't need to connect these nodes together in this first instance. This is why we ignore\nthe `node` member at first. But we are going to connect these nodes in a future point of the code, which is\nwhy these objects are marked as \"variable objects\", so that we can alter them in the future.\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nvar one: NodeU32 = .{ .data = 1 };\nvar two: NodeU32 = .{ .data = 2 };\nvar three: NodeU32 = .{ .data = 3 };\nvar five: NodeU32 = .{ .data = 5 };\n```\n:::\n\n\nNow that we have both the linked list and also the nodes created, we can start to connect them together.\nYou can use the `prepend()` method from the linked list object to insert the first node in the list, which\nis the \"head\" of the linked list. As the name suggests, this specific method prepends the input node to the linked list,\nor, in other words, it transforms the input node into the first node of the list.\n\nAfter we added the \"head node\" of the list, we can start to add the \"next nodes\" in the list by using the `insertAfter()` method\nfrom the `SinglyLinkedList.Node` type, which, in our case here, is accessible through the `node` member of our\n`NodeU32` type. Thus, we can start to create the connections between the nodes by calling this method from the node objects\nthat are present in the list. Like in this example below:\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nlist.prepend(&two.node); // {2}\ntwo.node.insertAfter(&five.node); // {2, 5}\ntwo.node.insertAfter(&three.node); // {2, 3, 5}\n```\n:::\n\n\nYou can also call the `prepend()` method again to add new nodes to the beginning of the linked list, which\nmeans, effectively, changing the \"head node\" of the list, like this:\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nlist.prepend(&one.node); // {1, 2, 3, 5}\n```\n:::\n\n\n\nThere are other methods available from the singly linked list object that you might be interested. You can find a\nsummary of them in the bullet points below:\n\n- `remove()` to remove a specific node from the linked list.\n- `len()` to count how many nodes there is in the linked list.\n- `popFirst()` to remove the first node (i.e., the \"head\") from the linked list.\n\nSo, that is how singly linked lists work in Zig in a nutshell. To sum up,\nthis is all the source code that was exposed in this section inside the single cell:\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst NodeU32 = struct {\n    data: u32,\n    node: std.SinglyLinkedList.Node = .{},\n};\n\nvar list: std.SinglyLinkedList = .{};\nvar one: NodeU32 = .{ .data = 1 };\nvar two: NodeU32 = .{ .data = 2 };\nvar three: NodeU32 = .{ .data = 3 };\nvar five: NodeU32 = .{ .data = 5 };\n\nlist.prepend(&two.node); // {2}\ntwo.node.insertAfter(&five.node); // {2, 5}\ntwo.node.insertAfter(&three.node); // {2, 3, 5}\nlist.prepend(&one.node); // {1, 2, 3, 5}\n\ntry stdout.print(\"Number of nodes: {}\", .{list.len()});\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNumber of nodes: 4\n```\n\n\n:::\n:::\n\n\n\n### How to use a doubly linked list\n\nIf you want to use a doubly linked list instead, you will face a similar workflow compared to the\nsingly linked list:\n\n1. You first create a \"custom node type\" that can store the specific data type that you want.\n2. Create an empty doubly linked list object.\n3. Create the nodes of linked list.\n4. Start to insert the nodes inside the list.\n\nIn your \"custom node type\", you should use the `DoublyLinkedList.Node` type to denote\nthe `node` member of the struct. The snippet below demonstrates that. Here we are creating,\nonce again, a node type that can store `u32` values. But this time, this struct is tailored\nto be used inside a `DoublyLinkedList` struct.\n\nAfter this step, the way that you create the new empty linked list, and the nodes that you want insert,\nis practically identical to the singly linked list case. But, this time,\nwe normally use the `append()` method from the linked list object to add new nodes to the list.\n\nThis `append()` method from the linked list object will always append the input node to the end of the\nlinked list. However, in case you want to add the new node into a different position of the list, then,\nyou should take a look at the `insertAfter()` and `insertBefore()` methods of the linked list object.\nThese methods allow you to insert the new node either after or before an existing node in the list.\n\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst NodeU32 = struct {\n    data: u32,\n    node: std.DoublyLinkedList.Node = .{},\n};\n\nvar list: std.DoublyLinkedList = .{};\nvar one: NodeU32 = .{ .data = 1 };\nvar two: NodeU32 = .{ .data = 2 };\nvar three: NodeU32 = .{ .data = 3 };\nvar five: NodeU32 = .{ .data = 5 };\n\nlist.append(&one.node); // {1}\nlist.append(&three.node); // {1, 3}\nlist.insertAfter(\n    &one.node,\n    &five.node\n); // {1, 5, 3}\nlist.append(&two.node); // {1, 5, 3, 2}\n\ntry stdout.print(\"Number of nodes: {}\", .{list.len()});\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNumber of nodes: 4\n```\n\n\n:::\n:::\n\n\nThese are other methods from the `DoublyLinkedList` object that might interest you:\n\n- `remove()`: to remove a specific node from the list.\n- `len()`: to count the number of nodes in the list.\n- `prepend()`: to add a node to the beginning of the list (i.e. set the head node of the list).\n- `pop()`: to remove the last node of the list.\n- `popFirst()`: to remove the first node of the list.\n- `concatByMoving()`: to concat two doubly linked lists together.\n\n\n### Iterating through the linked list\n\nIf you want to iterate over the elements of the linked list, all you need to do is to follow\nthe trail created by the \"pointer to next node\". We usually do that inside a while loop, that simply goes to the\nnext node over and over, until it finds a null pointer, which means that we hit the end of the list.\n\nThis next example demonstrates how such while loop would work. Notice that we are using the `@fieldParentPtr()`\nbuilt-in function to get access to a pointer that points to the parent instance of the `node` object. In other words,\nwe get access to a pointer to the `NodeU32` instance that contains the current node. This way, we can use this pointer\nto access the data that is currently stored in this node.\n\nAlso notice that in each iteration of the while loop, we are changing the value of the `it` variable to the next node\nin the list. The while loop is interrupted in the moment that this `it` variable becomes null, which will happen\nwhen the there is not \"next node\" in the list, which means that we have reached the end of the list.\n\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst NodeU32 = struct {\n    data: u32,\n    node: std.SinglyLinkedList.Node = .{},\n};\n\nvar list: std.SinglyLinkedList = .{};\nvar one: NodeU32 = .{ .data = 1 };\nvar two: NodeU32 = .{ .data = 2 };\nvar three: NodeU32 = .{ .data = 3 };\nvar five: NodeU32 = .{ .data = 5 };\n\nlist.prepend(&two.node); // {2}\nlist.prepend(&five.node); // {5, 2}\nlist.prepend(&three.node); // {3, 5, 2}\nlist.prepend(&one.node); // {1, 3, 5, 2}\n\nvar it = list.first;\nwhile (it) |node| : (it = node.next) {\n    const l: *NodeU32 = @fieldParentPtr(\n        \"node\", node\n    );\n    try stdout.print(\n        \"Current value: {}\", .{l.data}\n    );\n}\n```\n:::\n\n\n```\nCurrent value: 1\nCurrent value: 3\nCurrent value: 5\nCurrent value: 2\n```\n\n\n\n\n## Multi array structure\n\nZig introduces a new data structure called `MultiArrayList()`. It's a different version of the dynamic array\nthat we have introduced in @sec-dynamic-array. The difference between this structure and the `ArrayList()`\nthat we know from @sec-dynamic-array, is that `MultiArrayList()` creates a separate dynamic array\nfor each field of the struct that you provide as input.\n\nConsider the following code example. We create a new custom struct called `Person`. This\nstruct contains three different data members, or, three different fields. As consequence,\nwhen we provide this `Person` data type as input to `MultiArrayList()`, this\ncreates a \"struct of three different arrays\" called `PersonArray`. In other words,\nthis `PersonArray` is a struct that contains three internal dynamic arrays in it.\nOne array for each field found in the `Person` struct definition.\n\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nconst std = @import(\"std\");\nconst Person = struct {\n    name: []const u8,\n    age: u8,\n    height: f32,\n};\nconst PersonArray = std.MultiArrayList(Person);\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n    var people = PersonArray{};\n    defer people.deinit(allocator);\n\n    try people.append(allocator, .{\n        .name = \"Auguste\", .age = 15, .height = 1.54\n    });\n    try people.append(allocator, .{\n        .name = \"Elena\", .age = 26, .height = 1.65\n    });\n    try people.append(allocator, .{\n        .name = \"Michael\", .age = 64, .height = 1.87\n    });\n}\n```\n:::\n\n\nIn other words, instead of creating an array of \"persons\", the `MultiArrayList()` function\ncreates a \"struct of arrays\". Each data member of this struct is a different array that stores\nthe values of a specific field from the `Person` values that were added (or, appended) to this \"struct of arrays\".\nOne important detail is that each of these separate internal arrays stored inside `PersonArray`\nare dynamic arrays. This means that these arrays can grow in capacity automatically as needed, to accomodate\nmore values.\n\nThe @fig-multi-array exposed below presents a diagram that describes the `PersonArray` struct\nthat we have created in the previous code example. Notice that the values of the data members\npresent in each of the three `Person` values that we have appended into the `PersonArray` object\n, are scattered across three different internal arrays of the `PersonArray` object.\n\n![A diagram of the `PersonArray` struct.](./../Figures/multi-array.png){#fig-multi-array}\n\nYou can easily access each of these arrays separately, and iterate over the values of each array.\nFor that, you will need to call the `items()` method from the `PersonArray` object, and provide as input\nto this method, the name of the field that you want to iterate over.\nIf you want to iterate through the `.age` array for example, then, you need to call `items(.age)` from\nthe `PersonArray` object, like in the example below:\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nfor (people.items(.age)) |*age| {\n    try stdout.print(\"Age: {d}\\n\", .{age.*});\n}\n```\n:::\n\n\n```\nAge: 15\nAge: 26\nAge: 64\n```\n\n\nIn the above example, we are iterating over the values of the `.age` array, or,\nthe internal array of the `PersonArray` object that contains the values of the `age`\ndata member from the `Person` values that were added to the multi array struct.\n\nIn this example we are calling the `items()` method directly from the `PersonArray`\nobject. However, in most situations it's recommened to call this `items()` method\nfrom a \"slice object\", which you can create from the `slice()` method.\nThe reason for this is that calling `items()` multiple times have better performance\nif you use a slice object.\n\nTherefore, if you are planning to access only one of the\ninternal arrays from your \"multi array struct\", it's fine to call `items()` directly\nfrom the multi array object. But if you need to access many of the internal arrays\nfrom your \"multi array struct\", then, you will likely need to call `items()` more\nthan once, and, in such circumstance, is better to call `items()` through a slice object.\nThe example below demonstrates the use of such object:\n\n\n::: {.cell}\n\n```{.zig .cell-code}\nvar slice = people.slice();\nfor (slice.items(.age)) |*age| {\n    age.* += 10;\n}\nfor (slice.items(.name), slice.items(.age)) |*n,*a| {\n    try stdout.print(\n        \"Name: {s}, Age: {d}\\n\", .{n.*, a.*}\n    );\n}\n```\n:::\n\n\n```\nName: Auguste, Age: 25\nName: Elena, Age: 36\nName: Michael, Age: 74\n```\n\n\n## Conclusion\n\nThere are many other data structures that I haven't presented here.\nBut you can check them out at the official Zig Standard Library documentation page.\nActually, when you get into the [homepage of the documentation](https://ziglang.org/documentation/master/std/#)[^home], the first thing\nthat appears to you in this page, is a list of types and data structures that\nare available in the Zig Standard Library.\nThere are some very specific data structures in this list, like a\n[`BoundedArray` struct](https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArray)[^bounded]\n, but there is also some more general structures, such as a\n[`PriorityQueue` struct](https://ziglang.org/documentation/master/std/#std.priority_queue.PriorityQueue)[^priority].\n\n\n[^home]: <https://ziglang.org/documentation/master/std/#>\n[^priority]: <https://ziglang.org/documentation/master/std/#std.priority_queue.PriorityQueue>.\n[^bounded]: <https://ziglang.org/documentation/master/std/#std.bounded_array.BoundedArray>\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}